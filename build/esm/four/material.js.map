{"version":3,"file":"material.js","sources":["../../../src/four/material.ts"],"sourcesContent":["import { AffineMat4, Obj4 } from \"../math/algebra/affine.js\";\r\nimport { Vec4 } from \"../math/algebra/vec4.js\";\r\nimport { generateUUID } from \"../math/random.js\";\r\nimport { TetraSlicePipeline } from \"../render/slice/slice.js\";\r\nimport { Renderer } from \"./renderer.js\";\r\nimport { Geometry } from \"./scene.js\";\r\nimport { _generateVertShader } from \"./vertexshader.js\";\r\n\r\nexport type ColorOutputNode = MaterialNode & { output: \"color\" };\r\nexport type Vec4OutputNode = MaterialNode & { output: \"vec4\" };\r\nexport type FloatOutputNode = MaterialNode & { output: \"f32\" };\r\nexport type TransformOutputNode = MaterialNode & { output: \"affineMat4\" };\r\n\r\n/** An iterative structure for Material */\r\nexport class MaterialNode {\r\n    identifier: string;\r\n    input: { [name: string]: MaterialNode } = {};\r\n    output: string;\r\n    static constFractionDigits = 4;\r\n    getCode(r: Renderer, root: Material, outputToken: string): string { return \"\"; }\r\n    getInputCode(r: Renderer, root: Material, token: string) {\r\n        let out: { [name: string]: string } = {};\r\n        let code = \"\";\r\n        for (let [name, node] of globalThis.Object.entries(this.input)) {\r\n            let inputToken = token + \"_\" + name;\r\n            out[name] = inputToken;\r\n            code += node.getCode(r, root, inputToken) + \"\\n\";\r\n        };\r\n        return { token: out, code };\r\n    }\r\n    update(r: Renderer) {\r\n        for (let node of globalThis.Object.values(this.input)) {\r\n            node.update(r);\r\n        }\r\n    }\r\n    constructor(identifier: string) { this.identifier = identifier; }\r\n}\r\n/** Material is the top node of MaterialNode */\r\nexport class Material extends MaterialNode {\r\n    cullMode: GPUCullMode = \"front\";\r\n    compiling = false;\r\n    compiled = false;\r\n    needsUpdate = true;\r\n    output = \"shader\";\r\n    pipeline: TetraSlicePipeline;\r\n    uuid: string;\r\n    bindGroup: GPUBindGroup[];\r\n    bindGroupBuffers: GPUBuffer[] = [];\r\n    fetchBuffers: string[] = [];\r\n    declUniforms: { [name: string]: { location: number, type: string, buffer: GPUBuffer } } = {};\r\n    declUniformLocation = 0;\r\n    declVarys: string[] = [];\r\n    declHeaders: { [name: string]: string };\r\n    createBindGroup(r: Renderer, p: TetraSlicePipeline) {\r\n        this.bindGroup = this.bindGroupBuffers.length ? [r.core.createFragmentShaderBindGroup(p, 0, this.bindGroupBuffers)] : [];\r\n    }\r\n    init(r: Renderer) {\r\n        this.getShaderCode(r); // scan code to get binding infomations\r\n        this.compiling = false;\r\n        this.compiled = true;\r\n    }\r\n    async compile(r: Renderer) {\r\n        this.compiling = true;\r\n        r.pullPipeline(this.identifier, \"compiling\");\r\n        let { vs, fs } = this.getShaderCode(r);\r\n        this.pipeline = await r.core.createTetraSlicePipeline({\r\n            vertex: { code: vs, entryPoint: \"main\" },\r\n            fragment: { code: fs, entryPoint: \"fourMain\" },\r\n            cullMode: this.cullMode\r\n        });\r\n        r.pullPipeline(this.identifier, this.pipeline);\r\n        this.compiling = false;\r\n        this.compiled = true;\r\n    }\r\n    // when a subnode uses vary input, call this function to check attribute buffer and construct input structure\r\n    addVary(a: string) {\r\n        if (!this.declVarys.includes(a)) {\r\n            this.declVarys.push(a);\r\n        }\r\n        if (a == \"pos\") return;\r\n        if (!this.fetchBuffers.includes(a)) {\r\n            this.fetchBuffers.push(a);\r\n        }\r\n    }\r\n    // when a subnode uses header, call this function to check whether headers are already included\r\n    addHeader(key: string, value: string) {\r\n        if (!this.declHeaders[key]) {\r\n            this.declHeaders[key] = value;\r\n        } else if (this.declHeaders[key] !== value) {\r\n            console.warn(`Found multiple definition of header \"${key}\".`);\r\n        }\r\n    }\r\n    // when a subnode uses uniform, call this function to add uniform globally\r\n    addUniform(type: string, u: string, buffer: GPUBuffer) {\r\n        if (!this.declUniforms[u]) {\r\n            this.declUniforms[u] = { location: this.declUniformLocation++, type, buffer };\r\n            this.bindGroupBuffers.push(buffer);\r\n        }\r\n    }\r\n    fetchBuffer(g: Geometry): GPUBuffer[] {\r\n        //sort buffer fetchBuffers\r\n        return [g.gpuBuffer[\"position\"], ...this.fetchBuffers.map(b => g.gpuBuffer[b])];\r\n    }\r\n    getShaderCode(r: Renderer): { vs: string, fs: string } {\r\n        // what we need in jsData except for position buffer\r\n        this.fetchBuffers = [];\r\n        // renderPipeline's uniform variables except for world light (in another group)\r\n        this.declUniforms = {};\r\n        // output of computeShader, also input for fragment shader\r\n        this.declVarys = [];\r\n        this.bindGroupBuffers = [];\r\n        // renderPipeline's uniform bindgroup's location number\r\n        this.declUniformLocation = 0;\r\n        this.declHeaders = {};\r\n        // iteratively generate code\r\n        let code = this.getCode(r, this, \"\");\r\n        // deal no need for vary input\r\n        let fsIn = this.declVarys.length ? 'vary: fourInputType' : \"\";\r\n        let lightCode = r.lightShaderInfomation.lightCode;\r\n        let headers = globalThis.Object.values(this.declHeaders).join(\"\\n\");\r\n        // if no uniform at group0, then bind lights on 0, or 1\r\n        if (this.declUniformLocation === 0) { lightCode = lightCode.replace(\"@group(1)\", \"@group(0)\") }\r\n        let header = headers + lightCode + `\r\n    struct tsxAffineMat{\r\n        matrix: mat4x4f,\r\n        vector: vec4f,\r\n    }\r\n    @fragment fn fourMain(${fsIn}) -> @location(0) vec4f {\r\n        let ambientLightDensity = uWorldLight.ambientLightDensity.xyz;`; // avoid basic material doesn't call this uniform at all\r\n        // if frag shader has input, we need to construct a struct fourInputType\r\n        if (fsIn) {\r\n            let struct = `    struct fourInputType{\\n`;\r\n            for (let i = 0, l = this.declVarys.length; i < l; i++) {\r\n                struct += `        @location(${i}) ${this.declVarys[i]}: vec4f,\\n`;\r\n            }\r\n            struct += \"    }\\n\";\r\n            header = struct + header;\r\n        }\r\n        for (let [u, { location, type }] of globalThis.Object.entries(this.declUniforms)) {\r\n            header = `   @group(0) @binding(${location}) var<uniform> ${u}:${type};\\n` + header;\r\n        }\r\n        // we use the result from getCode to generate needed vertex variables\r\n        return { vs: _generateVertShader(this.fetchBuffers, this.declVarys), fs: header + code + `\\n   }` };\r\n    }\r\n\r\n    constructor(identifiers: string) {\r\n        super(identifiers);\r\n        this.uuid = generateUUID();\r\n    }\r\n    gpuUniformBuffer: { [name: string]: GPUBuffer };\r\n}\r\n/** ConstValue will be hardcoded in shader */\r\nclass ConstValue extends MaterialNode {\r\n    getCode(r: Renderer, root: Material, outputToken: string) {\r\n        return `\r\n                const ${outputToken} = ${this.identifier};`;\r\n    }\r\n    constructor(identifier: string) {\r\n        super(identifier);\r\n    }\r\n}\r\nclass ColorConstValue extends ConstValue {\r\n    declare output: \"color\";\r\n    constructor(color: GPUColor) {\r\n        let r: number = (color as GPUColorDict)?.r ?? color[0] ?? 0;\r\n        let g: number = (color as GPUColorDict)?.g ?? color[1] ?? 0;\r\n        let b: number = (color as GPUColorDict)?.b ?? color[2] ?? 0;\r\n        let a: number = (color as GPUColorDict)?.a ?? color[3] ?? 1;\r\n        super(`vec4f(${r.toFixed(MaterialNode.constFractionDigits)},${g.toFixed(MaterialNode.constFractionDigits)},${b.toFixed(MaterialNode.constFractionDigits)},${a.toFixed(MaterialNode.constFractionDigits)})`);\r\n    }\r\n}\r\nclass Vec4ConstValue extends ConstValue {\r\n    declare output: \"vec4\";\r\n    constructor(vec: Vec4) {\r\n        super(`vec4f(${vec.flat().map(n => n.toFixed(MaterialNode.constFractionDigits)).join(\",\")})`);\r\n    }\r\n}\r\nclass FloatConstValue extends ConstValue {\r\n    declare output: \"f32\";\r\n    constructor(f: number) {\r\n        super(f.toFixed(MaterialNode.constFractionDigits));\r\n    }\r\n}\r\nclass TransformConstValue extends ConstValue {\r\n    declare output: \"affineMat4\";\r\n    constructor(v: Obj4) {\r\n        let afmat = v.getAffineMat4();\r\n        let matEntries = afmat.mat.ts().elem.map(n => n.toFixed(MaterialNode.constFractionDigits)).join(\",\");\r\n        let vecEntries = afmat.vec.flat().map(n => n.toFixed(MaterialNode.constFractionDigits)).join(\",\");\r\n        super(`tsxAffineMat(mat4x4f(${matEntries}),vec4f(${vecEntries}))`);\r\n    }\r\n}\r\n\r\n/** the same UniformValue instance will share one uniform buffer */\r\nclass UniformValue extends MaterialNode {\r\n    gpuBuffer: GPUBuffer;\r\n    gpuBufferSize: number;\r\n    jsBufferSize: number;\r\n    type: string;\r\n    needsUpdate = true;\r\n    constructor() {\r\n        super(\"u\" + generateUUID().replace(/\\-/g, \"\").slice(16));\r\n    }\r\n    getCode(r: Renderer, root: Material, outputToken: string) {\r\n        if (!this.gpuBuffer) {\r\n            this.createBuffer(r);\r\n        }\r\n        root.addUniform(this.type, this.identifier, this.gpuBuffer);\r\n        return `\r\n                let ${outputToken} = ${this.identifier};`;\r\n    }\r\n    createBuffer(r: Renderer) {\r\n        this.gpuBuffer = r.gpu.createBuffer(GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM, this.gpuBufferSize, \"uConstValueBuffer\");\r\n        this.jsBufferSize = this.gpuBufferSize >> 2;\r\n    }\r\n    _update(r: Renderer) { }\r\n    update(r: Renderer) {\r\n        if (!this.needsUpdate) return;\r\n        this._update(r);\r\n        r.gpu.device.queue.writeBuffer(this.gpuBuffer, 0, r.jsBuffer, 0, this.jsBufferSize);\r\n        this.needsUpdate = false;\r\n    }\r\n}\r\nexport class ColorUniformValue extends UniformValue {\r\n    declare output: \"color\";\r\n    type = \"vec4f\";\r\n    gpuBufferSize = 4 * 4;\r\n    value: GPUColor;\r\n    _update(r: Renderer) {\r\n        r.jsBuffer[0] = (this.value as GPUColorDict)?.r ?? this.value[0] ?? 0;\r\n        r.jsBuffer[1] = (this.value as GPUColorDict)?.g ?? this.value[1] ?? 0;\r\n        r.jsBuffer[2] = (this.value as GPUColorDict)?.b ?? this.value[2] ?? 0;\r\n        r.jsBuffer[3] = (this.value as GPUColorDict)?.a ?? this.value[3] ?? 1;\r\n    }\r\n    write(value: GPUColor) {\r\n        this.value = value;\r\n        this.needsUpdate = true;\r\n    }\r\n}\r\nexport class Vec4UniformValue extends UniformValue {\r\n    declare output: \"vec4\";\r\n    type = \"vec4f\";\r\n    gpuBufferSize = 4 * 4;\r\n    value: Vec4;\r\n    _update(r: Renderer) {\r\n        this.value.writeBuffer(r.jsBuffer);\r\n    }\r\n    write(value: Vec4) {\r\n        this.value = value;\r\n        this.needsUpdate = true;\r\n    }\r\n}\r\nexport class FloatUniformValue extends UniformValue {\r\n    declare output: \"f32\";\r\n    type = \"f32\";\r\n    gpuBufferSize = 4;\r\n    value: number;\r\n    _update(r: Renderer) {\r\n        r.jsBuffer[0] = this.value;\r\n    }\r\n    write(value: number) {\r\n        this.value = value;\r\n        this.needsUpdate = true;\r\n    }\r\n}\r\nexport class TransformUniformValue extends UniformValue {\r\n    declare output: \"affineMat4\";\r\n    type = \"tsxAffineMat\";\r\n    gpuBufferSize = 20 * 4;\r\n    value: Obj4;\r\n    private affineMatValue = new AffineMat4();\r\n    _update(r: Renderer) {\r\n        this.affineMatValue.setFromObj4(this.value).writeBuffer(r.jsBuffer);\r\n    }\r\n    write(value: Obj4) {\r\n        this.value = value;\r\n        this.needsUpdate = true;\r\n    }\r\n}\r\n\r\n\r\nexport type Color = GPUColor | ColorOutputNode;\r\n/** A shortcut path for writing a constant color */\r\nfunction makeColorOutput(color: Color) {\r\n    if (!(color instanceof MaterialNode)) color = new ColorConstValue(color as GPUColor);\r\n    return color;\r\n}\r\nexport type Float = number | FloatOutputNode;\r\n/** A shortcut path for writing a constant color */\r\nfunction makeFloatOutput(f: Float) {\r\n    if (!(f instanceof MaterialNode)) f = new FloatConstValue(f as number);\r\n    return f;\r\n}\r\n/** Basic material just return color node's output color  */\r\nexport class BasicMaterial extends Material {\r\n    declare input: {\r\n        color: ColorOutputNode;\r\n    };\r\n    constructor(color: Color) {\r\n        color = makeColorOutput(color);\r\n        super(\"Basic(\" + color.identifier + \")\");\r\n        this.input = { color };\r\n    }\r\n    getCode(r: Renderer, root: Material, outputToken: string) {\r\n        let color = this.input.color.getCode(r, root, \"color\");\r\n        return color + `\r\n                return color;`;\r\n    }\r\n}\r\nexport class LambertMaterial extends Material {\r\n    declare input: {\r\n        color: ColorOutputNode;\r\n    };\r\n\r\n    getCode(r: Renderer, root: Material, outputToken: string) {\r\n        root.addVary(\"normal\");\r\n        root.addVary(\"pos\");\r\n        let color = this.input.color.getCode(r, root, \"color\");\r\n        return color + `\r\n                var radiance = ambientLightDensity;\r\n                for(var i=0;i<${r.lightShaderInfomation.posdirLightsNumber};i++){\r\n                    var N = vec4f(0.0);\r\n                    if(uWorldLight.posdirLights[i].density.w<-0.5){\r\n                        N = uWorldLight.posdirLights[i].pos_dir;\r\n                    }else if(uWorldLight.posdirLights[i].density.w>0.5){\r\n                        N = uWorldLight.posdirLights[i].pos_dir - vary.pos;\r\n                        N *= pow(length(N),-uWorldLight.posdirLights[i].density.w); // decay by distance\r\n                    }\r\n                    radiance += uWorldLight.posdirLights[i].density.rgb * max(0.0,dot(vary.normal,N));\r\n                }\r\n                for(var i=0;i<${r.lightShaderInfomation.spotLightsNumber};i++){\r\n                    if(uWorldLight.spotLights[i].density.w>0.5){\r\n                        var N = uWorldLight.spotLights[i].pos - vary.pos;\r\n                        let len = length(N);\r\n                        let penumbra = max(0.0,dot(N / len,uWorldLight.spotLights[i].dir)*uWorldLight.spotLights[i].params.x + uWorldLight.spotLights[i].params.y);\r\n                        N *= pow(len,-uWorldLight.spotLights[i].params.w) * pow(penumbra, uWorldLight.spotLights[i].params.z);\r\n                        radiance += uWorldLight.spotLights[i].density.rgb * max(0.0,dot(vary.normal,N));\r\n                    }\r\n                }\r\n                return vec4f(acesFilm((color.rgb + blackColor) * radiance), color.a);`;\r\n    }\r\n    constructor(color: Color) {\r\n        color = makeColorOutput(color);\r\n        super(\"Lambert(\" + color.identifier + \")\");\r\n        this.input = { color };\r\n    }\r\n}\r\n/** Blinn Phong */\r\nexport class PhongMaterial extends Material {\r\n    declare input: {\r\n        color: ColorOutputNode;\r\n        specular: ColorOutputNode;\r\n        shininess: FloatOutputNode;\r\n    };\r\n\r\n    getCode(r: Renderer, root: Material, outputToken: string) {\r\n        root.addVary(\"normal\");\r\n        root.addVary(\"pos\");\r\n        root.addUniform(\"array<tsxAffineMat,2>\", \"uCamMat\", r.uCamMatBuffer);\r\n        let { code } = this.getInputCode(r, root, outputToken);\r\n        return code + `\r\n                var radiance = ambientLightDensity;\r\n                var specularRadiance = vec3<f32>(0.0);\r\n                let viewRay = -normalize(vary.pos - uCamMat[1].vector);\r\n                for(var i=0;i<${r.lightShaderInfomation.posdirLightsNumber};i++){\r\n                    var N = vec4f(0.0);\r\n                    var D = 0.0;\r\n                    if(uWorldLight.posdirLights[i].density.w<-0.5){\r\n                        D = 1.0;\r\n                        N = uWorldLight.posdirLights[i].pos_dir;\r\n                    }else if(uWorldLight.posdirLights[i].density.w>0.5){\r\n                        N = uWorldLight.posdirLights[i].pos_dir - vary.pos;\r\n                        let len = length(N);\r\n                        D = pow(len,1.0 - uWorldLight.posdirLights[i].density.w); // decay by distance\r\n                        N /= len;\r\n                    }else{\r\n                        continue;\r\n                    }\r\n                    let halfvec = normalize(N + viewRay);\r\n                    radiance += uWorldLight.posdirLights[i].density.rgb *  D * max(0.0,dot(vary.normal,N));\r\n                    specularRadiance += uWorldLight.posdirLights[i].density.rgb *  D * max(0.0,pow(dot(vary.normal,halfvec),_shininess) ) ;\r\n                }\r\n                for(var i=0;i<${r.lightShaderInfomation.spotLightsNumber};i++){\r\n                    if(uWorldLight.spotLights[i].density.w>0.5){\r\n                        \r\n                        var N = uWorldLight.spotLights[i].pos - vary.pos;\r\n                        let len = length(N);\r\n                        N /= len;\r\n                        let penumbra = max(0.0,dot(N,uWorldLight.spotLights[i].dir)*uWorldLight.spotLights[i].params.x + uWorldLight.spotLights[i].params.y);\r\n                        let D = pow(len,1.0-uWorldLight.spotLights[i].params.w) * pow(penumbra, uWorldLight.spotLights[i].params.z);\r\n                        let halfvec = normalize(N + viewRay);\r\n                        \r\n                        radiance += uWorldLight.spotLights[i].density.rgb *  D * max(0.0,dot(vary.normal,N));\r\n                        specularRadiance += uWorldLight.spotLights[i].density.rgb *  D * max(0.0,pow(dot(vary.normal,halfvec),_shininess) ) ;\r\n                    }\r\n                }\r\n                return vec4f(acesFilm((_color.rgb+blackColor) * radiance + _specular.rgb * specularRadiance), _color.a);`;\r\n    }\r\n    constructor(color: Color, shininess?: Float, specular?: Color) {\r\n        color = makeColorOutput(color);\r\n        specular = makeColorOutput(specular ?? [1, 1, 1]);\r\n        shininess = makeFloatOutput(shininess ?? 20.0);\r\n        super(\"Phong(\" + color.identifier + \",\" + specular.identifier + \",\" + shininess.identifier + \")\");\r\n        this.input = { color, shininess, specular };\r\n    }\r\n}\r\nexport class CheckerTexture extends MaterialNode {\r\n    declare output: \"color\";\r\n    declare input: {\r\n        color1: ColorOutputNode;\r\n        color2: ColorOutputNode;\r\n        uvw: Vec4OutputNode;\r\n    }\r\n    getCode(r: Renderer, root: Material, outputToken: string) {\r\n        // Tell root material that CheckerTexture needs deal dependency of vary input uvw\r\n        let { token, code } = this.getInputCode(r, root, outputToken);\r\n        return code + `\r\n                let ${outputToken}_checker = fract(${token.uvw}+vec4f(0.001)) - vec4f(0.5);\r\n                let ${outputToken} = mix(${token.color1},${token.color2},step( ${outputToken}_checker.x * ${outputToken}_checker.y * ${outputToken}_checker.z * ${outputToken}_checker.w, 0.0));\r\n                `;\r\n    }\r\n    constructor(color1: Color, color2: Color, uvw?: Vec4OutputNode) {\r\n        color1 = makeColorOutput(color1);\r\n        color2 = makeColorOutput(color2);\r\n        uvw ??= new UVWVec4Input();\r\n        super(`Checker(${color1.identifier},${color2.identifier},${uvw.identifier})`);\r\n        this.input = { color1, color2, uvw };\r\n    }\r\n}\r\nexport class WgslTexture extends MaterialNode {\r\n    declare output: \"color\";\r\n    declare input: {\r\n        uvw: Vec4OutputNode;\r\n    }\r\n    private wgslCode: string;\r\n    private entryPoint: string;\r\n    getCode(r: Renderer, root: Material, outputToken: string) {\r\n        root.addHeader(this.entryPoint, this.wgslCode);\r\n        let { token, code } = this.getInputCode(r, root, outputToken);\r\n        return code + `\r\n                let ${outputToken} = ${this.entryPoint}(${token.uvw});\r\n                `;\r\n    }\r\n    constructor(wgslCode: string, entryPoint: string, uvw?: Vec4OutputNode) {\r\n        uvw ??= new UVWVec4Input();\r\n        super(`Wgsl(${wgslCode},${uvw.identifier})`);\r\n        this.wgslCode = wgslCode.replace(new RegExp(\"\\b\" + entryPoint + \"\\b\", \"g\"), \"##\");\r\n        this.input = { uvw };\r\n        this.entryPoint = entryPoint;\r\n    }\r\n}\r\nexport class GridTexture extends MaterialNode {\r\n    declare output: \"color\";\r\n    declare input: {\r\n        color1: ColorOutputNode;\r\n        color2: ColorOutputNode;\r\n        gridWidth: Vec4OutputNode;\r\n        uvw: Vec4OutputNode;\r\n    }\r\n    getCode(r: Renderer, root: Material, outputToken: string) {\r\n        // Tell root material that CheckerTexture needs deal dependency of vary input uvw\r\n        let { token, code } = this.getInputCode(r, root, outputToken);\r\n        return code + `\r\n                let ${outputToken}_grid = step(${token.gridWidth}, fract(${token.uvw}));\r\n                let ${outputToken} = mix(${token.color1},${token.color2},${outputToken}_grid.x*${outputToken}_grid.y*${outputToken}_grid.z);\r\n                `;\r\n    }\r\n    constructor(color1: Color, color2: Color, gridWidth: number | Vec4 | Vec4OutputNode, uvw?: Vec4OutputNode) {\r\n        color1 = makeColorOutput(color1);\r\n        color2 = makeColorOutput(color2);\r\n        gridWidth = !(gridWidth instanceof MaterialNode) ? new Vec4ConstValue(\r\n            (gridWidth instanceof Vec4) ? gridWidth : new Vec4(gridWidth, gridWidth, gridWidth, gridWidth)\r\n        ) : gridWidth;\r\n        uvw ??= new UVWVec4Input();\r\n        super(`Grid(${color1.identifier},${color2.identifier}),${gridWidth.identifier},${uvw.identifier}`);\r\n        this.input = { color1, color2, gridWidth, uvw };\r\n    }\r\n}\r\nexport class UVWVec4Input extends MaterialNode {\r\n    declare output: \"vec4\";\r\n    getCode(r: Renderer, root: Material, outputToken: string) {\r\n        root.addVary(\"uvw\");\r\n        return `\r\n                let ${outputToken} = vary.uvw;`;\r\n    }\r\n    constructor() {\r\n        super(\"vary.uvw\");\r\n    }\r\n}\r\nexport class WorldCoordVec4Input extends MaterialNode {\r\n    declare output: \"vec4\";\r\n    getCode(r: Renderer, root: Material, outputToken: string) {\r\n        root.addVary(\"pos\");\r\n        return `\r\n                let ${outputToken} = vary.pos;`;\r\n    }\r\n    constructor() {\r\n        super(\"vary.pos\");\r\n    }\r\n}\r\nexport class Vec4TransformNode extends MaterialNode {\r\n    declare output: \"vec4\";\r\n    declare input: {\r\n        vec4: Vec4OutputNode;\r\n        transform: TransformOutputNode;\r\n    }\r\n    getCode(r: Renderer, root: Material, outputToken: string) {\r\n        let input = this.getInputCode(r, root, outputToken);\r\n        let affine = input.token.transform;\r\n        return input.code + `\r\n                let ${outputToken} = ${affine}.matrix * ${input.token.vec4} + ${affine}.vector;`;\r\n    }\r\n    constructor(vec4: Vec4OutputNode, transform: Obj4 | TransformOutputNode) {\r\n        transform = (!(transform instanceof MaterialNode)) ? new TransformConstValue(transform) : transform;\r\n        super(\"vec4tr(\" + vec4.identifier + \",\" + transform.identifier + \")\");\r\n        this.input = { vec4, transform };\r\n    }\r\n}\r\n/** simplex 3D noise */\r\nexport const NoiseWGSLHeader = `\r\n        fn mod289v3(x:vec3<f32>)->vec3<f32> {\r\n            return x - floor(x * (1.0 / 289.0)) * 289.0; \r\n        }\r\n        fn mod289v4(x:vec4f)->vec4f {\r\n            return x - floor(x * (1.0 / 289.0)) * 289.0; \r\n        }\r\n        fn mod289f(x:f32)->f32 {\r\n            return x - floor(x * (1.0 / 289.0)) * 289.0; \r\n        }\r\n        fn permutev4(x:vec4f)->vec4f {\r\n            return mod289v4(((x * 34.0) + 1.0) * x);\r\n        }\r\n        fn permutef(x:f32)-> f32 {\r\n            return mod289f(((x * 34.0) + 1.0) * x);\r\n        }\r\n        fn taylorInvSqrtv4(r:vec4f)->vec4f {\r\n            return vec4(1.79284291400159) - 0.85373472095314 * r;\r\n        }\r\n        fn taylorInvSqrtf(r:f32)->f32{\r\n            return 1.79284291400159 - 0.85373472095314 * r;\r\n        }\r\n        \r\n        fn snoise(v1:vec3<f32>)->f32{\r\n            let v = v1 + vec3(0.00001,0.00002,0.00003);\r\n            const C = vec2(1.0/6.0, 1.0/3.0);\r\n            const D = vec4(0.0, 0.5, 1.0, 2.0);\r\n\r\n            // First corner\r\n            var i  = floor(v + dot(v, vec3(C.y)) );\r\n            let x0 =   v - i + dot(i, vec3(C.x)) ;\r\n\r\n            // Other corners\r\n            let g = step(x0.yzx, x0.xyz);\r\n            let l = 1.0 - g;\r\n            let i1 = min( g.xyz, l.zxy );\r\n            let i2 = max( g.xyz, l.zxy );\r\n\r\n            let x1 = x0 - i1 + vec3(C.x);\r\n            let x2 = x0 - i2 + vec3(C.y); // 2.0*C.x = 1/3 = C.y\r\n            let x3 = x0 - vec3(D.y);      // -1.0+3.0*C.x = -0.5 = -D.y\r\n\r\n            // Permutations\r\n            i = mod289v3(i);\r\n            let p = permutev4( permutev4( permutev4(\r\n                        vec4(i.z) + vec4(0.0, i1.z, i2.z, 1.0 ))\r\n                    + vec4(i.y) + vec4(0.0, i1.y, i2.y, 1.0 ))\r\n                    + vec4(i.x) + vec4(0.0, i1.x, i2.x, 1.0 ));\r\n\r\n            // Gradients: 7x7 points over a square, mapped onto an octahedron.\r\n            // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\r\n            const n_ = 0.142857142857; // 1.0/7.0\r\n            let  ns = n_ * D.wyz - D.xzx;\r\n\r\n            let j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\r\n\r\n            let x_ = floor(j * ns.z);\r\n            let y_ = floor(j - 7.0 * x_ );    // mod(j,N)\r\n\r\n            let x = x_ *ns.x + vec4(ns.y);\r\n            let y = y_ *ns.x + vec4(ns.y);\r\n            let h = 1.0 - abs(x) - abs(y);\r\n\r\n            let b0 = vec4( x.xy, y.xy );\r\n            let b1 = vec4( x.zw, y.zw );\r\n\r\n            //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\r\n            //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\r\n            let s0 = floor(b0)*2.0 + 1.0;\r\n            let s1 = floor(b1)*2.0 + 1.0;\r\n            let sh = -step(h, vec4(0.0));\r\n\r\n            let a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\r\n            let a1 = b1.xzyw + s1.xzyw*sh.zzww ;\r\n\r\n            var p0 = vec3(a0.xy,h.x);\r\n            var p1 = vec3(a0.zw,h.y);\r\n            var p2 = vec3(a1.xy,h.z);\r\n            var p3 = vec3(a1.zw,h.w);\r\n\r\n            //Normalise gradients\r\n            let norm = taylorInvSqrtv4(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\r\n            p0 *= norm.x;\r\n            p1 *= norm.y;\r\n            p2 *= norm.z;\r\n            p3 *= norm.w;\r\n\r\n            // Mix final noise value\r\n            var m = max(vec4(0.6) - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), vec4(0.0));\r\n            m = m * m;\r\n            return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );\r\n        }\r\n        `;\r\n\r\nexport class ColorMixer extends MaterialNode {\r\n    declare output: \"color\"\r\n    declare input: {\r\n        color1: ColorOutputNode;\r\n        color2: ColorOutputNode;\r\n        mix: FloatOutputNode;\r\n    }\r\n    getCode(r: Renderer, root: Material, outputToken: string) {\r\n        // Tell root material that CheckerTexture needs deal dependency of vary input uvw\r\n        let { token, code } = this.getInputCode(r, root, outputToken);\r\n        return code + `\r\n                let ${outputToken} = mix(${token.color1},${token.color2},${token.mix});\r\n                `;\r\n    }\r\n    constructor(color1: Color, color2: Color, mix: Float) {\r\n        color1 = makeColorOutput(color1);\r\n        color2 = makeColorOutput(color2);\r\n        mix = makeFloatOutput(mix);\r\n        super(`Mixer(${color1.identifier},${color2.identifier},${mix.identifier})`);\r\n        this.input = { color1, color2, mix };\r\n    }\r\n}\r\nexport class NoiseTexture extends MaterialNode {\r\n    declare output: \"f32\";\r\n    declare input: {\r\n        uvw: Vec4OutputNode;\r\n    }\r\n    getCode(r: Renderer, root: Material, outputToken: string) {\r\n        root.addHeader(\"NoiseWGSLHeader\", NoiseWGSLHeader);\r\n        let { token, code } = this.getInputCode(r, root, outputToken);\r\n        return code + `\r\n                let ${outputToken} = snoise(${token.uvw});\r\n                `;\r\n    }\r\n    constructor(uvw?: Vec4OutputNode) {\r\n        uvw ??= new UVWVec4Input();\r\n        super(`Noise(${uvw.identifier})`);\r\n        this.input = { uvw };\r\n    }\r\n}"],"names":[],"mappings":"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"}
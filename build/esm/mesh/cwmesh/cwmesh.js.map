{"version":3,"file":"cwmesh.js","sources":["../../../../src/mesh/cwmesh/cwmesh.ts"],"sourcesContent":["import { Vec4 } from \"../../math/algebra/vec4.js\";\r\nimport { Bivec, Obj4, Rotor, _360 } from \"../../math/math.js\";\r\nimport { path, polytope } from \"./geoms\";\r\nexport type FaceId = number;\r\nexport type Simplex = number[];\r\nexport type Face = Array<FaceId>;\r\nexport type FaceOrientaion = Array<boolean>;\r\nexport type DimList<T> = Array<T>;\r\nexport type CWMeshStructData = DimList<Face[] | Vec4[]>;\r\nexport type OrientaionData = DimList<FaceOrientaion[]>;\r\nexport type CWMeshSelectionData = DimList<Set<FaceId>>;\r\nexport type RankedCWMap = DimList<Map<FaceId, FaceId>>;\r\nfunction range(i: number) {\r\n    const arr = [];\r\n    for (let j = 0; j < i; j++) { arr.push(j); }\r\n    return arr;\r\n}\r\nexport class CWMeshSelection {\r\n    cwmesh: CWMesh;\r\n    selData: CWMeshSelectionData;\r\n    constructor(cwmesh: CWMesh, data?: CWMeshSelectionData) {\r\n        this.cwmesh = cwmesh;\r\n        this.selData = data ?? [];\r\n    }\r\n    clone() {\r\n        return new CWMeshSelection(this.cwmesh, this.selData.map(set => new Set(set)));\r\n    }\r\n    /// this function modify selection into closure\r\n    closure(): CWMeshSelection {\r\n        const sel = this.selData;\r\n        for (let dim = sel.length - 1; dim > 0; dim--) {\r\n            if (!sel[dim]) continue;\r\n            const faces = this.cwmesh.data[dim] as Face[];\r\n            for (const faceId of sel[dim]) {\r\n                for (const d_faceId of faces[faceId]) {\r\n                    sel[dim - 1] ??= new Set();\r\n                    sel[dim - 1].add(d_faceId);\r\n                }\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    addFace(dim: number, faceId: FaceId) {\r\n        const seldata = this.selData;\r\n        seldata[dim] ??= new Set;\r\n        seldata[dim].add(faceId);\r\n        return this;\r\n    }\r\n}\r\nexport class CWMesh {\r\n    data: CWMeshStructData = [];\r\n    orientation: OrientaionData = [];\r\n    clone() {\r\n        const newcwmesh = new CWMesh();\r\n        newcwmesh.data = this.data.map(dataDim => dataDim ? dataDim.map(\r\n            (face: Face | Vec4) => face instanceof Vec4 ? face.clone() : face.slice(0)\r\n        ) as Face[] | Vec4[] : undefined);\r\n        newcwmesh.orientation = this.orientation.map(oDim => oDim ? oDim.map(\r\n            (faceO: FaceOrientaion) => faceO.slice(0)\r\n        ) : undefined);\r\n        return newcwmesh;\r\n    }\r\n\r\n\r\n    /* structure normalizations */\r\n\r\n\r\n    /// faces must be orientated\r\n    sort2DFace() {\r\n        const d_faces = this.data[1] as [FaceId, FaceId][];\r\n        const facesO = this.orientation[2];\r\n        const faces = this.data[2] as Face[];\r\n        for (const [faceId, face] of faces.entries()) {\r\n            const faceO = facesO[faceId];\r\n            const dd2nextdfaceMap = new Map<FaceId, number>();\r\n            for (const [d_faceIdx, d_faceId] of face.entries()) {\r\n                const d_face = d_faces[d_faceId];\r\n                const o = faceO[d_faceIdx];\r\n                dd2nextdfaceMap.set(d_face[o ? 0 : 1], d_faceIdx);\r\n            }\r\n            let curIdx = 0;\r\n            let newOrder = [curIdx];\r\n            const faceLength = face.length;\r\n            while (true) {\r\n                const d_faceId = face[curIdx];\r\n                const next_dd_faceIdx = faceO[curIdx] ? 1 : 0;\r\n                const dd_faceId = d_faces[d_faceId][next_dd_faceIdx];\r\n                curIdx = dd2nextdfaceMap.get(dd_faceId);\r\n                if (curIdx === 0) break;\r\n                newOrder.push(curIdx);\r\n                if (newOrder.length > faceLength) { console.error(\"Non manifold structure found.\"); break; }\r\n            }\r\n            faces[faceId] = newOrder.map(i => face[i]);\r\n            facesO[faceId] = newOrder.map(i => faceO[i]);\r\n        }\r\n    }\r\n    flipOrientation(dim: number, faceIds?: FaceId[]) {\r\n        faceIds ??= range(this.data[dim].length);\r\n        if (dim === 0) throw \"Vertex orientation flip is not implemented\";\r\n        if (dim === 1) {\r\n            const edgeTable = this.data[1];\r\n            for (const faceId of faceIds) {\r\n                const edge = edgeTable[faceId];\r\n                const a = edge[0]; edge[0] = edge[1]; edge[1] = a;\r\n            }\r\n        } else {\r\n            const oTable = this.orientation[dim];\r\n            if (!oTable) throw \"Orientation is undefiend\";\r\n            for (const faceId of faceIds) {\r\n                const o = oTable[faceId];\r\n                if (o === undefined) throw \"Orientation is undefiend\";\r\n                for (let i = 0; i < o.length; i++) o[i] = !o[i];\r\n            }\r\n        }\r\n        const cellTable = this.data[dim + 1] as Face[];\r\n        const cellOTable = this.orientation[dim + 1];\r\n        if (!cellOTable) return;\r\n        for (const [cellId, cell] of cellTable.entries()) {\r\n            for (const [faceIdx, faceId] of cell.entries()) {\r\n                if (faceIds.includes(faceId)) {\r\n                    cellOTable[cellId][faceIdx] = !cellOTable[cellId][faceIdx];\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /** tested with bug here (for examples/#cwmesh::duopy5 ), some faces orientations are not consisted */\r\n    // now, makeDual doesn't use this function anymore\r\n    calculateOrientation(dim: number, faceIds?: FaceId[]) {\r\n        if (dim === 0) return;\r\n        if (dim === 1) return; // edge: [-1, 1]\r\n        faceIds ??= range(this.data[dim].length);\r\n        const d2ftable: Map<number, Array<[number, number]>> = new Map;\r\n        const faces = faceIds.map(faceId => this.data[dim][faceId] as Face);\r\n\r\n        for (const [faceIdx, faceId] of faceIds.entries()) {\r\n            const face = faces[faceIdx] as Face;\r\n\r\n            // if face not oriented yet, deal with it first\r\n\r\n            if (dim !== 2) {\r\n                this.orientation[dim] ??= [];\r\n                if (!this.orientation[dim][faceId]) this.calculateOrientationInFace(dim, faceId);\r\n            }\r\n\r\n            // get all d_face and its table\r\n\r\n            for (const [d_faceIdx, d_faceId] of face.entries()) {\r\n                if (!d2ftable.has(d_faceId)) d2ftable.set(d_faceId, new Array());\r\n                d2ftable.get(d_faceId).push([d_faceIdx, faceIdx]);\r\n            }\r\n        }\r\n        let current_faceIdxs = [];\r\n        let current_faceIdx = 0;\r\n        const fOTable = this.orientation[dim];\r\n        const faceO: boolean[] = [];\r\n        while (current_faceIdx !== undefined) {\r\n            const currentFaceId = faceIds[current_faceIdx];\r\n            for (const [d_faceIdx, d_faceId] of faces[current_faceIdx].entries()) {\r\n                const ajacent_faceIdxs = d2ftable.get(d_faceId);\r\n                if (ajacent_faceIdxs.length > 2) throw \"Non manifold structure found\";\r\n                if (ajacent_faceIdxs.length === 1) continue;\r\n                let [next_d_faceIdx, next_faceIdx] = ajacent_faceIdxs[0][1] === current_faceIdx ? ajacent_faceIdxs[1] : ajacent_faceIdxs[0];\r\n                if (faceO[next_faceIdx] !== undefined) continue;\r\n                const d_faceOInCurrentFace = dim === 2 ? 1 === d_faceIdx : fOTable[currentFaceId][d_faceIdx];\r\n                const d_faceOInNextFace = dim === 2 ? 1 === next_d_faceIdx : fOTable[faceIds[next_faceIdx]][next_d_faceIdx];\r\n                faceO[next_faceIdx] = (faceO[current_faceIdx] === d_faceOInCurrentFace) !== d_faceOInNextFace;\r\n                current_faceIdxs.push(next_faceIdx);\r\n            }\r\n            current_faceIdx = current_faceIdxs.pop();\r\n        }\r\n        this.flipOrientation(dim, faceO.map((o, idx) => [o, faceIds[idx]] as [boolean, number]).filter(([o, id]) => !o).map(([o, id]) => id));\r\n    }\r\n    calculateOrientationInFace(dim: number, faceId: FaceId) {\r\n        this.orientation ??= [];\r\n        this.orientation[dim] ??= [];\r\n        if (this.orientation[dim][faceId]) return;\r\n        if (dim === 0) return;\r\n        if (dim === 1) return; // edge: [-1, 1]\r\n        const face = this.data[dim][faceId] as Face;\r\n\r\n        // if d_face not oriented yet, deal with it first\r\n\r\n        if (dim !== 2) {\r\n            for (const d_faceId of face) {\r\n                this.orientation[dim - 1] ??= [];\r\n                if (!this.orientation[dim - 1][d_faceId]) this.calculateOrientationInFace(dim - 1, d_faceId);\r\n            }\r\n        }\r\n\r\n        // get all dd_face and its table\r\n\r\n        const dd2dtable: Map<number, Array<[number, number]>> = new Map;\r\n        const d_faces = face.map(d_faceId => this.data[dim - 1][d_faceId] as Face);\r\n        let d_faceIdx: FaceId = 0;\r\n        for (const d_face of d_faces) {\r\n            for (const [dd_faceIdx, dd_faceId] of d_face.entries()) {\r\n                if (!dd2dtable.has(dd_faceId)) dd2dtable.set(dd_faceId, new Array());\r\n                dd2dtable.get(dd_faceId).push([dd_faceIdx, d_faceIdx]);\r\n            }\r\n            d_faceIdx++;\r\n        }\r\n        const faceO: FaceOrientaion = new Array(face.length); faceO[0] = true;\r\n        let current_d_faceIdxs = [];\r\n        let current_d_faceIdx = 0;\r\n        const dfOTable = this.orientation[dim - 1];\r\n        while (current_d_faceIdx !== undefined) {\r\n            const currentFaceId = face[current_d_faceIdx];\r\n            for (const [dd_faceIdx, dd_faceId] of d_faces[current_d_faceIdx].entries()) {\r\n                const ajacent_d_faceIdxs = dd2dtable.get(dd_faceId);\r\n                if (ajacent_d_faceIdxs.length > 2) throw \"Non manifold structure found\";\r\n                if (ajacent_d_faceIdxs.length === 1) continue;\r\n                let [next_dd_faceIdx, next_d_faceIdx] = ajacent_d_faceIdxs[0][1] === current_d_faceIdx ? ajacent_d_faceIdxs[1] : ajacent_d_faceIdxs[0];\r\n                if (faceO[next_d_faceIdx] !== undefined) continue;\r\n                const dd_faceOInCurrentFace = dim === 2 ? 1 === dd_faceIdx : dfOTable[currentFaceId][dd_faceIdx];\r\n                const dd_faceOInNextFace = dim === 2 ? 1 === next_dd_faceIdx : dfOTable[face[next_d_faceIdx]][next_dd_faceIdx];\r\n                faceO[next_d_faceIdx] = (faceO[current_d_faceIdx] === dd_faceOInCurrentFace) !== dd_faceOInNextFace;\r\n                current_d_faceIdxs.push(next_d_faceIdx);\r\n            }\r\n            current_d_faceIdx = current_d_faceIdxs.pop();\r\n        }\r\n        this.orientation[dim][faceId] = faceO;\r\n    }\r\n    /// this will reorder faceIds after deleting\r\n    deleteSelection(sel: CWMeshSelection) {\r\n        const remapping: RankedCWMap = [];\r\n        for (const [dim, selDim] of sel.selData.entries()) {\r\n            if (!selDim) continue;\r\n            remapping[dim] = new Map;\r\n            const faceMapTable: number[] = [];\r\n            let newId = 0; let del: boolean;\r\n            this.data[dim] = (this.data[dim] as (Face | Vec4)[]).filter(\r\n                (face: Face | Vec4, faceId: number) => (\r\n                    del = !selDim.has(faceId),\r\n                    remapping[dim].set(faceId, del ? -1 : newId++),\r\n                    del\r\n                )\r\n            ) as Face[] | Vec4[];\r\n            this.orientation[dim] = this.orientation[dim].filter(\r\n                (face: boolean[], faceId: number) => !selDim.has(faceId)\r\n            );\r\n        }\r\n        for (const [dim, dataDim] of this.data.entries()) {\r\n            const remapDim = remapping[dim - 1];\r\n            if (!remapDim || !remapDim.size) continue;\r\n            for (const face of dataDim as Face[]) {\r\n                for (const [faceIdx, faceId] of face.entries()) {\r\n                    face[faceIdx] = remapDim.get(faceId);\r\n                    if (face[faceIdx] === -1) throw \"A deleted subface is used by other faces\";\r\n                }\r\n            }\r\n        }\r\n        return remapping;\r\n    }\r\n\r\n\r\n    /* get informations from part of cwmesh */\r\n\r\n    dim() {\r\n        for (let i = this.data.length - 1; i >= 0; i--) {\r\n            if (this.data[i].length) {\r\n                return i;\r\n            }\r\n        }\r\n    }\r\n    findBorder(dim: number, faceIds?: Set<FaceId>) {\r\n        if (dim === 0) return;\r\n        if (!this.data[dim] || !this.data[dim].length) return;\r\n        faceIds ??= new Set(range(this.data[dim].length));\r\n        const bordersO = new Map<FaceId, number>();\r\n        const faces = this.data[dim] as Face[];\r\n        const facesO = this.orientation[dim] ?? [];\r\n\r\n        for (const faceId of faceIds) {\r\n            const face = faces[faceId];\r\n            const faceO = dim === 1 ? [false, true] : facesO[faceId] ?? [];\r\n            for (const [d_faceIdx, d_faceId] of face.entries()) {\r\n                const orientation = faceO[d_faceIdx];\r\n                if (!bordersO.get(d_faceId)) {\r\n                    bordersO.set(d_faceId, (orientation === undefined) ? NaN : (orientation ? 1 : -1));\r\n                } else {\r\n                    const prev = bordersO.get(d_faceId);\r\n                    if (isNaN(prev)) bordersO.delete(d_faceId);\r\n                    bordersO.set(d_faceId, prev + (orientation ? 1 : -1));\r\n                }\r\n            }\r\n        }\r\n        for (const [k, v] of bordersO) {\r\n            if (v === 0) {\r\n                bordersO.delete(k);\r\n            }\r\n        }\r\n        return bordersO;\r\n    }\r\n    getAllSelection(): CWMeshSelection {\r\n        return new CWMeshSelection(this, this.data.map(dimData => dimData ? new Set(range(dimData.length)) : undefined));\r\n    }\r\n    /// faces must be flat, convex and orientated\r\n    triangulate(dim: number, faceIds: number[], orientations?: boolean[]) {\r\n        faceIds ??= range(this.data[dim].length);\r\n        const faces = this.data[dim];\r\n        const facesO = this.orientation[dim];\r\n        if (dim === 0) {\r\n            throw \"can't triangulate points\";\r\n        }\r\n        if (dim === 1) {\r\n            return faceIds.map((id, idx) => [\r\n                !orientations || orientations[idx] === false ? [\r\n                    this.data[1][id][1], this.data[1][id][0]\r\n                ] : [\r\n                    this.data[1][id][0], this.data[1][id][1]\r\n                ]\r\n            ] as Simplex[]);\r\n        }\r\n        const result: Simplex[][] = [];\r\n        for (const [faceIdx, faceId] of faceIds.entries()) {\r\n            const face = faces[faceId] as Face;\r\n            const faceO = facesO[faceId];\r\n\r\n            // get the first vertex\r\n\r\n            let subfaceDim = dim - 1;\r\n            let subface0Id = face[0];\r\n            while (subfaceDim) {\r\n                subface0Id = this.data[subfaceDim--][subface0Id][0];\r\n            }\r\n\r\n            const d_faceWaitForTriagulate: FaceId[] = [];\r\n            const d_faceWaitForTriagulateO: boolean[] = [];\r\n\r\n            for (const [d_faceIdx, d_faceId] of face.entries()) {\r\n\r\n                // get subfaces who contain the first vertex\r\n\r\n                const tempsel = new CWMeshSelection(this).addFace(dim - 1, d_faceId).closure();\r\n                if (tempsel.selData[0].has(subface0Id)) continue;\r\n\r\n                d_faceWaitForTriagulate.push(d_faceId);\r\n                d_faceWaitForTriagulateO.push(faceO[d_faceIdx]);\r\n            }\r\n\r\n            const faceResult = this.triangulate(dim - 1, d_faceWaitForTriagulate, d_faceWaitForTriagulateO).flat();\r\n            faceResult.forEach(s => {\r\n                s.push(subface0Id)\r\n                if (orientations && orientations[faceIdx] === false) {\r\n                    const temp = s[0]; s[0] = s[1]; s[1] = temp;\r\n                }\r\n            });\r\n            result.push(faceResult);\r\n        }\r\n        return result;\r\n    }\r\n    /// dual data doesn't generate orientation information\r\n    getDualData(dim: number, faceIds?: number[]) {\r\n        faceIds ??= range(this.data[dim].length);\r\n        const data: DimList<Map<FaceId, Set<FaceId>>> = [];\r\n        for (let d = dim; d; d--) {\r\n            const faces = this.data[d];\r\n            data[d - 1] ??= new Map;\r\n            for (const [faceId, face] of faces.entries()) {\r\n                for (const d_faceId of face as Face) {\r\n                    if (!data[d - 1].get(d_faceId)) data[d - 1].set(d_faceId, new Set);\r\n                    data[d - 1].get(d_faceId).add(faceId);\r\n                }\r\n            }\r\n        }\r\n        return data;\r\n    }\r\n\r\n    /* modify topology of cwmesh */\r\n\r\n\r\n    duplicate(sel?: CWMeshSelection, notCheckselectionClosure?: boolean) {\r\n        if (!sel) notCheckselectionClosure = true;\r\n        sel ??= this.getAllSelection();\r\n        const closure = (notCheckselectionClosure ? sel : sel.closure()).selData;\r\n        const info: DimList<Map<FaceId, FaceId>> = [];\r\n        const vertexIsVec4 = this.data[0][0] instanceof Vec4;\r\n        for (const [dim, faceIdList] of closure.entries()) {\r\n            info[dim] = new Map;\r\n            const faces = this.data[dim];\r\n            const facesO = this.orientation[dim];\r\n            for (const faceId of faceIdList) {\r\n                const f0: FaceId = faces.length;\r\n                info[dim].set(faceId, f0);\r\n                if (dim === 0) faces.push((vertexIsVec4 ? (faces[faceId] as Vec4).clone() : []) as any);\r\n                else {\r\n                    (faces as Face[]).push((faces as Face[])[faceId].map(d_faceId => info[dim - 1].get(d_faceId)));\r\n                    if (facesO && facesO[faceId]) {\r\n                        facesO[f0] = facesO[faceId].slice(0);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return info;\r\n    }\r\n    // before making bridge, oritation must be consist, this can be checked and corrected (todo)\t\t\t\t\t\t\r\n    bridge(mapInfo: DimList<Map<FaceId, FaceId>>) {\r\n        const info: DimList<Map<FaceId, FaceId>> = [];\r\n        for (const [dim, faceIdList] of mapInfo.entries()) {\r\n            const faces = this.data[dim];\r\n            const facesO = this.orientation[dim];\r\n            this.data[dim + 1] ??= [];\r\n            const cells = this.data[dim + 1] as Face[];\r\n            const invO = (dim & 1) === 0;\r\n            if (!this.orientation[dim + 1]) this.orientation[dim + 1] = [];\r\n            const cellsO = this.orientation[dim + 1];\r\n            for (const [faceId, clonedFaceId] of faceIdList) {\r\n                const face = faces[faceId] as Face;\r\n                const faceO = facesO ? facesO[faceId] : undefined;\r\n                const newId: FaceId = cells.length;\r\n                info[dim] ??= new Map; info[dim].set(faceId, newId);\r\n                if (dim === 0) cells.push([faceId, clonedFaceId]);\r\n                else {\r\n                    const newCell: Face = face.map(d_faceId => info[dim - 1].get(d_faceId)); newCell.push(faceId, clonedFaceId);\r\n                    cells.push(newCell);\r\n                    // D(Extrude(A)) = (-1)^(dim+1)(A - Aclone) + Extrude(DA)\r\n                    const newCellO = dim === 1 ? [false, true] : faceO.slice(0);\r\n                    newCellO.push(!invO, invO);\r\n                    cellsO[newId] = newCellO;\r\n                }\r\n            }\r\n        }\r\n        return info;\r\n    }\r\n    topologicalExtrude(sel?: CWMeshSelection) {\r\n        sel ??= this.getAllSelection();\r\n        const cloneInfo = this.duplicate(sel);\r\n        const bridgeInfo = this.bridge(cloneInfo);\r\n        return { cloneInfo, bridgeInfo };\r\n    }\r\n    topologicalCone(sel?: CWMeshSelection, notCheckselectionClosure?: boolean) {\r\n        if (!sel) notCheckselectionClosure = true;\r\n        sel ??= this.getAllSelection();\r\n        sel = notCheckselectionClosure ? sel : sel.closure();\r\n        const info: DimList<Map<FaceId, FaceId>> = [];\r\n        const v0: FaceId = this.data[0].length;\r\n        this.data[0].push(this.data[0][0] instanceof Vec4 ? new Vec4() : [] as any);\r\n        for (const [dim, faceIdList] of sel.selData.entries()) {\r\n            const faces = this.data[dim];\r\n            const facesO = this.orientation[dim];\r\n            this.data[dim + 1] ??= [];\r\n            const cells = this.data[dim + 1] as Face[];\r\n            this.orientation[dim + 1] ??= [];\r\n            const invO = (dim & 1) === 0;\r\n            const cellsO = this.orientation[dim + 1];\r\n            for (const faceId of faceIdList) {\r\n                const face = faces[faceId] as Face;\r\n                const faceO = facesO ? facesO[faceId] : undefined;\r\n                const newId: FaceId = cells.length;\r\n                info[dim] ??= new Map; info[dim].set(faceId, newId);\r\n                if (dim === 0) cells.push([faceId, v0]);\r\n                else {\r\n                    const newCell: Face = face.map(d_faceId => info[dim - 1].get(d_faceId)); newCell.push(faceId);\r\n                    cells.push(newCell);\r\n                    // D(Cone(A)) = (-1)^(dim+1)A + Cone(DA)\r\n                    if (faceO) {\r\n                        const newCellO = faceO.slice(0); newCellO.push(!invO);\r\n                        cellsO[newId] = newCellO;\r\n                    } else if (dim === 1) {\r\n                        cellsO[newId] = [false, true, !invO];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return {\r\n            coneVertex: v0,\r\n            map: info\r\n        };\r\n    }\r\n    // this U= this[thisSel] x shape2[shape2Sel]\r\n    topologicalProduct(shape2: CWMesh, thisSel?: CWMeshSelection, shape2Sel?: CWMeshSelection) {\r\n        if (thisSel) thisSel.closure();\r\n        if (shape2Sel) shape2Sel.closure();\r\n        thisSel ??= this.getAllSelection();\r\n        shape2Sel ??= shape2.getAllSelection();\r\n        // productInfo[dim2].get(face2Id)[dim1].get(face1Id) ==> face1_x_face2_Id\r\n        const productInfo: DimList<Map<FaceId, DimList<Map<FaceId, FaceId>>>> = [new Map];\r\n        // this[i] x shape2[0]\r\n        let firstCopy = true;\r\n        for (const sp2vId of shape2Sel.selData[0]) {\r\n            if (firstCopy) {\r\n                const identityInfo = thisSel.selData.map(set => new Map(set.entries()));\r\n                productInfo[0].set(sp2vId, identityInfo);\r\n                firstCopy = false;\r\n            } else {\r\n                const cloneInfo = this.duplicate(thisSel, true);\r\n                productInfo[0].set(sp2vId, cloneInfo);\r\n            }\r\n        }\r\n        // loop shape2\r\n        for (const [dim2, thisSel2dim] of shape2Sel.selData.entries()) {\r\n            // skip shape2[0], already calculated\r\n            if (!dim2 || !thisSel2dim) continue;\r\n            const faces2 = shape2.data[dim2];\r\n            const faces2O = shape2.orientation[dim2];\r\n            productInfo[dim2] ??= new Map;\r\n            const productInfoDim2 = productInfo[dim2];\r\n            for (const face2Id of thisSel2dim) {\r\n                const face2 = faces2[face2Id];\r\n                const face2O = faces2O ? faces2O[face2Id] : undefined;\r\n                if (!productInfoDim2.has(face2Id)) productInfoDim2.set(face2Id, []);\r\n                const face2ProductInfo = productInfoDim2.get(face2Id);\r\n                // loop shape1\r\n                for (const [dim1, thisSel1dim] of thisSel.selData.entries()) {\r\n                    if (!thisSel1dim) continue;\r\n                    const dim12 = dim1 + dim2;\r\n                    const faces1 = this.data[dim1];\r\n                    const faces1O = this.orientation[dim1];\r\n                    face2ProductInfo[dim1] ??= new Map;\r\n                    this.data[dim12] ??= [];\r\n                    const cells = this.data[dim12] as Face[];\r\n                    if (dim12 > 1) this.orientation[dim12] ??= [];\r\n                    const cellsO = this.orientation[dim12];\r\n                    for (const face1Id of thisSel1dim) {\r\n                        const face1 = faces1[face1Id];\r\n                        const face1O = faces1O ? faces1O[face1Id] : undefined;\r\n                        // regist newCell\r\n                        const newCell: Face = [];\r\n                        const newCellO = [];\r\n                        const newCellId = cells.length;\r\n                        face2ProductInfo[dim1].set(face1Id, newCellId);\r\n\r\n                        // D(shape1) x shape2 \r\n                        if (dim1) { // exclude 0-face with no border\r\n                            for (const [d_face1Idx, d_face1Id] of (face1 as Face).entries()) {\r\n                                newCell.push(face2ProductInfo[dim1 - 1].get(d_face1Id));\r\n                                if (dim1 > 1) newCellO.push(face1O[d_face1Idx]);\r\n                            }\r\n                            if (dim1 === 1) newCellO.push(false, true);\r\n                        }\r\n                        // D(shape2) x shape1\r\n                        const invO = (dim1 & 1) === 1;\r\n                        for (const [d_face2Idx, d_face2Id] of (face2 as Face).entries()) {\r\n                            newCell.push(productInfo[dim2 - 1].get(d_face2Id)[dim1].get(face1Id));\r\n                            if (dim2 > 1) newCellO.push(invO !== face2O[d_face2Idx]);\r\n                        }\r\n                        if (dim2 === 1) newCellO.push(invO, !invO);\r\n\r\n                        if (dim12 === 1) {\r\n                            if (newCellO[0] === true) {\r\n                                const temp = newCell[0]; newCell[0] = newCell[1]; newCell[1] = temp;\r\n                            }\r\n                        } else {\r\n                            cellsO.push(newCellO);\r\n                        }\r\n                        cells.push(newCell);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return productInfo;\r\n    }\r\n\r\n\r\n    /* modify concrete shape of cwmesh up to 4d */\r\n\r\n\r\n    apply(verticesCalls: (vertex: Vec4) => Vec4) {\r\n        (this.data[0] as Vec4[]).forEach(verticesCalls);\r\n        return this;\r\n    }\r\n    makePrism(direction: Vec4, alignCenter: boolean, sel?: CWMeshSelection) {\r\n        const { cloneInfo, bridgeInfo } = this.topologicalExtrude(sel);\r\n        const vs = this.data[0] as Vec4[];\r\n        if (alignCenter) {\r\n            for (const [srcvId, destvId] of cloneInfo[0]) {\r\n                vs[srcvId].addmulfs(direction, -0.5);\r\n                vs[destvId].addmulfs(direction, 0.5);\r\n            }\r\n        } else {\r\n            for (const [srcvId, destvId] of cloneInfo[0]) {\r\n                vs[destvId].adds(direction);\r\n            }\r\n        }\r\n        return { cloneInfo, bridgeInfo };\r\n    }\r\n    makeRotatoid(bivec: Bivec, segment: number, angle?: number) {\r\n        // throw \"not test yet\";\r\n        let pathcw: CWMesh;\r\n        const dangle = (angle ?? _360) / segment;\r\n        const ps: Vec4[] = [];\r\n        for (let i = 0, j = 0; i < segment; i++, j += dangle) { ps.push(new Vec4(Math.cos(j), Math.sin(j))); }\r\n        if (angle === undefined) {\r\n            pathcw = path(ps, true);\r\n        } else {\r\n            ps.push(new Vec4(Math.cos(angle), Math.sin(angle)));\r\n            pathcw = path(ps, false);\r\n        }\r\n        const R0 = Rotor.lookAtbb(Bivec.xy, bivec);\r\n        pathcw.apply(v => v.rotates(R0));\r\n\r\n        const v1s = this.data[0] as Vec4[];\r\n        const info = this.topologicalProduct(pathcw);\r\n\r\n        const r0 = bivec.mulf(dangle).exp();\r\n        const r = r0.clone();\r\n        const rarr: Rotor[] = [new Rotor, r.clone()];\r\n        for (let i = 2; i < pathcw.data[0].length; i++) {\r\n            rarr.push(r.mulsl(r0).clone());\r\n        }\r\n        for (const [v2Id, dim1List] of info[0]) {\r\n            for (const [v1Id, v1_x_v2Id] of dim1List[0]) {\r\n                if (v1Id === v1_x_v2Id) break;\r\n                if (v1Id !== v1_x_v2Id) v1s[v1_x_v2Id].copy(v1s[v1Id]).rotates(rarr[v2Id]);\r\n                r.mulsl(r0);\r\n            }\r\n        }\r\n        return info;\r\n    }\r\n    makePyramid(point: Vec4, sel?: CWMeshSelection) {\r\n        const info = this.topologicalCone(sel);\r\n        const vs = this.data[0] as Vec4[];\r\n        vs[info.coneVertex].copy(point);\r\n        return info;\r\n    }\r\n    makeDirectProduct(shape2: CWMesh, thisSel?: CWMeshSelection, shape2Sel?: CWMeshSelection) {\r\n        const v1s = this.data[0] as Vec4[];\r\n        const v2s = shape2.data[0] as Vec4[];\r\n        const info = this.topologicalProduct(shape2, thisSel, shape2Sel);\r\n        for (const [v2Id, dim1List] of info[0]) {\r\n            for (const [v1Id, v1_x_v2Id] of dim1List[0]) {\r\n                if (v1Id === v1_x_v2Id) break;\r\n                if (v1Id !== v1_x_v2Id) v1s[v1_x_v2Id].addset(v1s[v1Id], v2s[v2Id]);\r\n            }\r\n        }\r\n        for (const [v2Id, dim1List] of info[0]) {\r\n            for (const [v1Id, v1_x_v2Id] of dim1List[0]) {\r\n                if (v1Id !== v1_x_v2Id) break;\r\n                if (v1Id === v1_x_v2Id) v1s[v1_x_v2Id].addset(v1s[v1Id], v2s[v2Id]);\r\n            }\r\n        }\r\n        return info;\r\n    }\r\n    /// mesh must be closed manifold\r\n    makeDual() {\r\n        const d = (this.findBorder(this.dim()).size) ? this.dim() - 1 : this.dim();\r\n        const info = this.getDualData(d);\r\n        const mesh = new CWMesh;\r\n        for (let nd = d, dim = 0; nd > 0; nd--, dim++) {\r\n            mesh.data[nd] = [];\r\n            const nfaces = mesh.data[nd];\r\n            for (let [faceId, coDfaceId] of info[dim]) {\r\n                nfaces[faceId] = Array.from(coDfaceId);\r\n            }\r\n        }\r\n        mesh.data[0] = this.data[d].map((_, faceId) => {\r\n            const arr = Array.from(new CWMeshSelection(this).addFace(d, faceId).closure().selData[0]).map(\r\n                vId => this.data[0][vId] as Vec4\r\n            );\r\n            return arr.reduce((a: Vec4, b: Vec4) => a.adds(b), new Vec4).divfs(arr.length);\r\n        });\r\n        mesh.data[4] = [range(mesh.data[3].length)];\r\n        mesh.calculateOrientationInFace(4, 0);\r\n        return mesh;\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n"],"names":[],"mappings":"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"}
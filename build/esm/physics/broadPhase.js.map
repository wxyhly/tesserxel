{"version":3,"file":"broadPhase.js","sources":["../../../src/physics/broadPhase.ts"],"sourcesContent":["import { math } from \"../tesserxel.js\";\r\nimport { World } from \"./engine.js\";\r\nimport { Rigid, rigid } from \"./rigid.js\";\r\n\r\nexport interface BroadPhaseConstructor {\r\n    new(): BroadPhase;\r\n};\r\nexport type BroadPhaseList = [Rigid, Rigid][];\r\nexport abstract class BroadPhase {\r\n    checkList: BroadPhaseList = [];\r\n    ignorePair: BroadPhaseList = [];\r\n    protected clearCheckList() {\r\n        this.checkList = [];\r\n    }\r\n    abstract run(world: World): void;\r\n    protected verifyCheckList() {\r\n        this.checkList = this.checkList.filter(([a, b]) => -1 === this.ignorePair.findIndex(([x, y]) => (a === x && b === y) || (a === y && b === x)));\r\n    }\r\n}\r\nexport class BoundingGlomeBroadPhase extends BroadPhase {\r\n    checkBoundingGlome(ri: Rigid, rj: Rigid) {\r\n        let gi = ri.geometry instanceof rigid.Glome;\r\n        let gj = rj.geometry instanceof rigid.Glome;\r\n        let pi = ri.geometry instanceof rigid.Plane;\r\n        let pj = rj.geometry instanceof rigid.Plane;\r\n        let directDetect = (gi || pi) && (gj || pj);\r\n        let radi = ri.geometry.boundingGlome;\r\n        let radj = rj.geometry.boundingGlome;\r\n        if (!directDetect && radi && radj) {\r\n            let r = radi + radj;\r\n            if (ri.position.distanceSqrTo(rj.position) > r * r) {\r\n                return false;\r\n            }\r\n        } else if (pi && radj) {\r\n            let d = radj - (rj.position.dot((ri.geometry as rigid.Plane).normal) - (ri.geometry as rigid.Plane).offset)\r\n            if (d < 0) return false;\r\n        } else if (pj && radi) {\r\n            let d = radi - (ri.position.dot((rj.geometry as rigid.Plane).normal) - (rj.geometry as rigid.Plane).offset)\r\n            if (d < 0) return false;\r\n        }\r\n        return true;\r\n    }\r\n    run(world: World) {\r\n        this.clearCheckList();\r\n        for (let i = 0; i < world.rigids.length; i++) {\r\n            for (let j = i + 1; j < world.rigids.length; j++) {\r\n                let ri = world.rigids[i], rj = world.rigids[j];\r\n                if (!ri.mass && !rj.mass) continue;\r\n                if (!this.checkBoundingGlome(ri, rj)) continue;\r\n                let iU = ri.geometry instanceof rigid.Union;\r\n                let jU = rj.geometry instanceof rigid.Union;\r\n                if (!iU && !jU) {\r\n                    this.checkList.push([ri, rj]);\r\n                } else if (iU && !jU) {\r\n                    for (let r of (ri.geometry as rigid.Union).components) {\r\n\r\n                        if (!this.checkBoundingGlome(r, rj)) continue;\r\n                        this.checkList.push([r, rj]);\r\n                    }\r\n                } else if (!iU && jU) {\r\n                    for (let r of (rj.geometry as rigid.Union).components) {\r\n                        if (!this.checkBoundingGlome(r, ri)) continue;\r\n                        this.checkList.push([r, ri]);\r\n                    }\r\n                } else {\r\n                    for (let r1 of (ri.geometry as rigid.Union).components) {\r\n                        for (let r2 of (rj.geometry as rigid.Union).components) {\r\n                            if (!this.checkBoundingGlome(r1, r2)) continue;\r\n                            this.checkList.push([r1, r2]);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\ntype BoundingGlomeTreeNode = {\r\n    position: math.Vec4;\r\n    radius: number;\r\n    surcell: number;\r\n    child1: BoundingGlomeTreeNode | Rigid;\r\n    child2?: BoundingGlomeTreeNode | Rigid;\r\n    parent?: BoundingGlomeTreeNode;\r\n    rigidIndex?: number;\r\n};\r\nexport class BoundingGlomeTreeBroadPhase extends BroadPhase {\r\n    tree: BoundingGlomeTreeNode;\r\n    exclude: Rigid[];\r\n    include: Rigid[];\r\n    buildTree(world: World) {\r\n        this.tree = undefined;\r\n        this.exclude = [];\r\n        this.include = [];\r\n        let rigidIndex = -1;\r\n        for (let i = 0; i < world.rigids.length; i++) {\r\n            let ri = world.rigids[i];\r\n            if (ri.geometry instanceof rigid.Plane || ri.geometry instanceof rigid.GlomicCavity) {\r\n                this.exclude.push(ri);\r\n            } else {\r\n                this.include.push(ri);\r\n                rigidIndex++;\r\n                let riRadius = ri.geometry.boundingGlome;\r\n                let newRigidNode: BoundingGlomeTreeNode = {\r\n                    radius: riRadius, position: ri.position.clone(),\r\n                    surcell: riRadius * riRadius,\r\n                    child1: ri, rigidIndex\r\n                };\r\n                if (!this.tree) {\r\n                    // create initial tree: node->rigid[0]\r\n                    this.tree = newRigidNode;\r\n                } else {\r\n                    let node = this.tree;\r\n                    let nodeNeedUpdate = true;\r\n                    let done = false;\r\n                    while (!done) {\r\n                        if (node.child1 instanceof Rigid) {\r\n                            // insert a new leaf node for rigid\r\n                            let radius = node.child1.geometry.boundingGlome;\r\n                            let surcell = nodeNeedUpdate ? node.surcell : radius * radius;\r\n                            let wrapNode: BoundingGlomeTreeNode = {\r\n                                radius, position: node.child1.position.clone(), surcell,\r\n                                child1: node.child1, parent: node, rigidIndex: node.rigidIndex\r\n                            };\r\n                            node.child1 = wrapNode;\r\n                            node.child2 = newRigidNode;\r\n                            newRigidNode.parent = node;\r\n                            node.rigidIndex = undefined;\r\n                            done = true;\r\n                        }\r\n                        if (nodeNeedUpdate) {\r\n                            // update node's bounding glome\r\n                            let distance = node.position.distanceTo(newRigidNode.position);\r\n                            let newRadius = (distance + riRadius + node.radius) * 0.5;\r\n                            if (newRadius <= Math.min(riRadius, node.radius)) {\r\n                                if (newRadius <= riRadius) {\r\n                                    node.position.copy(ri.position);\r\n                                    node.radius = riRadius;\r\n                                    node.surcell = newRigidNode.surcell;\r\n                                }\r\n                            } else {\r\n                                node.position.subs(ri.position).mulfs((newRadius - riRadius) / distance).adds(ri.position);\r\n                                node.radius = newRadius;\r\n                                node.surcell = node.radius * node.radius;\r\n                            }\r\n                        }\r\n                        if (!done && node.child2) {\r\n                            let distance1 = ri.position.distanceTo(node.child1.position);\r\n                            let d1 = distance1 + riRadius + node.child1.radius;\r\n                            let surcell1 = d1 * d1 * 0.25;\r\n                            let distance2 = ri.position.distanceTo(node.child2.position);\r\n                            let d2 = distance2 + riRadius + (node.child2 as BoundingGlomeTreeNode).radius;\r\n                            let surcell2 = d2 * d2 * 0.25;\r\n                            let surcell = Math.min(surcell1, surcell2);\r\n                            let radius: number, distance: number;\r\n                            if (surcell1 - node.child1.surcell < surcell2 - (node.child2 as BoundingGlomeTreeNode).surcell) {\r\n                                node = node.child1;\r\n                                radius = d1 * 0.5;\r\n                                distance = distance1;\r\n                            } else {\r\n                                node = node.child2 as BoundingGlomeTreeNode;\r\n                                radius = d2 * 0.5;\r\n                                distance = distance2;\r\n                            }\r\n                            node.position.subs(ri.position).mulfs((radius - riRadius) / distance).adds(ri.position);\r\n                            node.radius = radius;\r\n                            node.surcell = surcell;\r\n                            nodeNeedUpdate = false;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n        }\r\n    }\r\n    run(world: World) { // todo: union\r\n        this.clearCheckList();\r\n        this.buildTree(world);\r\n        for (let includeIdx = 0; includeIdx < this.include.length; includeIdx++) {\r\n            const stack = [this.tree];\r\n            const i = this.include[includeIdx];\r\n            while (stack.length) {\r\n                const node = stack.pop();\r\n                if (node.child1 instanceof Rigid) {\r\n                    if (node.rigidIndex <= includeIdx) {\r\n                        continue;\r\n                    }\r\n                }\r\n                let r = i.geometry.boundingGlome + node.radius;\r\n                if (i.position.distanceSqrTo(node.position) < r * r) {\r\n                    if (node.child2) {\r\n                        stack.push(node.child1 as BoundingGlomeTreeNode, node.child2 as BoundingGlomeTreeNode);\r\n                    } else {\r\n                        this.checkList.push([i, node.child1 as Rigid]);\r\n                    }\r\n                }\r\n            }\r\n            for (let e of this.exclude) {\r\n                this.checkList.push([i, e]);\r\n            }\r\n        }\r\n\r\n    }\r\n}\r\nexport class NaiveBroadPhase extends BroadPhase {\r\n    run(world: World) {\r\n        this.clearCheckList();\r\n        for (let i = 0; i < world.rigids.length; i++) {\r\n            for (let j = i + 1; j < world.rigids.length; j++) {\r\n                let ri = world.rigids[i], rj = world.rigids[j];\r\n                if (!ri.mass && !rj.mass) continue;\r\n                let iU = ri.geometry instanceof rigid.Union;\r\n                let jU = rj.geometry instanceof rigid.Union;\r\n                if (!iU && !jU) {\r\n                    this.checkList.push([ri, rj]);\r\n                } else if (iU && !jU) {\r\n                    for (let r of (ri.geometry as rigid.Union).components) {\r\n                        this.checkList.push([r, rj]);\r\n                    }\r\n                } else if (!iU && jU) {\r\n                    for (let r of (rj.geometry as rigid.Union).components) {\r\n                        this.checkList.push([r, ri]);\r\n                    }\r\n                } else {\r\n                    for (let r1 of (ri.geometry as rigid.Union).components) {\r\n                        for (let r2 of (rj.geometry as rigid.Union).components) {\r\n                            this.checkList.push([r1, r2]);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        this.verifyCheckList();\r\n    }\r\n}\r\nexport class IgnoreAllBroadPhase extends BroadPhase {\r\n    run(world: World) {\r\n        this.clearCheckList();\r\n    }\r\n}"],"names":[],"mappings":"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"}
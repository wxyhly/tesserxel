{"version":3,"file":"pipeline.js","sources":["../../../../src/render/slice/pipeline.ts"],"sourcesContent":["\r\nimport { GPU } from \"../gpu.js\";\r\nimport { InternalSliceRendererConfig, RetinaSliceBufferMgr, TetraSliceBufferMgr } from \"./renderer.js\";\r\nimport { RaytracingPipelineDescriptor, TetraSlicePipelineDescriptor } from \"./interfaces.js\";\r\nimport { getFnInputAndOutput, parseAttr, parseTypeName, ResourceType, TypeInfo, WgslReflect } from \"../wgsl.js\";\r\n\r\nconst tetraSliceBindGroup0declareIndex = 3;\r\nexport const refacingMatsCode = `\r\nconst tsx_refacingMats = array<mat4x4f,6>(\r\n// +z\r\nmat4x4f(\r\n1,0,0,0,\r\n0,1,0,0,\r\n0,0,1,0,\r\n0,0,0,1,\r\n),\r\n// -z\r\nmat4x4f(\r\n1,0,0,0,\r\n0,1,0,0,\r\n0,0,-1,0,\r\n0,0,0,1,\r\n),\r\n// +y\r\nmat4x4f(\r\n1,0,0,0,\r\n0,0,1,0,\r\n0,1,0,0,\r\n0,0,0,1,\r\n),\r\n// -y\r\nmat4x4f(\r\n1,0,0,0,\r\n0,0,-1,0,\r\n0,-1,0,0,\r\n0,0,0,1,\r\n),\r\n// +x\r\nmat4x4f(\r\n0,0,1,0,\r\n0,1,0,0,\r\n1,0,0,0,\r\n0,0,0,1,\r\n),\r\n// -x\r\nmat4x4f(\r\n0,0,-1,0,\r\n0,1,0,0,\r\n-1,0,0,0,\r\n0,0,0,1,\r\n),\r\n);\r\nconst determinantRefacingMats = array<f32,6>(1,-1,-1,-1,-1,-1);\r\n`;\r\nexport const StructDefSliceInfo = `\r\nstruct tsxSliceInfo{\r\n    slicePos: f32, refacing: u32, flag: u32, viewport: u32,\r\n}`;\r\nexport const StructDefUniformBuffer = `\r\nstruct tsxUniformBuffer{\r\n    retinaMV: mat4x4f, retinaP: mat4x4f, camProj: vec4f,\r\n    eyeCross: vec3<f32>, sliceOffset: u32, refacing: u32, screenAspect: f32, layerOpacity: f32,\r\n}`;\r\nconst expectTetraSlicePipelineInput = {\r\n    \"location(0)\": \"_attribute0[tetraIndex]\",\r\n    \"location(1)\": \"_attribute1[tetraIndex]\",\r\n    \"location(2)\": \"_attribute2[tetraIndex]\",\r\n    \"location(3)\": \"_attribute3[tetraIndex]\",\r\n    \"location(4)\": \"_attribute4[tetraIndex]\",\r\n    \"location(5)\": \"_attribute5[tetraIndex]\",\r\n    \"builtin(instance_index)\": \"instanceIndex\",\r\n    \"builtin(tetra_index)\": \"tetraIndex\",\r\n}\r\nconst expectTetraSlicePipelineOutput = [\r\n    \"location(0)\", \"location(1)\", \"location(2)\", \"location(3)\", \"location(4)\", \"location(5)\",\r\n    \"builtin(position)\"\r\n];\r\nexport class TetraSlicePipeline {\r\n    computePipeline: GPUComputePipeline;\r\n    computeBindGroup0: GPUBindGroup;\r\n    renderPipeline: GPURenderPipeline;\r\n    outputVaryBuffer: GPUBuffer[];\r\n    vertexOutNum: number;\r\n    private reflect: WgslReflect;\r\n    private gpu: GPU;\r\n    private device: GPUDevice;\r\n    private crossComputeShaderModule: GPUShaderModule;\r\n    private fragmentShaderModule: GPUShaderModule;\r\n    descriptor: TetraSlicePipelineDescriptor;\r\n    getCompilationInfo() {\r\n        return { tetra: this.crossComputeShaderModule?.getCompilationInfo(), fragment: this.fragmentShaderModule?.getCompilationInfo() };\r\n    }\r\n    async init(gpu: GPU, config: InternalSliceRendererConfig, descriptor: TetraSlicePipelineDescriptor, tetrasliceBufferMgr: TetraSliceBufferMgr) {\r\n        this.gpu = gpu;\r\n        this.device = gpu.device;\r\n        this.descriptor = descriptor;\r\n        let vertexState = descriptor.vertex;\r\n        this.reflect = new WgslReflect(vertexState.code);\r\n        let mainFn = this.reflect._functions.get(vertexState.entryPoint);\r\n        if (!mainFn || mainFn.node.attributes?.[0].name !== \"tetra\") console.error(\"Tetra vertex shader entry Point function not found\");\r\n\r\n        let { input, output, call } = getFnInputAndOutput(this.reflect, mainFn, expectTetraSlicePipelineInput, expectTetraSlicePipelineOutput);\r\n        let layout = this.getBindGroupLayout(output);\r\n        // compute pipeline\r\n        let computeGroup0Buffers = tetrasliceBufferMgr.buffers.slice(0);\r\n        let bindGroup0declare = '';\r\n        let varInterpolate = \"\";\r\n        let emitOutput1 = \"\";\r\n        let emitOutput2 = \"\";\r\n\r\n        // render pipeline\r\n        let vinputVert = '';\r\n        let voutputVert = '';\r\n        let vcallVert = \"\";\r\n        let vertexBufferAttributes: GPUVertexBufferLayout[] = [];\r\n        this.vertexOutNum = 0;\r\n        this.outputVaryBuffer = tetrasliceBufferMgr.prepareNewPipeline();\r\n        for (let attr in output) {\r\n            let id: number;\r\n            if (attr === \"return\") continue;\r\n            let packedType = output[attr].type; // unpack matrix4x4\r\n            let rawType = packedType.replace(\"mat4x4f\", \"vec4f\");\r\n            if (attr === \"builtin(position)\") {\r\n                id = 0;\r\n            } else if (attr.startsWith(\"location(\")) {\r\n                let i = attr.charAt(9);\r\n                id = Number(i) + 1;\r\n            }\r\n            if (id >= 0) {\r\n                this.vertexOutNum++;\r\n                bindGroup0declare += `@group(0) @binding(${tetraSliceBindGroup0declareIndex + id}) var<storage, read_write> _output${id} : array<${rawType}>;\\n`;\r\n                varInterpolate += `var output${id}s : array<${rawType},4>;\\n`;\r\n                emitOutput1 += `\r\n            _output${id}[outOffset] =   output${id}s[0];\r\n            _output${id}[outOffset+1] = output${id}s[1];\r\n            _output${id}[outOffset+2] = output${id}s[2];`\r\n                emitOutput2 += `\r\n                _output${id}[outOffset+3] = output${id}s[2];\r\n                _output${id}[outOffset+4] = output${id}s[1];\r\n                _output${id}[outOffset+5] = output${id}s[3];`\r\n                let jeg = rawType.match(/array<(.+),(.+)>/);\r\n                if (jeg) {\r\n                    let typeArrLength = Number(jeg[2]);\r\n                    let attributes = [];\r\n                    for (let i = 0; i < typeArrLength; i++) {\r\n                        attributes.push({\r\n                            shaderLocation: id, // here we keep same id, we'll deal this later\r\n                            format: 'float32x4',\r\n                            offset: i << 4\r\n                        })\r\n                    }\r\n                    vertexBufferAttributes.push({\r\n                        arrayStride: typeArrLength << 4,\r\n                        attributes\r\n                    });\r\n                    computeGroup0Buffers.push({ buffer: tetrasliceBufferMgr.requireOutputBuffer(id, typeArrLength, this.outputVaryBuffer) });\r\n                } else {\r\n                    computeGroup0Buffers.push({ buffer: tetrasliceBufferMgr.requireOutputBuffer(id, 1, this.outputVaryBuffer) });\r\n                    vertexBufferAttributes.push({\r\n                        arrayStride: 16,\r\n                        attributes: [{\r\n                            shaderLocation: id,\r\n                            format: 'float32x4' as GPUVertexFormat,\r\n                            offset: 0\r\n                        }]\r\n                    });\r\n                }\r\n\r\n            }\r\n        }\r\n        let bindGroup1declare = '';\r\n        for (let attr of input) {\r\n            if (!attr.startsWith(\"location(\")) continue;\r\n            let i = attr.charAt(9);\r\n            bindGroup1declare += `@group(1) @binding(${i}) var<storage, read> _attribute${i} : array<mat4x4f>;\\n`;\r\n        }\r\n        let parsedCode = vertexState.code.replace(/@tetra/g, \" \").replace(/@location\\s*\\(\\s*[0-9]+\\s*\\)\\s*/g, \" \").replace(/@builtin\\s*\\(\\s*[^\\)\\s]+\\s*\\)\\s*/g, \" \");\r\n        function makeInterpolate(a: number, b: number) {\r\n            let str = '';\r\n            for (let attr in output) {\r\n                let result = output[attr].type?.match(/array<(.+),(.+)>/);\r\n                let name = attr.startsWith(\"location(\") ? output[attr].expr : attr == \"builtin(position)\" ? \"refPosMat\" : \"\";\r\n                if (!name) continue;\r\n                let i = attr.startsWith(\"location(\") ? Number(attr.charAt(9)) + 1 : 0;\r\n                if (result) {\r\n                    let typeArrLength = Number(result[2]);\r\n                    for (let idx = 0; idx < typeArrLength; idx++)\r\n                        str += `output${i}s[offset][${idx}] = mix(${name}[${idx}][${a}],${name}[${idx}][${b}],alpha);\\n`;\r\n                } else {\r\n                    str += `output${i}s[offset] = mix(${name}[${a}],${name}[${b}],alpha);\\n`;\r\n                }\r\n            }\r\n            return str;\r\n        }\r\n        let cullOperator = descriptor.cullMode == \"back\" ? \"<\" : \">\";\r\n        let commonCameraSliceCode = `\r\nlet sign = step(vec4f(0.0,0.0,0.0,0.0),scalar);\r\nlet vertnum = sign.x + sign.y + sign.z + sign.w;\r\nif(!(vertnum == 0.0 || vertnum == 4.0)){ // if hit one slice\r\n    if(sign.x + sign.y == 1.0){\r\n        let alpha = scalar.x/(scalar.x - scalar.y);\r\n        ${makeInterpolate(0, 1)}\r\n        offset++;\r\n    }\r\n    if(sign.x + sign.z == 1.0){\r\n        let alpha = scalar.x/(scalar.x - scalar.z);\r\n        ${makeInterpolate(0, 2)}\r\n        offset++;\r\n    }\r\n    if(sign.x + sign.w == 1.0){\r\n        let alpha = scalar.x/(scalar.x - scalar.w);\r\n        ${makeInterpolate(0, 3)}\r\n        offset++;\r\n    }\r\n    if(sign.y + sign.z == 1.0){\r\n        let alpha = scalar.y/(scalar.y - scalar.z);\r\n        ${makeInterpolate(1, 2)}\r\n        offset++;\r\n    }\r\n    if(sign.y + sign.w == 1.0){\r\n        let alpha = scalar.y/(scalar.y - scalar.w);\r\n        ${makeInterpolate(1, 3)}\r\n        offset++;\r\n    }\r\n    if(sign.z + sign.w == 1.0){\r\n        let alpha = scalar.z/(scalar.z - scalar.w);\r\n        ${makeInterpolate(2, 3)}\r\n        offset++;\r\n    }\r\n\r\n    // offset is total vertices number (3 or 4), delta is faces number (3 or 6)\r\n    let delta:u32 = u32((offset - 2) * 3);\r\n    // get output location thread-safely\r\n    let outOffset : u32 = atomicAdd(&(_emitIndex_slice.emitIndex[i]), delta) + emitIndexOffset;\r\n    // write 3 vertices of first triangular face\r\n    ${emitOutput1}\r\n    // write 3 vertices of second triangular face if one has\r\n    if(offset == 4){\r\n        ${emitOutput2}\r\n    }\r\n} // end one hit\r\n`;\r\n        let crossComputeCode = refacingMatsCode + StructDefSliceInfo + StructDefUniformBuffer + `\r\nstruct _EmitIndex_Slice{\r\n    slice: array<tsxSliceInfo, ${config.maxSlicesNumber}>,\r\n    emitIndex: array<atomic<u32>>,\r\n}\r\n\r\n@group(0) @binding(0) var<storage, read_write> _emitIndex_slice: _EmitIndex_Slice;\r\n@group(0) @binding(1) var<uniform> tsx_uniforms : tsxUniformBuffer;\r\n@group(0) @binding(2) var<uniform> thumbnailViewport : array<vec4f,16>;\r\n${bindGroup0declare}\r\n${bindGroup1declare}\r\n\r\n// user defined functions and bind groups\r\n${parsedCode}\r\n\r\nconst tsx_emitIndexStride : u32 = ${config.maxCrossSectionBufferSize >> (config.sliceGroupSizeBit + 4)};\r\n@compute @workgroup_size(${vertexState.workgroupSize ?? config.defaultWorkGroupSize})\r\nfn _mainCompute(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>){\r\n    let tetraIndex = GlobalInvocationID.x;\r\n    let instanceIndex = GlobalInvocationID.y;\r\n    ${input.has(\"location(0)\") ? `\r\n    if(tetraIndex >= arrayLength(&_attribute0)){ // todo: check performance?\r\n        return;\r\n    }` : ``} \r\n    // calculate camera space coordinate : builtin(position) and other output need to be interpolated : location(x)\r\n    // call user defined code \r\n    ${call}\r\n    let cameraPosMat = ${output[\"builtin(position)\"].expr};\r\n    \r\n    var instanceLength:u32 = ${config.sliceGroupSize};\r\n    var refPosMat : mat4x4f;\r\n    var refCamMat : mat4x4f;\r\n    let sliceFlag = _emitIndex_slice.slice[tsx_uniforms.sliceOffset].flag;\r\n\r\n    if(tsx_uniforms.camProj.x < 0){ // Orthographic\r\n        let projBiais:mat4x4f = mat4x4f(\r\n            0,0,tsx_uniforms.camProj.w,1,\r\n            0,0,tsx_uniforms.camProj.w,1,\r\n            0,0,tsx_uniforms.camProj.w,1,\r\n            0,0,tsx_uniforms.camProj.w,1,\r\n        );\r\n        let projMat = mat4x4f(\r\n            -tsx_uniforms.camProj.x,0,0,0,\r\n            0,tsx_uniforms.camProj.y,0,0,\r\n            0,0,0,0,\r\n            0,0,tsx_uniforms.camProj.z,0,\r\n        );\r\n\r\n        ${(descriptor.cullMode == \"back\" || descriptor.cullMode == \"front\") ? `\r\n        // cull face: if all slices in this group has no eye4D offset, cull here\r\n        var cameraPosDetMat = transpose(cameraPosMat); \r\n        cameraPosDetMat[3] = vec4f(-1.0);\r\n        if(determinant(cameraPosDetMat) ${cullOperator} 0){ return; }` : \"\"}\r\n\r\n        // [uniform if] all slices are in retina, no eye4D\r\n        if(sliceFlag == 0){\r\n            // we get refacing mat from uniform for retina slices\r\n            let retinaRefacingMat = tsx_refacingMats[tsx_uniforms.refacing & 7];\r\n            // calculate standard device coordinate for retina: projection * refacing * view * model * pos\r\n            refCamMat = retinaRefacingMat * cameraPosMat;\r\n            refPosMat = projMat * refCamMat + projBiais;\r\n        }else{\r\n            instanceLength = _emitIndex_slice.slice[tsx_uniforms.sliceOffset].flag;\r\n        }\r\n        \r\n        // prepare for interpolations\r\n        var emitIndexOffset = 0u;\r\n        for(var i:u32 = 0; i<instanceLength; i++){\r\n            ${varInterpolate}\r\n            let sliceInfo = _emitIndex_slice.slice[tsx_uniforms.sliceOffset + i];\r\n            if(sliceInfo.slicePos > 1.0){\r\n                emitIndexOffset += tsx_emitIndexStride;\r\n                continue;\r\n            }\r\n            var offset = 0u;\r\n            if(sliceFlag != 0){\r\n                refCamMat = tsx_refacingMats[sliceInfo.refacing & 7] * cameraPosMat;\r\n                refPosMat = projMat * refCamMat + projBiais;\r\n                let vp = thumbnailViewport[tsx_uniforms.sliceOffset + i - (tsx_uniforms.refacing >> 5)];\r\n                let aspect = vp.w / vp.z;\r\n                refPosMat[0].x *= aspect;\r\n                refPosMat[1].x *= aspect;\r\n                refPosMat[2].x *= aspect;\r\n                refPosMat[3].x *= aspect;\r\n            }\r\n            // calculate cross section pos * plane.normal\r\n            let scalar = transpose(refCamMat)[2] + vec4f(sliceInfo.slicePos / tsx_uniforms.camProj.x); \r\n            ${commonCameraSliceCode}\r\n            emitIndexOffset += tsx_emitIndexStride;\r\n        } // end all hits\r\n    }else{\r\n        let preclipW = cameraPosMat[0].w >= 0 && cameraPosMat[1].w >= 0 && cameraPosMat[2].w >= 0  && cameraPosMat[3].w >= 0;\r\n        if(preclipW){ return; }\r\n        let projBiais:mat4x4f = mat4x4f(\r\n            0,0,tsx_uniforms.camProj.w,0,\r\n            0,0,tsx_uniforms.camProj.w,0,\r\n            0,0,tsx_uniforms.camProj.w,0,\r\n            0,0,tsx_uniforms.camProj.w,0\r\n        );\r\n        let projMat = mat4x4f(\r\n            tsx_uniforms.camProj.x,0,0,0,\r\n            0,tsx_uniforms.camProj.y,0,0,\r\n            0,0,0,0,\r\n            0,0,tsx_uniforms.camProj.z,-1,\r\n        );\r\n        let eyeMat = mat4x4f(\r\n            tsx_uniforms.eyeCross.x,0,0,0,\r\n            tsx_uniforms.eyeCross.x,0,0,0,\r\n            tsx_uniforms.eyeCross.x,0,0,0,\r\n            tsx_uniforms.eyeCross.x,0,0,0\r\n        );\r\n        // [uniform if] all slices are in retina, no eye4D\r\n        if(sliceFlag == 0){\r\n            ${(descriptor.cullMode == \"back\" || descriptor.cullMode == \"front\") ? `\r\n            // cull face: if all slices in this group has no eye4D offset, cull here\r\n            if(determinant(cameraPosMat) ${cullOperator} 0){ return; }` : \"\"}\r\n            \r\n            // we get refacing mat from uniform for retina slices\r\n            let retinaRefacingMat = tsx_refacingMats[tsx_uniforms.refacing & 7];\r\n            // calculate standard device coordinate for retina: projection * refacing * view * model * pos\r\n            refCamMat = retinaRefacingMat * cameraPosMat;\r\n            refPosMat = projMat * refCamMat + projBiais;\r\n        }else{\r\n            instanceLength = _emitIndex_slice.slice[tsx_uniforms.sliceOffset].flag;\r\n        }\r\n        \r\n        // prepare for interpolations\r\n        var emitIndexOffset = 0u;\r\n        for(var i:u32 = 0; i<instanceLength; i++){\r\n            ${varInterpolate}\r\n            let sliceInfo = _emitIndex_slice.slice[tsx_uniforms.sliceOffset + i];\r\n            if(sliceInfo.slicePos > 1.0){\r\n                emitIndexOffset += tsx_emitIndexStride;\r\n                continue;\r\n            }\r\n            var offset = 0u;\r\n            if(sliceFlag != 0){\r\n                refCamMat = tsx_refacingMats[sliceInfo.refacing & 7] * cameraPosMat + \r\n                    eyeMat * (f32(sliceInfo.refacing >> 3) - 1.0);\r\n                    ${(descriptor.cullMode == \"back\" || descriptor.cullMode == \"front\") ? `\r\n                if(determinant(refCamMat) * determinantRefacingMats[sliceInfo.refacing & 7] ${cullOperator} 0){\r\n                    emitIndexOffset += tsx_emitIndexStride;\r\n                    continue;\r\n                }`: \"\"}\r\n                refPosMat = projMat * refCamMat + projBiais;\r\n                let vp = thumbnailViewport[tsx_uniforms.sliceOffset + i - (tsx_uniforms.refacing >> 5)];\r\n                let aspect = vp.w / vp.z;\r\n                refPosMat[0].x *= aspect;\r\n                refPosMat[1].x *= aspect;\r\n                refPosMat[2].x *= aspect;\r\n                refPosMat[3].x *= aspect;\r\n            }\r\n            // calculate cross section pos * plane.normal\r\n            let scalar = transpose(refCamMat) * vec4(0.0,0.0,1.0,sliceInfo.slicePos / tsx_uniforms.camProj.x); \r\n            ${commonCameraSliceCode}\r\n            emitIndexOffset += tsx_emitIndexStride;\r\n        } // end all hits\r\n    } // end camera type\r\n}\r\n`;\r\n        this.crossComputeShaderModule = this.gpu.device.createShaderModule({\r\n            code: crossComputeCode\r\n        });\r\n        let computePipelinePromise = this.gpu.device.createComputePipelineAsync({\r\n            layout: layout.computeLayout as GPUPipelineLayout | GPUAutoLayoutMode,\r\n            compute: {\r\n                module: this.crossComputeShaderModule,\r\n                entryPoint: '_mainCompute'\r\n            }\r\n        });\r\n        vertexBufferAttributes.sort((a, b) =>\r\n            (a.attributes[0].shaderLocation - b.attributes[0].shaderLocation)\r\n        );\r\n        let shaderLocationCounter = 0;\r\n        for (let vba of vertexBufferAttributes) {\r\n            for (let attr of vba.attributes) {\r\n                attr.shaderLocation = shaderLocationCounter++;\r\n            }\r\n        }\r\n        for (let i = 0; i < shaderLocationCounter; i++) {\r\n            let attr = i ? `location(${i - 1})` : \"builtin(position)\";\r\n            vinputVert += `@location(${i}) member${i}: vec4f,\\n`;\r\n            voutputVert += `@${attr} member${i}: vec4f,\\n`;\r\n            vcallVert += `data.member${i},`;\r\n        }\r\n        const vertexShaderModule = this.gpu.device.createShaderModule({\r\n            code: `\r\nstruct tsxvInputType{\r\n    ${vinputVert}\r\n};\r\nstruct tsxvOutputType{\r\n    ${voutputVert}\r\n};\r\n@vertex fn main(data : tsxvInputType)-> tsxvOutputType{\r\n    return tsxvOutputType(${vcallVert});\r\n}\r\n`});\r\n        this.fragmentShaderModule = this.gpu.device.createShaderModule({ code: descriptor.fragment.code });\r\n        let renderPipelinePromise = this.gpu.device.createRenderPipelineAsync({\r\n            layout: layout.renderLayout as GPUPipelineLayout | GPUAutoLayoutMode,\r\n            vertex: {\r\n                module: vertexShaderModule,\r\n                entryPoint: 'main',\r\n                buffers: vertexBufferAttributes,\r\n            },\r\n            fragment: {\r\n                module: this.fragmentShaderModule,\r\n                entryPoint: descriptor.fragment.entryPoint,\r\n                targets: [{ format: this.gpu.preferredFormat }]\r\n            },\r\n            primitive: {\r\n                topology: 'triangle-list',\r\n            },\r\n            depthStencil: {\r\n                depthWriteEnabled: true,\r\n                depthCompare: 'less',\r\n                format: 'depth24plus',\r\n            }\r\n        });\r\n        const [computePipeline, renderPipeline] = await Promise.all([computePipelinePromise, renderPipelinePromise]);\r\n        this.computePipeline = computePipeline;\r\n        this.renderPipeline = renderPipeline;\r\n        this.computeBindGroup0 = this.gpu.createBindGroup(computePipeline, 0, computeGroup0Buffers, \"TetraComputePipeline\");\r\n        return this;\r\n    }\r\n    private getBindGroupLayout(output: {\r\n        [name: string]: { expr: string; type: string; }\r\n    }) {\r\n        let computeBindGroupLayouts: GPUBindGroupLayout[] = [];\r\n        let renderBindGroupLayouts: GPUBindGroupLayout[] = [];\r\n        const layout = this.descriptor.layout;\r\n        if (!layout || layout === 'auto') return {\r\n            computeLayout: 'auto' as GPUAutoLayoutMode,\r\n            renderLayout: 'auto' as GPUAutoLayoutMode\r\n        }\r\n        let computeLayout = layout?.computeLayout;\r\n        let renderLayout = layout?.renderLayout;\r\n        if ((computeLayout !== 'auto' && computeLayout as GPUBindGroupLayoutDescriptor[])?.length) {\r\n            const bindGroupLayoutsDesc = (computeLayout as GPUBindGroupLayoutDescriptor[]);\r\n            let bindgroupLayouts = this.reflect.getBindGroups();\r\n            for (let groupIdx = 0, l = bindgroupLayouts.length; groupIdx < l; groupIdx++) {\r\n                let groupLayoutDesc: Array<GPUBindGroupLayoutEntry> = [];\r\n                if (groupIdx === 0) {\r\n                    // here Object.keys(output).length - 1 because it has \"return\" key\r\n                    for (let i = 0, l = Object.keys(output).length - 1 + tetraSliceBindGroup0declareIndex; i < l; i++) {\r\n                        const type: GPUBufferBindingType = i && i < tetraSliceBindGroup0declareIndex ? 'uniform' : 'storage';\r\n                        groupLayoutDesc.push({ binding: i, visibility: GPUShaderStage.COMPUTE, buffer: { type } });\r\n                    }\r\n                } else {\r\n                    const bindings = bindgroupLayouts[groupIdx];\r\n                    for (let i = 0, l = bindings.length; i < l; i++) {\r\n                        const entry = (bindGroupLayoutsDesc[groupIdx]?.entries as Array<GPUBindGroupLayoutEntry>)?.filter(\r\n                            e => e.binding === i\r\n                        )[0];\r\n                        const descriptor = bindings[i];\r\n                        if (entry) {\r\n                            groupLayoutDesc.push(entry);\r\n                        } else if (!descriptor) {\r\n                            groupLayoutDesc.push({ binding: i, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } });\r\n                        } else if (descriptor.resourceType === ResourceType.Storage) {\r\n                            groupLayoutDesc.push({ binding: i, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } });\r\n                        } else if (descriptor.resourceType === ResourceType.Uniform) {\r\n                            groupLayoutDesc.push({ binding: i, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'uniform' } });\r\n                        }\r\n                    }\r\n                }\r\n                const bindGroupLayout = this.device.createBindGroupLayout({ entries: groupLayoutDesc });\r\n                computeBindGroupLayouts.push(bindGroupLayout);\r\n            }\r\n            computeLayout = this.device.createPipelineLayout({ bindGroupLayouts: computeBindGroupLayouts, label: \"computeBindGroupLayoutDesc\" });\r\n        }\r\n\r\n        if ((renderLayout !== 'auto' && renderLayout as GPUBindGroupLayoutDescriptor[])?.length) {\r\n            const bindGroupLayoutsDesc = (renderLayout as GPUBindGroupLayoutDescriptor[]);\r\n            const renderReflect = new WgslReflect(this.descriptor.fragment.code);\r\n            let bindgroupLayouts = renderReflect.getBindGroups();\r\n            for (let groupIdx = 0, l = bindgroupLayouts.length; groupIdx < l; groupIdx++) {\r\n                let groupLayoutDesc: Array<GPUBindGroupLayoutEntry> = [];\r\n\r\n                const bindings = bindgroupLayouts[groupIdx];\r\n                for (let i = 0, l = bindings.length; i < l; i++) {\r\n                    const entry = (bindGroupLayoutsDesc[groupIdx]?.entries as Array<GPUBindGroupLayoutEntry>)?.filter(\r\n                        e => e.binding === i\r\n                    )[0];\r\n                    if (entry) {\r\n                        groupLayoutDesc.push(entry);\r\n                    } else if (!bindings[i] || bindings[i].resourceType === ResourceType.Storage) {\r\n                        groupLayoutDesc.push({ binding: i, visibility: GPUShaderStage.FRAGMENT, buffer: {} });\r\n                    } else if (bindings[i].resourceType === ResourceType.Storage) {\r\n                        groupLayoutDesc.push({ binding: i, visibility: GPUShaderStage.FRAGMENT, buffer: {} });\r\n                    } else if (bindings[i].resourceType === ResourceType.Sampler) {\r\n                        groupLayoutDesc.push({ binding: i, visibility: GPUShaderStage.FRAGMENT, sampler: {} });\r\n                    } else if (bindings[i].resourceType === ResourceType.Texture) {\r\n                        groupLayoutDesc.push({ binding: i, visibility: GPUShaderStage.FRAGMENT, texture: {} });\r\n                    }\r\n                }\r\n                const bindGroupLayout = this.device.createBindGroupLayout({ entries: groupLayoutDesc });\r\n                renderBindGroupLayouts.push(bindGroupLayout);\r\n            }\r\n            renderLayout = this.device.createPipelineLayout({ bindGroupLayouts: renderBindGroupLayouts, label: \"renderBindGroupLayoutDesc\" });\r\n        }\r\n        return {\r\n            computeLayout, renderLayout\r\n        }\r\n    }\r\n}\r\n\r\nexport class RaytracingPipeline {\r\n    pipeline: GPURenderPipeline;\r\n    bindGroup0: GPUBindGroup;\r\n    shaderModule: GPUShaderModule;\r\n    getCompilationInfo(){\r\n        return this.shaderModule?.getCompilationInfo();\r\n    }\r\n    async init(gpu: GPU, config: InternalSliceRendererConfig, descriptor: RaytracingPipelineDescriptor, sliceBuffers: RetinaSliceBufferMgr) {\r\n        let code = descriptor.code.replace(/@ray(\\s)/g, \"@vertex$1\");\r\n        const reflect = new WgslReflect(code);\r\n        let mainRayFn = reflect._functions.get(descriptor.rayEntryPoint);\r\n        if (!mainRayFn) console.error(\"Raytracing pipeline: Entry point does not exist.\");\r\n        // let mainFragFn = reflect.functions.filter(\r\n        //     e => e.attributes && e.attributes.some(a => a.name === \"fragment\") && e.name == descriptor.fragment.entryPoint\r\n        // )[0];\r\n        let { input, output, call } = getFnInputAndOutput(reflect, mainRayFn,\r\n            {\r\n                \"builtin(ray_origin)\": \"camRayOri\",\r\n                \"builtin(ray_direction)\": \"camRayDir\",\r\n                \"builtin(voxel_coord)\": \"voxelCoord\",\r\n                \"builtin(aspect_matrix)\": \"refacingMat3 * mat3x3<f32>(aspect,0.0,0.0, 0.0,1.0,0.0, 0.0,0.0,1.0) * refacingMat3\",\r\n            },\r\n            [\"location(0)\", \"location(1)\", \"location(2)\", \"location(3)\", \"location(4)\", \"location(5)\"]\r\n        );\r\n        let dealRefacingCall = \"\";\r\n        if (input.has(\"builtin(aspect_matrix)\")) {\r\n            dealRefacingCall = \"let refacingMat3 = mat3x3<f32>(refacingMat[0].xyz,refacingMat[1].xyz,refacingMat[2].xyz);\"\r\n        }\r\n        let retunTypeMembers: string;\r\n        let outputMembers: string;\r\n        if (mainRayFn.node.returnType.attributes) {\r\n            outputMembers = output[\"return\"].expr;\r\n            retunTypeMembers = `@${parseAttr(mainRayFn.node.returnType.attributes)} ${parseTypeName(mainRayFn.node.returnType as any as TypeInfo)}`;\r\n        } else {\r\n            let st = reflect.structs.filter(s => s.name === mainRayFn.node.returnType.name)[0];\r\n            if (!st) console.error(\"No attribute found\");\r\n            outputMembers = st.members.map(m => output[parseAttr(m.attributes)].expr).join(\",\\n\");\r\n            retunTypeMembers = st.members.map(m => `@${parseAttr(m.attributes)} ${m.name}: ${parseTypeName(m.type)}`).join(\",\\n\");\r\n        }\r\n\r\n        // ${wgslreflect.parseAttr(mainRayFn.return.attributes)} userRayOut: ${wgslreflect.parseTypeName(mainRayFn.return)}\r\n        let shaderCode = refacingMatsCode + StructDefSliceInfo + StructDefUniformBuffer + `\r\nstruct tsxvOut{\r\n    @builtin(position) pos: vec4f,\r\n    ${retunTypeMembers}\r\n}\r\nstruct tsxAffineMat{\r\n    matrix: mat4x4f,\r\n    vector: vec4f,\r\n}\r\n@group(0) @binding(0) var<storage, read> tsx_slice: array<tsxSliceInfo, ${config.maxSlicesNumber}>;\r\n\r\n@group(0) @binding(1) var<uniform> tsx_uniforms : tsxUniformBuffer;\r\n@group(0) @binding(2) var<uniform> thumbnailViewport : array<vec4f,16>;\r\nfn apply(afmat: tsxAffineMat, points: mat4x4f) -> mat4x4f{\r\n    let biais = mat4x4f(afmat.vector, afmat.vector, afmat.vector, afmat.vector);\r\n    return afmat.matrix * points + biais;\r\n}\r\nfn applyinv(afmat: tsxAffineMat, points: mat4x4f) -> mat4x4f{\r\n    let biais = mat4x4f(afmat.vector, afmat.vector, afmat.vector, afmat.vector);\r\n    return transpose(afmat.matrix) * (points - biais);\r\n}\r\n${code.replace(/@vertex/g, \" \").replace(/@builtin\\s*\\(\\s*(ray_origin|ray_direction|voxel_coord|aspect_matrix)\\s*\\)\\s*/g, \" \")}\r\n@vertex fn mainVertex(@builtin(vertex_index) vindex:u32, @builtin(instance_index) i_index:u32) -> tsxvOut{\r\n    const pos = array<vec2<f32>, 4>(\r\n        vec2<f32>(-1.0, -1.0),\r\n        vec2<f32>(-1.0, 1.0),\r\n        vec2<f32>( 1.0, -1.0),\r\n        vec2<f32>( 1.0, 1.0),\r\n    );\r\n    let sliceInfo = tsx_slice[tsx_uniforms.sliceOffset + i_index];\r\n    let sliceFlag = tsx_slice[tsx_uniforms.sliceOffset].flag;\r\n    var refacingEnum : u32;\r\n\r\n    let posidx = pos[vindex];\r\n    let coord = vec2<f32>(posidx.x, posidx.y);\r\n    var aspect = 1.0;\r\n    var rayPos = vec4f(0.0);// no eye offset for retina\r\n    var rayDir = vec4f(0.0,0.0,0.0,-1.0);// point forward for Orthographic camera\r\n    if(tsx_uniforms.camProj.x < 0){\r\n        rayPos = vec4f(coord.x/tsx_uniforms.camProj.x * aspect, coord.y/tsx_uniforms.camProj.y, sliceInfo.slicePos/tsx_uniforms.camProj.x, -tsx_uniforms.camProj.w/tsx_uniforms.camProj.z);\r\n    }else{\r\n        if(sliceFlag == 0){\r\n            refacingEnum = tsx_uniforms.refacing;\r\n        }else{\r\n            refacingEnum = sliceInfo.refacing;\r\n            let vp = thumbnailViewport[tsx_uniforms.sliceOffset + i_index - (tsx_uniforms.refacing >> 5)];\r\n            aspect = vp.z / vp.w;\r\n            rayPos = vec4f(-tsx_uniforms.eyeCross.x * (f32(sliceInfo.refacing >> 3) - 1.0), 0.0, 0.0, 0.0);\r\n        }\r\n        rayDir = vec4f(coord.x/tsx_uniforms.camProj.x * aspect, coord.y/tsx_uniforms.camProj.y, sliceInfo.slicePos/tsx_uniforms.camProj.x, -1.0);\r\n    }\r\n    let refacingMat = tsx_refacingMats[refacingEnum & 7];\r\n    let camRayDir = refacingMat * rayDir;\r\n    let camRayOri = refacingMat * rayPos;\r\n    let voxelCoord = (refacingMat * vec4f(coord, sliceInfo.slicePos,0.0)).xyz;\r\n    ${dealRefacingCall}\r\n    ${call}\r\n    let x = f32(((sliceInfo.viewport >> 24) & 0xFF) << ${config.viewportCompressShift}) * ${1 / config.sliceTextureWidth};\r\n    let y = f32(((sliceInfo.viewport >> 16) & 0xFF) << ${config.viewportCompressShift}) * ${1 / config.sliceTextureHeight};\r\n    let w = f32(((sliceInfo.viewport >> 8 ) & 0xFF) << ${config.viewportCompressShift}) * ${1 / config.sliceTextureWidth};\r\n    let h = f32((sliceInfo.viewport & 0xFF) << ${config.viewportCompressShift}) * ${1 / config.sliceTextureHeight};\r\n    let texelCoord = array<vec2<f32>, 4>(\r\n        vec2<f32>(x, y+h),\r\n        vec2<f32>(x, y),\r\n        vec2<f32>(x+w, y+h),\r\n        vec2<f32>(x+w, y),\r\n    )[vindex] * 2.0 - vec2<f32>(1.0);\r\n    \r\n    if(sliceInfo.slicePos > 1.0){\r\n        return tsxvOut(\r\n            vec4f(0.0,0.0,0.0, -1.0),\r\n            ${outputMembers}\r\n        );\r\n    }else{\r\n        return tsxvOut(\r\n            vec4f(texelCoord.x,-texelCoord.y, 0.999999, 1.0),\r\n            ${outputMembers}\r\n        );\r\n    }\r\n}\r\nfn calDepth(distance: f32)->f32{\r\n    return -tsx_uniforms.camProj.z + tsx_uniforms.camProj.w / distance;\r\n}\r\n`;\r\n        let module = gpu.device.createShaderModule({ code: shaderCode });\r\n        this.shaderModule = module;\r\n        this.pipeline = await gpu.device.createRenderPipelineAsync({\r\n            layout: 'auto',\r\n            vertex: {\r\n                module,\r\n                entryPoint: 'mainVertex',\r\n            },\r\n            fragment: {\r\n                module,\r\n                entryPoint: descriptor.fragmentEntryPoint,\r\n                targets: [{ format: gpu.preferredFormat }]\r\n            },\r\n            primitive: {\r\n                topology: 'triangle-strip',\r\n            },\r\n            depthStencil: {\r\n                depthWriteEnabled: true,\r\n                depthCompare: 'less',\r\n                format: 'depth24plus',\r\n            }\r\n        });\r\n\r\n        let buffers = [\r\n            { buffer: sliceBuffers.emitIndexSliceBuffer },\r\n            { buffer: sliceBuffers.uniformsBuffer },\r\n            { buffer: sliceBuffers.thumbnailViewportBuffer },\r\n        ];\r\n        this.bindGroup0 = gpu.createBindGroup(this.pipeline, 0, buffers);\r\n\r\n        return this;\r\n    }\r\n\r\n};"],"names":["WgslReflect","i","ResourceType"],"mappings":"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"}
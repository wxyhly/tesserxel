{"version":3,"file":"renderer.js","sources":["../../../../src/render/slice/renderer.ts"],"sourcesContent":["import { AffineMat4, Obj4 } from \"../../math/algebra/affine.js\";\r\nimport { Mat4 } from \"../../math/algebra/mat4.js\";\r\nimport { Vec4 } from \"../../math/algebra/vec4.js\";\r\nimport { _RAD2DEG } from \"../../math/const.js\";\r\nimport { OrthographicCamera, PerspectiveCamera, getOrthographicProjectionMatrix, getPerspectiveProjectionMatrix } from \"../../math/geometry/camera.js\";\r\nimport { AABB, Plane } from \"../../math/geometry/primitive.js\";\r\nimport { GPU } from \"../gpu.js\";\r\nimport { DefaultDisplayConfig, DisplayConfig, DisplayConfigName, EyeStereo, IWireframeRenderState, RaytracingPipelineDescriptor, RetinaRenderPassDescriptor, RetinaSliceFacing, SectionConfig, SliceRendererConfig, TetraSlicePipelineDescriptor } from \"./interfaces.js\";\r\nimport { RaytracingPipeline, StructDefSliceInfo, StructDefUniformBuffer, TetraSlicePipeline, refacingMatsCode } from \"./pipeline.js\";\r\nimport { RenderState as IRenderState, RetinaRenderPass as IRetinaRenderPass } from \"./interfaces.js\";\r\n/** Internal use for SliceRenderer's Display Configs */\r\nexport interface InternalDisplayConfig extends DisplayConfig {\r\n    opacity: number;\r\n    paddedSliceNum: number;\r\n    sliceGroupNum: number;\r\n    totalGroupNum: number;\r\n    enableStereo: boolean;\r\n}\r\n/** Internal use for SliceRenderer's Base Configs */\r\nexport interface InternalSliceRendererConfig extends SliceRendererConfig {\r\n    /** log2 of sliceGroupSize in SliceRendererConfig */\r\n    sliceGroupSizeBit: number;\r\n    /** A gpu device limit to set textures as large as possible */\r\n    maxTextureSize: number;\r\n    /** viewport data is compressed in gpu buffer, this gives the amount */\r\n    viewportCompressShift: number;\r\n    /** SliceTexture is a big 2d texuture containing all slices within a slice group*/\r\n    sliceTextureWidth: number;\r\n    sliceTextureHeight: number;\r\n}\r\nconst DefaultWorkGroupSize = 256;\r\nconst DefaultSliceGroupSize = 16;\r\nconst DefaultMaxSlicesNumber = 256;\r\nconst DefaultMaxCrossSectionBufferSize = 0x800000;\r\nconst DefaultEnableFloat16Blend = true;\r\nconst uniformsBufferLength = 64 + 64 + 16 + 4 + 4 + 4 + 4 + 12 + 4; // last 4 is padding\r\nconst retinaMVBufferOffset = 0;\r\nconst retinaProjectBufferOffset = 64;\r\nconst camProjBufferOffset = retinaProjectBufferOffset + 64;\r\nconst eyeCrossBufferOffset = camProjBufferOffset + 16;\r\nconst sliceOffsetBufferOffset = eyeCrossBufferOffset + 12;\r\nconst refacingBufferOffset = sliceOffsetBufferOffset + 4;\r\nconst screenAspectBufferOffset = refacingBufferOffset + 4;\r\nconst layerOpacityBufferOffset = screenAspectBufferOffset + 4;\r\nconst power2arr = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512];\r\nlet linearTextureSampler: GPUSampler;\r\n\r\nexport class SliceRenderer {\r\n\r\n    gpu: GPU;\r\n    private tetraBuffers: TetraSliceBufferMgr;\r\n    private sliceBuffers: RetinaSliceBufferMgr;\r\n    private crossRenderPass: CrossRenderPass;\r\n    private retinaRenderPass: RetinaRenderPass;\r\n    private screenRenderPass: ScreenRenderPass;\r\n    private rendererConfig: InternalSliceRendererConfig;\r\n    private displayConfig: InternalDisplayConfig;\r\n    private wireframeRenderPass: WireFrameRenderPass;\r\n\r\n    constructor(gpu: GPU, config?: SliceRendererConfig) {\r\n        if (!gpu.device) throw \"GPU is not initialized yet.\";\r\n        config ??= {};\r\n        config.maxSlicesNumber ??= DefaultMaxSlicesNumber;\r\n        config.enableFloat16Blend ??= DefaultEnableFloat16Blend;\r\n        config.maxCrossSectionBufferSize ??= DefaultMaxCrossSectionBufferSize;\r\n        config.sliceGroupSize ??= DefaultSliceGroupSize;\r\n        config.defaultWorkGroupSize ??= DefaultWorkGroupSize;\r\n\r\n        this.rendererConfig = config as InternalSliceRendererConfig;\r\n        this.rendererConfig.sliceGroupSizeBit = power2arr.indexOf(config.sliceGroupSize);\r\n        const maxTextureSize = gpu.device.limits.maxTextureDimension2D;\r\n        this.rendererConfig.maxTextureSize = maxTextureSize;\r\n        this.rendererConfig.sliceTextureWidth = maxTextureSize >> 1;\r\n        this.rendererConfig.sliceTextureHeight = maxTextureSize;\r\n        // viewport is compressed in gpu buffer by four u8s, therefore shift amount is maxSize >> 8\r\n        this.rendererConfig.viewportCompressShift = power2arr.indexOf(this.rendererConfig.maxTextureSize >> 8);\r\n        this.gpu = gpu;\r\n        this.wireframeRenderPass = new WireFrameRenderPass(gpu, this.rendererConfig);\r\n        this.sliceBuffers = new RetinaSliceBufferMgr(gpu, this.rendererConfig);\r\n        this.tetraBuffers = new TetraSliceBufferMgr(gpu, this.rendererConfig, this.sliceBuffers);\r\n        this.crossRenderPass = new CrossRenderPass(gpu);\r\n        this.retinaRenderPass = new RetinaRenderPass(gpu, this.rendererConfig, this.sliceBuffers, this.crossRenderPass);\r\n        this.screenRenderPass = new ScreenRenderPass(gpu, this.rendererConfig, this.sliceBuffers);\r\n        linearTextureSampler = gpu.device.createSampler({\r\n            magFilter: 'linear',\r\n            minFilter: 'linear'\r\n        });\r\n        this.displayConfig = {\r\n            sections: [], retinaResolution: 0, retinaLayers: 0,\r\n            retinaStereoEyeOffset: 0, sectionStereoEyeOffset: 0, crosshair: 0,\r\n            opacity: 1, paddedSliceNum: 0, sliceGroupNum: 0, totalGroupNum: 0, enableStereo: false\r\n        };\r\n        this.setDisplayConfig(DefaultDisplayConfig);\r\n    }\r\n    async init() {\r\n        await Promise.all([this.crossRenderPass.init(), this.retinaRenderPass.init(), this.screenRenderPass.init(), this.wireframeRenderPass.init()]);\r\n        return this;\r\n    }\r\n    createRetinaRenderPass(descriptor: RetinaRenderPassDescriptor): IRetinaRenderPass {\r\n        return new RetinaRenderPass(this.gpu, this.rendererConfig, this.sliceBuffers, this.crossRenderPass, descriptor) as IRetinaRenderPass;\r\n    }\r\n    setRetinaRenderPass(retinaRenderPass: IRetinaRenderPass) {\r\n        this.retinaRenderPass = retinaRenderPass as RetinaRenderPass;\r\n    }\r\n    getCurrentRetinaRenderPass() {\r\n        return this.retinaRenderPass as IRetinaRenderPass;\r\n    }\r\n    setDisplayConfig(config: DisplayConfig) {\r\n\r\n        /// Small buffers settings\r\n\r\n        if (config.canvasSize) {\r\n            this.displayConfig.canvasSize = config.canvasSize;\r\n            this.screenRenderPass.setSize(config.canvasSize);\r\n        }\r\n        if (config.screenBackgroundColor) {\r\n            this.displayConfig.screenBackgroundColor = (\r\n                (config.screenBackgroundColor as number[])?.length === 3\r\n            ) ? [...config.screenBackgroundColor as number[], 1] : config.screenBackgroundColor;\r\n        }\r\n        if (config.retinaClearColor) {\r\n            this.displayConfig.retinaClearColor = config.retinaClearColor\r\n            this.crossRenderPass.descClear.colorAttachments[0].clearValue = config.retinaClearColor;\r\n        }\r\n        config.retinaLayers ??= this.displayConfig.retinaLayers ?? 0;\r\n        config.opacity ??= this.displayConfig.opacity ?? 1;\r\n        config.crosshair ??= this.displayConfig.crosshair ?? 0;\r\n        config.retinaStereoEyeOffset ??= this.displayConfig.retinaStereoEyeOffset;\r\n        config.sectionStereoEyeOffset ??= this.displayConfig.sectionStereoEyeOffset;\r\n\r\n        if (config.opacity !== this.displayConfig.opacity || config.retinaLayers !== this.displayConfig.retinaLayers) {\r\n            // When sliceNum == 0, opacity is 0 -> detect opacity to not render crosshair\r\n            let value = config.retinaLayers ? config.opacity / config.retinaLayers : 0.0;\r\n            this.gpu.device.queue.writeBuffer(this.sliceBuffers.uniformsBuffer, layerOpacityBufferOffset, new Float32Array([value]));\r\n            this.displayConfig.opacity = config.opacity;\r\n        }\r\n        if (\r\n            config.retinaStereoEyeOffset !== this.displayConfig.retinaStereoEyeOffset ||\r\n            config.sectionStereoEyeOffset !== this.displayConfig.sectionStereoEyeOffset ||\r\n            config.crosshair !== this.displayConfig.crosshair\r\n        ) {\r\n            this.displayConfig.retinaStereoEyeOffset = config.retinaStereoEyeOffset;\r\n            this.displayConfig.sectionStereoEyeOffset = config.sectionStereoEyeOffset;\r\n            this.displayConfig.crosshair = config.crosshair;\r\n            this.gpu.device.queue.writeBuffer(this.sliceBuffers.uniformsBuffer, eyeCrossBufferOffset, new Float32Array([\r\n                config.sectionStereoEyeOffset, config.retinaStereoEyeOffset, config.crosshair\r\n            ]));\r\n            this.displayConfig.enableStereo = this.displayConfig.sectionStereoEyeOffset !== 0 || this.displayConfig.retinaStereoEyeOffset !== 0;\r\n        }\r\n\r\n        if (config.camera4D) this.sliceBuffers.setCameraProjectMatrix(config.camera4D);\r\n        if (config.camera3D) this.sliceBuffers.setRetinaProjectMatrix(config.camera3D);\r\n        if (config.retinaViewMatrix) this.sliceBuffers.setRetinaViewMatrix(config.retinaViewMatrix);\r\n\r\n        /// Small buffers settings end\r\n\r\n        if ((!config.sections) && (this.displayConfig.retinaLayers == config.retinaLayers\r\n        ) && (!config.retinaResolution)) return;\r\n\r\n        /// Retina and section configurations\r\n\r\n        this.sliceBuffers.setSlicesAndSections(this.displayConfig, config);\r\n\r\n    }\r\n    getSafeTetraNumInOnePass() {\r\n        // maximum vertices per slice\r\n        let maxVertices = this.rendererConfig.maxCrossSectionBufferSize >> (this.rendererConfig.sliceGroupSizeBit + 4);\r\n        // one tetra generate at most 6 vertices\r\n        return Math.floor(maxVertices / 6);\r\n    }\r\n    getStereoMode() { return this.getDisplayConfig('retinaStereoEyeOffset') !== 0 || this.getDisplayConfig('sectionStereoEyeOffset') !== 0; }\r\n    getMinResolutionMultiple() { return 1 << this.rendererConfig.viewportCompressShift; }\r\n    getDisplayConfig(configNames: 'canvasSize'): GPUExtent3DStrict;\r\n    getDisplayConfig(configNames: 'sections'): SectionConfig[];\r\n    getDisplayConfig(configNames: 'retinaViewMatrix'): Mat4;\r\n    getDisplayConfig(configNames: 'camera3D' | 'camera4D'): PerspectiveCamera | OrthographicCamera;\r\n    getDisplayConfig(configNames: \"screenBackgroundColor\" | \"retinaClearColor\"): GPUColor;\r\n    getDisplayConfig(configNames: 'retinaLayers' | 'retinaResolution' | 'opacity' | 'sectionStereoEyeOffset' | 'retinaStereoEyeOffset' | 'crosshair'): number;\r\n    getDisplayConfig(...configNames: DisplayConfigName[]) {\r\n        const cfg = this.displayConfig;\r\n        if (!configNames || !configNames.length) {\r\n            return {\r\n                canvasSize: cfg.canvasSize,\r\n                sections: this.sliceBuffers.deepCopySectionConfigs(cfg.sections),\r\n                retinaLayers: cfg.retinaLayers,\r\n                retinaResolution: cfg.retinaResolution,\r\n                opacity: cfg.opacity,\r\n                retinaStereoEyeOffset: cfg.retinaStereoEyeOffset,\r\n                sectionStereoEyeOffset: cfg.sectionStereoEyeOffset,\r\n                crosshair: cfg.crosshair,\r\n                screenBackgroundColor: cfg.screenBackgroundColor,\r\n                retinaClearColor: cfg.retinaClearColor,\r\n                camera4D: cfg.camera4D,\r\n                camera3D: cfg.camera3D,\r\n                retinaViewMatrix: cfg.retinaViewMatrix,\r\n            } as DisplayConfig;\r\n        }\r\n        if (configNames.length === 1) {\r\n            const name = configNames[0];\r\n            switch (name) {\r\n                case 'sections': return this.sliceBuffers.deepCopySectionConfigs(cfg.sections);\r\n                default: return cfg[name];\r\n            }\r\n        }\r\n        return configNames.map(name => name === 'sections' ? this.sliceBuffers.deepCopySectionConfigs(cfg.sections) : cfg[name]);\r\n    }\r\n    render(context: GPUCanvasContext, drawCall: (rs: IRenderState) => void, wireFrameDrawCall?: (rs: IWireframeRenderState) => void) {\r\n        this.sliceBuffers.updateBuffers(this.displayConfig.sliceGroupNum);\r\n\r\n        const gpu = this.gpu;\r\n        if (!this.crossRenderPass.clearRenderPipeline) throw \"SliceRenderer is not initailzed, forget to call 'await SliceRenderer.init()' ?\";\r\n        if (!this.retinaRenderPass.pipeline) throw \"SliceRenderer's current retinaRenderPass is not initailzed, forget to call 'await RetinaRenderPass.init()' ?\";\r\n        let canvasView = context.getCurrentTexture().createView();\r\n        const renderState = new RenderState(this.gpu, this.rendererConfig, this.sliceBuffers, this.tetraBuffers, this.crossRenderPass);\r\n        const commandEncoder = renderState.commandEncoder;\r\n        // todo: disable depth first, then add it\r\n        if (wireFrameDrawCall) {\r\n            this.wireframeRenderPass.renderPassDesc = {\r\n                colorAttachments: [{\r\n                    clearValue: this.displayConfig.screenBackgroundColor,\r\n                    view: this.screenRenderPass.view,\r\n                    loadOp: \"clear\" as GPULoadOp,\r\n                    storeOp: 'store' as GPUStoreOp\r\n                }],\r\n                depthStencilAttachment: {\r\n                    view: this.screenRenderPass.depthView,\r\n                    depthClearValue: 1.0,\r\n                    depthLoadOp: 'clear' as GPULoadOp,\r\n                    depthStoreOp: 'store' as GPUStoreOp,\r\n                }\r\n            };\r\n            this.wireframeRenderPass.renderState = renderState;\r\n            wireFrameDrawCall(this.wireframeRenderPass);\r\n            this.wireframeRenderPass.renderState = undefined;\r\n        }\r\n\r\n        for (let sliceIndex = 0; sliceIndex < this.displayConfig.totalGroupNum; sliceIndex++) {\r\n            renderState.needClear = true;\r\n            renderState.sliceIndex = sliceIndex;\r\n            renderState.frustumRange = undefined;\r\n            // set new slicegroup offset\r\n            commandEncoder.copyBufferToBuffer(this.sliceBuffers.sliceGroupOffsetBuffer, sliceIndex << 2, this.sliceBuffers.uniformsBuffer, sliceOffsetBufferOffset, 4);\r\n            drawCall(renderState);\r\n            if (renderState.needClear) {\r\n                // if drawCall is empty, we also need to clear texture\r\n                let clearPassEncoder = commandEncoder.beginRenderPass(this.crossRenderPass.descClear);\r\n                clearPassEncoder.setPipeline(this.crossRenderPass.clearRenderPipeline);\r\n                clearPassEncoder.draw(0);\r\n                clearPassEncoder.end();\r\n            }\r\n            const loadOp = (!wireFrameDrawCall) && sliceIndex === 0 ? 'clear' : \"load\" as GPULoadOp;\r\n            let retinaPassEncoder = commandEncoder.beginRenderPass({\r\n                colorAttachments: [{\r\n                    view: this.screenRenderPass.view,\r\n                    clearValue: this.displayConfig.screenBackgroundColor,\r\n                    loadOp,\r\n                    storeOp: 'store' as GPUStoreOp\r\n                }],\r\n\r\n                depthStencilAttachment: {\r\n                    view: this.screenRenderPass.depthView,\r\n                    depthClearValue: 1.0,\r\n                    depthLoadOp: loadOp,\r\n                    depthStoreOp: 'store' as GPUStoreOp,\r\n                }\r\n            });\r\n            retinaPassEncoder.setPipeline(this.retinaRenderPass.pipeline);\r\n            retinaPassEncoder.setBindGroup(0, this.retinaRenderPass.bindgroup);\r\n            if (this.retinaRenderPass.alphaBindgroup) {\r\n                retinaPassEncoder.setBindGroup(1, this.retinaRenderPass.alphaBindgroup);\r\n            }\r\n            let isSectionCount = this.displayConfig.sections.length && sliceIndex >= this.displayConfig.sliceGroupNum;\r\n            let lastCount = isSectionCount ? this.displayConfig.sections.length % this.rendererConfig.sliceGroupSize : 0;\r\n            let count = isSectionCount ? (\r\n                // if is section group\r\n                sliceIndex == this.displayConfig.totalGroupNum - 1 && lastCount ? lastCount : this.rendererConfig.sliceGroupSize\r\n            ) :\r\n                // if is not section group\r\n                this.displayConfig.enableStereo ? (this.rendererConfig.sliceGroupSize << 1) : this.rendererConfig.sliceGroupSize;\r\n            retinaPassEncoder.draw(4, count, 0, 0);\r\n            retinaPassEncoder.end();\r\n        }\r\n\r\n        let screenPassEncoder = commandEncoder.beginRenderPass({\r\n            colorAttachments: [{\r\n                view: canvasView,\r\n                clearValue: this.displayConfig.screenBackgroundColor,\r\n                loadOp: 'clear' as GPULoadOp,\r\n                storeOp: 'store' as GPUStoreOp\r\n            }]\r\n        });\r\n        screenPassEncoder.setPipeline(this.screenRenderPass.pipeline);\r\n        screenPassEncoder.setBindGroup(0, this.screenRenderPass.bindgroup);\r\n        screenPassEncoder.draw(4);\r\n        screenPassEncoder.end();\r\n        gpu.device.queue.submit([commandEncoder.finish()]);\r\n    }\r\n\r\n    async createTetraSlicePipeline(descriptor: TetraSlicePipelineDescriptor): Promise<TetraSlicePipeline> {\r\n        // lazy init buffer here, optimization for only raytracing rendering\r\n        if (!this.tetraBuffers.outputVaryBufferPool.length) this.tetraBuffers.init();\r\n        return await new TetraSlicePipeline().init(this.gpu, this.rendererConfig, descriptor, this.tetraBuffers);\r\n    }\r\n    async createRaytracingPipeline(descriptor: RaytracingPipelineDescriptor): Promise<RaytracingPipeline> {\r\n        return await new RaytracingPipeline().init(this.gpu, this.rendererConfig, descriptor, this.sliceBuffers);\r\n    }\r\n\r\n    /** for TetraSlicePipeline, vertex shader is internally a compute shader, so it doesn't share bindgroups with fragment shader.\r\n     *  for RaytracingPipeline, vertex shader and fragment shader are in one traditional render pipeline, they share bindgroups.\r\n     */\r\n    createVertexShaderBindGroup(pipeline: TetraSlicePipeline | RaytracingPipeline, index: number, buffers: GPUBuffer[], label?: string) {\r\n        if (index === 0) throw \"Unable to create BindGroup 0, which is occupied by internal usages.\";\r\n        return this.gpu.createBindGroup(\r\n            ((pipeline as TetraSlicePipeline).computePipeline ?\r\n                (pipeline as TetraSlicePipeline).computePipeline :\r\n                (pipeline as RaytracingPipeline).pipeline\r\n            ), index, buffers.map(e => ({ buffer: e })), \"VertexShaderBindGroup<\" + label + \">\"\r\n        );\r\n    }\r\n    /** for TetraSlicePipeline, vertex shader is internally a compute shader, so it doesn't share bindgroups with fragment shader.\r\n     *  for RaytracingPipeline, vertex shader and fragment shader are in one traditional render pipeline, they share bindgroups.\r\n     */\r\n    createFragmentShaderBindGroup(pipeline: TetraSlicePipeline | RaytracingPipeline, index: number, buffers: GPUBuffer[], label?: string) {\r\n        if (index === 0 && (pipeline as RaytracingPipeline).pipeline) throw \"Unable to create BindGroup 0, which is occupied by internal usages.\";\r\n        return this.gpu.createBindGroup(\r\n            ((pipeline as TetraSlicePipeline).computePipeline ?\r\n                (pipeline as TetraSlicePipeline).renderPipeline :\r\n                (pipeline as RaytracingPipeline).pipeline\r\n            ), index, buffers.map(e => ({ buffer: e })), \"FragmentShaderBindGroup<\" + label + \">\"\r\n        );\r\n    }\r\n}\r\n\r\n\r\n\r\nexport class RetinaSliceBufferMgr {\r\n\r\n    private queue: GPUQueue;\r\n    private rendererConfig: InternalSliceRendererConfig;\r\n    currentRetinaFacing: RetinaSliceFacing;\r\n    retinaMVMatChanged: boolean = true;\r\n    retinaFacingOrSlicesChanged: boolean = true;\r\n\r\n    uniformsBuffer: GPUBuffer;\r\n    thumbnailViewportBuffer: GPUBuffer;\r\n\r\n    retinaProjectJsBuffer = new Float32Array(16);\r\n    retinaMVMatJsBuffer = new Float32Array(16);\r\n    camProjJsBuffer = new Float32Array(4);\r\n    slicesJsBuffer = new Float32Array(4);\r\n    sliceGroupOffsetBuffer: GPUBuffer;\r\n    emitIndexSliceBuffer: GPUBuffer;\r\n\r\n    constructor(gpu: GPU, config: InternalSliceRendererConfig) {\r\n\r\n        this.emitIndexSliceBuffer = gpu.createBuffer(GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST, (4 << config.sliceGroupSizeBit) + (config.maxSlicesNumber << 4));\r\n\r\n        this.uniformsBuffer = gpu.createBuffer(GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST, uniformsBufferLength);\r\n        this.thumbnailViewportBuffer = gpu.createBuffer(GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST, 1024);\r\n\r\n        this.queue = gpu.device.queue;\r\n\r\n        const maxSliceGroupNum = Math.ceil(config.maxSlicesNumber / config.sliceGroupSize);\r\n        const sliceGroupOffsets = new Uint32Array(maxSliceGroupNum);\r\n        for (let i = 0; i < maxSliceGroupNum; i++) {\r\n            sliceGroupOffsets[i] = i * config.sliceGroupSize;\r\n        }\r\n        this.sliceGroupOffsetBuffer = gpu.createBuffer(GPUBufferUsage.COPY_SRC, sliceGroupOffsets);\r\n        this.rendererConfig = config;\r\n    }\r\n    updateBuffers(sliceGroupNum: number) {\r\n        if (this.retinaMVMatChanged) {\r\n            this.queue.writeBuffer(this.uniformsBuffer, retinaMVBufferOffset, this.retinaMVMatJsBuffer);\r\n            this.retinaMVMatChanged = false;\r\n        }\r\n        if (this.retinaFacingOrSlicesChanged) {\r\n            // refacing buffer stores not only refacing but also retina slices\r\n            this.queue.writeBuffer(this.uniformsBuffer, refacingBufferOffset, new Uint32Array([\r\n                this.currentRetinaFacing | ((sliceGroupNum) << (5 + this.rendererConfig.sliceGroupSizeBit))\r\n            ]));\r\n            this.retinaFacingOrSlicesChanged = false;\r\n        }\r\n    }\r\n    deepCopySectionConfigs(sectionConfigs: SectionConfig[], defaultRetinaResolution?: number) {\r\n        return sectionConfigs.map(e => ({\r\n            eyeStereo: e.eyeStereo ?? EyeStereo.None,\r\n            facing: e.facing,\r\n            slicePos: e.slicePos ?? 0,\r\n            viewport: {\r\n                x: e.viewport.x,\r\n                y: e.viewport.y,\r\n                width: e.viewport.width,\r\n                height: e.viewport.height,\r\n            },\r\n            resolution: e.resolution ?? defaultRetinaResolution\r\n        })) as SectionConfig[];\r\n    }\r\n    setSlicesAndSections(internalDisplayConfig: InternalDisplayConfig, displayConfig: DisplayConfig) {\r\n\r\n        let vpShift = this.rendererConfig.viewportCompressShift;\r\n        let prevRetinaResolution = internalDisplayConfig.retinaResolution;\r\n        if (displayConfig.retinaResolution) internalDisplayConfig.retinaResolution = (displayConfig.retinaResolution >> vpShift) << vpShift;\r\n\r\n        if (displayConfig.sections) {\r\n            // deepcopy\r\n            internalDisplayConfig.sections = this.deepCopySectionConfigs(displayConfig.sections, internalDisplayConfig.retinaResolution);\r\n        }\r\n\r\n        internalDisplayConfig.sections ??= [];\r\n        internalDisplayConfig.retinaLayers = displayConfig.retinaLayers;\r\n        let sections = internalDisplayConfig.sections;\r\n        let sliceStep = 2 / displayConfig.retinaLayers; // slice from -1 to 1\r\n        let sliceGroupNum = Math.ceil(displayConfig.retinaLayers / this.rendererConfig.sliceGroupSize);\r\n        let paddedSliceNum = sliceGroupNum << this.rendererConfig.sliceGroupSizeBit;\r\n        internalDisplayConfig.paddedSliceNum = paddedSliceNum;\r\n        let sectionNum = sections.length ?? 0;\r\n        let sectionGroupNum = Math.ceil(sectionNum / this.rendererConfig.sliceGroupSize);\r\n        let totalNum = paddedSliceNum + (sectionGroupNum << this.rendererConfig.sliceGroupSizeBit);\r\n        let slices = (this.slicesJsBuffer?.length === totalNum << 2) ? this.slicesJsBuffer : new Float32Array(totalNum << 2);\r\n        this.slicesJsBuffer = slices;\r\n        slices.fill(0);// todo : check neccesity?\r\n\r\n        let retinaWidth = internalDisplayConfig.retinaResolution;\r\n        let retinaX = 0, retinaY = 0;\r\n        for (let slice = -1, i = 0, sliceGroupOffset = 0; i < paddedSliceNum; slice += sliceStep, i++, sliceGroupOffset++) {\r\n            if (sliceGroupOffset === this.rendererConfig.sliceGroupSize) {\r\n                // start a new slice group\r\n                sliceGroupOffset = 0;\r\n                retinaX = 0;\r\n                retinaY = 0;\r\n            }\r\n            slices[(i << 2)] = slice; // slice pos. if slice > 1, discard in shader\r\n            slices[(i << 2) + 1] = 0; // leave 0 for retina slice (used only in cross section)\r\n            slices[(i << 2) + 2] = 0; // leave 0 for retina slice (used only in cross section)\r\n            let wshift = retinaWidth >> vpShift;\r\n            // a compressed viewport infomation\r\n            slices[(i << 2) + 3] = u32_to_f32(((retinaX >> vpShift) << 24) + ((retinaY >> vpShift) << 16) + (wshift << 8) + wshift);\r\n            if (retinaX + retinaWidth > this.rendererConfig.sliceTextureWidth ||\r\n                retinaY + retinaWidth > this.rendererConfig.sliceTextureHeight) {\r\n                this.setSlicesAndSections(internalDisplayConfig, { retinaResolution: prevRetinaResolution });\r\n                console.warn(\"Maximum retinaResolution reached\");\r\n                return;\r\n            }\r\n            retinaY += retinaWidth;\r\n            if (retinaY + retinaWidth > this.rendererConfig.sliceTextureHeight) {\r\n                retinaX += retinaWidth;\r\n                retinaY = 0;\r\n            }\r\n        }\r\n\r\n        internalDisplayConfig.sliceGroupNum = sliceGroupNum;\r\n        internalDisplayConfig.totalGroupNum = sliceGroupNum + sectionGroupNum;\r\n        if (sectionNum) {\r\n            let thumbnailViewportJsBuffer = new Float32Array(4 * 16);\r\n            let lastGroupPosition = sectionGroupNum - 1 << this.rendererConfig.sliceGroupSizeBit;\r\n            let lastGroupSlices = sections.length - lastGroupPosition;\r\n            // get max resolution widths per slice group\r\n\r\n            let deltaX = [];\r\n            let maxDx = 0;\r\n            for (let j = 0, sliceGroupOffset = 0, l = sections.length; j < l; j++, sliceGroupOffset++) {\r\n                let config = sections[j];\r\n                if (sliceGroupOffset === this.rendererConfig.sliceGroupSize) {\r\n                    sliceGroupOffset = 0;\r\n                    deltaX.push((maxDx >> vpShift) << vpShift);\r\n                    maxDx = 0;\r\n                }\r\n                maxDx = Math.max(maxDx, Math.ceil(config.resolution / config.viewport.height * config.viewport.width));\r\n            }\r\n            deltaX.push((maxDx >> 4) << 4);\r\n            retinaX = 0;\r\n            retinaY = 0;\r\n            let sliceGroup = 0;\r\n            for (let i = paddedSliceNum, j = 0, sliceGroupOffset = 0; i < totalNum; i++, j++, sliceGroupOffset++) {\r\n                let config = sections[j];\r\n                slices[(i << 2)] = config?.slicePos ?? 0;\r\n                slices[(i << 2) + 1] = u32_to_f32(((config?.facing) ?? 0) | ((config?.eyeStereo ?? 1) << 3));\r\n                slices[(i << 2) + 2] = u32_to_f32(j < lastGroupPosition ? this.rendererConfig.sliceGroupSize : lastGroupSlices);\r\n                if (config) {\r\n                    if (sliceGroupOffset === this.rendererConfig.sliceGroupSize) {\r\n                        retinaX = 0;\r\n                        retinaY = 0;\r\n                        sliceGroupOffset = 0;\r\n                        sliceGroup++;\r\n                    } else if (retinaY + config.resolution > this.rendererConfig.sliceTextureHeight) {\r\n                        retinaX += deltaX[sliceGroup];\r\n                        retinaY = 0;\r\n                    }\r\n\r\n                    let wshift = Math.ceil(config.resolution / config.viewport.height * config.viewport.width) >> vpShift;\r\n                    let hshift = config.resolution >> vpShift;\r\n                    slices[(i << 2) + 3] = u32_to_f32(\r\n                        (((retinaX >> vpShift)) << 24) + ((retinaY >> vpShift) << 16) + (wshift << 8) + hshift\r\n                    );\r\n                    thumbnailViewportJsBuffer[j << 2] = config.viewport.x;\r\n                    thumbnailViewportJsBuffer[(j << 2) + 1] = config.viewport.y;\r\n                    thumbnailViewportJsBuffer[(j << 2) + 2] = config.viewport.width;\r\n                    thumbnailViewportJsBuffer[(j << 2) + 3] = config.viewport.height;\r\n\r\n                    retinaY += (config.resolution >> vpShift) << vpShift;\r\n                }\r\n            }\r\n            this.queue.writeBuffer(this.thumbnailViewportBuffer, 0, thumbnailViewportJsBuffer);\r\n        }\r\n        this.queue.writeBuffer(this.emitIndexSliceBuffer, 0, slices);\r\n        this.retinaFacingOrSlicesChanged = true;\r\n    }\r\n    setRetinaProjectMatrix(camera: PerspectiveCamera | OrthographicCamera) {\r\n        if ((camera as PerspectiveCamera).fov) {\r\n            getPerspectiveProjectionMatrix(camera as PerspectiveCamera).mat4.writeBuffer(this.retinaProjectJsBuffer);\r\n        } else {\r\n            getOrthographicProjectionMatrix(camera as OrthographicCamera).mat4.writeBuffer(this.retinaProjectJsBuffer);\r\n        }\r\n        this.queue.writeBuffer(this.uniformsBuffer, retinaProjectBufferOffset, this.retinaProjectJsBuffer);\r\n    }\r\n    setRetinaViewMatrix(m: Mat4) {\r\n        let e = m.elem;\r\n        let facing = this.getFacing(e[8], e[9], e[10]);\r\n        if (facing !== this.currentRetinaFacing) {\r\n            this.retinaFacingOrSlicesChanged = true;\r\n            this.currentRetinaFacing = facing;\r\n        }\r\n        m.writeBuffer(this.retinaMVMatJsBuffer);\r\n        this.retinaMVMatChanged = true;\r\n    }\r\n    getRetinaCamera(): PerspectiveCamera | OrthographicCamera {\r\n        let c = this.retinaProjectJsBuffer;\r\n        let near = c[3] / c[2];\r\n        if (c[0] > 0) {\r\n            return {\r\n                fov: Math.atan(1 / c[1]) * _RAD2DEG * 2,\r\n                aspect: c[1] / c[0],\r\n                near,\r\n                far: c[2] * near / (1 + c[2])\r\n            };\r\n        } else {\r\n            return {\r\n                size: 1 / c[1],\r\n                aspect: - c[1] / c[0],\r\n                near,\r\n                far: near - 1.0 / c[2]\r\n            };\r\n        }\r\n    }\r\n    setCameraProjectMatrix(camera: PerspectiveCamera | OrthographicCamera) {\r\n        if ((camera as PerspectiveCamera).fov) {\r\n            getPerspectiveProjectionMatrix(camera as PerspectiveCamera).vec4.writeBuffer(this.camProjJsBuffer);\r\n        } else {\r\n            getOrthographicProjectionMatrix(camera as OrthographicCamera).vec4.writeBuffer(this.camProjJsBuffer);\r\n            this.camProjJsBuffer[0] = -this.camProjJsBuffer[0]; // use negative to mark Orthographic in shader\r\n        }\r\n        this.queue.writeBuffer(this.uniformsBuffer, camProjBufferOffset, this.camProjJsBuffer);\r\n    }\r\n    getFacing(x: number, y: number, z: number) {\r\n        let xa = Math.abs(x);\r\n        let ya = Math.abs(y);\r\n        let za = Math.abs(z);\r\n        switch (za > ya ? za > xa ? 2 : 0 : ya > xa ? 1 : 0) {\r\n            case 0:\r\n                return x > 0 ? RetinaSliceFacing.POSX : RetinaSliceFacing.NEGX;\r\n            case 1:\r\n                return y > 0 ? RetinaSliceFacing.POSY : RetinaSliceFacing.NEGY;\r\n            default:\r\n                return z > 0 ? RetinaSliceFacing.POSZ : RetinaSliceFacing.NEGZ;\r\n        }\r\n    }\r\n}\r\nclass CrossRenderPass {\r\n    descClear: GPURenderPassDescriptor;\r\n    descLoad: GPURenderPassDescriptor;\r\n    clearRenderPipelinePromise: Promise<GPURenderPipeline>;\r\n    clearRenderPipeline: GPURenderPipeline;\r\n    sliceTextureSize: { width: number, height: number };\r\n    sliceView: GPUTextureView;\r\n    constructor(gpu: GPU) {\r\n        // sliceTexture covered by sliceGroupSize x 2 atlas of sliceResolution x sliceResolution\r\n        let maxTextureSize = gpu.device.limits.maxTextureDimension2D;\r\n        let sliceTextureSize = { width: maxTextureSize >> 1, height: maxTextureSize };\r\n        this.sliceTextureSize = sliceTextureSize;\r\n        let sliceTexture = gpu.device.createTexture({\r\n            size: sliceTextureSize, format: gpu.preferredFormat,\r\n            usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING,\r\n        });\r\n        this.sliceView = sliceTexture.createView();\r\n\r\n        let depthTexture = gpu.device.createTexture({\r\n            size: sliceTextureSize, format: 'depth24plus',\r\n            usage: GPUTextureUsage.RENDER_ATTACHMENT,\r\n        });\r\n        let depthView = depthTexture.createView();\r\n        this.descClear = {\r\n            colorAttachments: [{\r\n                view: this.sliceView,\r\n                clearValue: { r: 0, g: 0, b: 0, a: 0.0 },\r\n                loadOp: 'clear' as GPULoadOp,\r\n                storeOp: 'store' as GPUStoreOp\r\n            }],\r\n            depthStencilAttachment: {\r\n                view: depthView,\r\n                depthClearValue: 1.0,\r\n                depthLoadOp: 'clear' as GPULoadOp,\r\n                depthStoreOp: 'store' as GPUStoreOp,\r\n            }\r\n        };\r\n\r\n        this.descLoad = {\r\n            colorAttachments: [{\r\n                view: this.sliceView,\r\n                loadOp: 'load' as GPULoadOp,\r\n                storeOp: 'store' as GPUStoreOp\r\n            }],\r\n            depthStencilAttachment: {\r\n                view: depthView,\r\n                depthLoadOp: 'load' as GPULoadOp,\r\n                depthStoreOp: 'store' as GPUStoreOp,\r\n            }\r\n        };\r\n        let clearModule = gpu.device.createShaderModule({\r\n            code:\r\n                \"@vertex fn v()->@builtin(position) vec4f{ return vec4f();} @fragment fn f()->@location(0) vec4f{ return vec4f();}\"\r\n        });\r\n        this.clearRenderPipelinePromise = gpu.device.createRenderPipelineAsync({\r\n            layout: 'auto',\r\n            vertex: {\r\n                module: clearModule,\r\n                entryPoint: 'v',\r\n            },\r\n            fragment: {\r\n                module: clearModule,\r\n                entryPoint: 'f',\r\n                targets: [{ format: gpu.preferredFormat }]\r\n            },\r\n            depthStencil: {\r\n                format: 'depth24plus',\r\n                depthCompare: 'less',\r\n                depthWriteEnabled: true\r\n            }\r\n        });\r\n    }\r\n    async init() {\r\n        this.clearRenderPipeline = await this.clearRenderPipelinePromise;\r\n    }\r\n}\r\nconst outputAttributeUsage = typeof GPUBufferUsage === 'undefined' ? null : GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST | GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX;\r\n\r\nexport class TetraSliceBufferMgr {\r\n    maxCrossSectionBufferSize: number;\r\n    gpu: GPU;\r\n    outputVaryBufferPool: Array<GPUBuffer> = []; // all the vary buffers for pipelines\r\n    private indicesInOutputBufferPool: Set<number>;\r\n    buffers: { buffer: GPUBuffer }[];\r\n    // outputVaryBuffer: GPUBuffer[];\r\n    constructor(gpu: GPU, config: InternalSliceRendererConfig, sliceBuffers: RetinaSliceBufferMgr) {\r\n        this.buffers = [\r\n            { buffer: sliceBuffers.emitIndexSliceBuffer },\r\n            { buffer: sliceBuffers.uniformsBuffer },\r\n            { buffer: sliceBuffers.thumbnailViewportBuffer },\r\n        ];\r\n        this.gpu = gpu;\r\n        this.maxCrossSectionBufferSize = config.maxCrossSectionBufferSize;\r\n    }\r\n    init() {\r\n        // lazy init buffer in creeating first tetraslice pipeline, optimization for only raytracing rendering\r\n        this.outputVaryBufferPool.push(this.gpu.createBuffer(outputAttributeUsage, this.maxCrossSectionBufferSize, \"Output buffer for builtin(position)\"));\r\n    }\r\n    prepareNewPipeline() {\r\n        this.indicesInOutputBufferPool = new Set;\r\n        this.indicesInOutputBufferPool.add(0); // default builtin(position) buffer\r\n        return [this.outputVaryBufferPool[0]];\r\n    }\r\n    destroy() {\r\n        for (const buffer of this.outputVaryBufferPool) {\r\n            buffer.destroy();\r\n        }\r\n    }\r\n    ////// caution: data race here\r\n    requireOutputBuffer(id: number, size: number, outBuffers: GPUBuffer[]): GPUBuffer {\r\n        if (id === 0) return this.outputVaryBufferPool[0];\r\n        let expectedSize = this.maxCrossSectionBufferSize * size;\r\n        for (let i = 0; i < this.outputVaryBufferPool.length; i++) {\r\n            if (this.indicesInOutputBufferPool.has(i)) continue; // we can't bind the same buffer again\r\n            let buffer = this.outputVaryBufferPool[i];\r\n            if (buffer.size === expectedSize) {\r\n                // found unused exactly sized buffer\r\n                this.indicesInOutputBufferPool.add(i);\r\n                outBuffers.push(buffer);\r\n                return buffer;\r\n            }\r\n        }\r\n        // no buffer found, we need to create\r\n        let buffer = this.gpu.createBuffer(outputAttributeUsage, expectedSize, \"Output buffer for \" + size + \" vec4(s)\");\r\n        this.indicesInOutputBufferPool.add(this.outputVaryBufferPool.length);\r\n        this.outputVaryBufferPool.push(buffer);\r\n        outBuffers.push(buffer);\r\n        return buffer;\r\n    }\r\n}\r\nclass RetinaRenderPass implements IRetinaRenderPass {\r\n    pipeline: GPURenderPipeline;\r\n    pipelinePromise: Promise<GPURenderPipeline>;\r\n    bindgroup: GPUBindGroup;\r\n    alphaBindgroup: GPUBindGroup;\r\n    crossRenderPass: CrossRenderPass;\r\n    readonly __brand: \"RetinaRenderPass\";\r\n    private gpu: GPU;\r\n    private config: InternalSliceRendererConfig;\r\n    private sliceBuffers: RetinaSliceBufferMgr;\r\n    descriptor: RetinaRenderPassDescriptor\r\n\r\n    constructor(gpu: GPU, config: InternalSliceRendererConfig, sliceBuffers: RetinaSliceBufferMgr, crossRenderPass: CrossRenderPass, descriptor?: RetinaRenderPassDescriptor) {\r\n        this.gpu = gpu;\r\n        this.config = config;\r\n        this.descriptor = descriptor ?? {};\r\n        this.sliceBuffers = sliceBuffers;\r\n        this.crossRenderPass = crossRenderPass;\r\n        let retinaRenderCode = refacingMatsCode + StructDefSliceInfo + StructDefUniformBuffer + `\r\nstruct tsxvOutputType{\r\n    @builtin(position) position : vec4f,\r\n    @location(0) relativeFragPosition : vec3<f32>,\r\n    @location(1) crossHair : f32,\r\n    @location(2) rayForCalOpacity : vec4f,\r\n    @location(3) retinaCoord : vec3<f32>,\r\n    @location(4) normalForCalOpacity : vec4f,\r\n}\r\nstruct tsxfInputType{\r\n    @location(0) relativeFragPosition : vec3<f32>,\r\n    @location(1) crossHair : f32,\r\n    @location(2) rayForCalOpacity : vec4f,\r\n    @location(3) retinaCoord : vec3<f32>,\r\n    @location(4) normalForCalOpacity : vec4f,\r\n}\r\n@group(0) @binding(0) var<storage,read> slice : array<tsxSliceInfo,${this.config.maxSlicesNumber}>;\r\n@group(0) @binding(1) var<uniform> tsx_uniforms : tsxUniformBuffer;\r\n@group(0) @binding(2) var<uniform> thumbnailViewport : array<vec4f,16>;\r\n\r\n@vertex fn mainVertex(@builtin(vertex_index) vindex : u32, @builtin(instance_index) iindex : u32) -> tsxvOutputType {\r\n    const pos = array<vec2<f32>, 4>(\r\n        vec2<f32>(-1.0, -1.0),\r\n        vec2<f32>(-1.0, 1.0),\r\n        vec2<f32>( 1.0, -1.0),\r\n        vec2<f32>( 1.0, 1.0),\r\n    );\r\n    var sindex = iindex;\r\n    var pos2d = pos[vindex];\r\n    let stereoLR = f32(iindex & 1) - 0.5;\r\n    if (slice[tsx_uniforms.sliceOffset].flag == 0 && tsx_uniforms.eyeCross.y != 0.0){\r\n        sindex = iindex >> 1;\r\n    }\r\n    let s = slice[sindex + tsx_uniforms.sliceOffset];\r\n    // let coord = vec2<f32>(pos2d.x, -pos2d.y) * 0.5 + 0.5;\r\n    let ray = vec4f(pos2d, s.slicePos, 1.0);\r\n    var retinaCoord: vec4f;\r\n    var glPosition: vec4f;\r\n    var camRay: vec4f;\r\n    var normal: vec4f;\r\n    let x = f32(((s.viewport >> 24) & 0xFF) << ${this.config.viewportCompressShift}) * ${1 / this.config.sliceTextureWidth};\r\n    let y = f32(((s.viewport >> 16) & 0xFF) << ${this.config.viewportCompressShift}) * ${1 / this.config.sliceTextureHeight};\r\n    let w = f32(((s.viewport >> 8 ) & 0xFF) << ${this.config.viewportCompressShift}) * ${1 / this.config.sliceTextureWidth};\r\n    let h = f32((s.viewport & 0xFF) << ${this.config.viewportCompressShift}) * ${1 / this.config.sliceTextureHeight};\r\n    var crossHair : f32;\r\n    if (slice[tsx_uniforms.sliceOffset].flag == 0){\r\n        crossHair = 0.0;\r\n        let stereoLR_offset = -stereoLR * tsx_uniforms.eyeCross.y;\r\n        let se = sin(stereoLR_offset);\r\n        let ce = cos(stereoLR_offset);\r\n        var pureRotationMvMat = tsx_uniforms.retinaMV;\r\n        pureRotationMvMat[3].z = 0.0;\r\n        let eyeMat = mat4x4f(\r\n            ce,0,se,0,\r\n            0,1,0,0,\r\n            -se,0,ce,0,\r\n            0,0,tsx_uniforms.retinaMV[3].z,1\r\n        );\r\n        let omat = eyeMat * pureRotationMvMat * tsx_refacingMats[tsx_uniforms.refacing & 7];\r\n        camRay = omat * ray;\r\n        retinaCoord = tsx_refacingMats[tsx_uniforms.refacing & 7] * ray;\r\n        glPosition = tsx_uniforms.retinaP * camRay;\r\n        if(tsx_uniforms.retinaP[3].w > 0){ // Orthographic\r\n            camRay = vec4f(0.0,0.0,-1.0,1.0);\r\n        }\r\n        normal = omat[2];\r\n        // todo: viewport of retina slices\r\n        glPosition.x = (glPosition.x) * tsx_uniforms.screenAspect + step(0.0001, abs(tsx_uniforms.eyeCross.y)) * stereoLR * glPosition.w;\r\n    }else{\r\n        let vp = thumbnailViewport[sindex + tsx_uniforms.sliceOffset - (tsx_uniforms.refacing >> 5)];\r\n        crossHair = tsx_uniforms.eyeCross.z / vp.w * step(abs(s.slicePos),0.1);\r\n        glPosition = vec4f(ray.x * vp.z * tsx_uniforms.screenAspect + vp.x, ray.y * vp.w + vp.y,0.5,1.0);\r\n        camRay = vec4f(pos[vindex].x * vp.z / vp.w,pos[vindex].y,0.0,1.0); // for rendering crosshair\r\n    }\r\n    \r\n    let texelCoord = array<vec2<f32>, 4>(\r\n        vec2<f32>(x, y+h),\r\n        vec2<f32>(x, y),\r\n        vec2<f32>( x+w, y+h),\r\n        vec2<f32>( x+w, y),\r\n    );\r\n    return tsxvOutputType(\r\n        glPosition,\r\n        vec3<f32>(texelCoord[vindex], s.slicePos),\r\n        crossHair,\r\n        camRay,\r\n        retinaCoord.xyz,\r\n        normal\r\n    );\r\n}\r\n\r\n@group(0) @binding(3) var tsx_txt: texture_2d<f32>;\r\n@group(0) @binding(4) var tsx_splr: sampler;\r\n${descriptor?.alphaShader?.code ?? `\r\nfn mainAlpha(color: vec4f, retinaCoord: vec3<f32>) -> f32{\r\n    return color.a;\r\n}\r\n`}\r\n@fragment fn mainFragment(input : tsxfInputType) -> @location(0) vec4f {\r\n    let color = textureSample(tsx_txt, tsx_splr, input.relativeFragPosition.xy);\r\n    var alpha: f32 = 1.0;\r\n    var factor = 0.0;\r\n    if (slice[tsx_uniforms.sliceOffset].flag == 0){\r\n        let dotvalue = dot(normalize(input.rayForCalOpacity.xyz), input.normalForCalOpacity.xyz);\r\n        let factor = tsx_uniforms.layerOpacity / (clamp(-dotvalue,0.0,1.0));\r\n        alpha = clamp(${descriptor?.alphaShader?.entryPoint ?? \"mainAlpha\"}(color, input.retinaCoord) * factor,0.0,1.0);\r\n    }else if (input.crossHair > 0.0) {\r\n    let cross = abs(input.rayForCalOpacity.xy);\r\n    factor = step(cross.x, input.crossHair * 0.05) + step(cross.y, input.crossHair * 0.05);\r\n    factor *= step(cross.x, input.crossHair) * step(cross.y, input.crossHair);\r\n}\r\nreturn vec4f(mix(color.rgb, vec3<f32>(1.0) - color.rgb, clamp(factor, 0.0, 1.0)), alpha);\r\n}\r\n`;\r\n        const retinaRenderShaderModule = gpu.device.createShaderModule({\r\n            code: retinaRenderCode\r\n        });\r\n        this.pipelinePromise = gpu.device.createRenderPipelineAsync({\r\n            layout: 'auto',\r\n            vertex: {\r\n                module: retinaRenderShaderModule,\r\n                entryPoint: 'mainVertex',\r\n            },\r\n            fragment: {\r\n                module: retinaRenderShaderModule,\r\n                entryPoint: 'mainFragment',\r\n                targets: [{\r\n                    format: this.config.enableFloat16Blend ? 'rgba16float' : this.gpu.preferredFormat,\r\n                    blend: {\r\n                        color: {\r\n                            srcFactor: \"src-alpha\" as GPUBlendFactor,\r\n                            dstFactor: \"one-minus-src-alpha\" as GPUBlendFactor,\r\n                            operation: \"add\" as GPUBlendOperation\r\n                        },\r\n                        alpha: {}\r\n                    }\r\n                }],\r\n            },\r\n            depthStencil: {\r\n                depthWriteEnabled: true,\r\n                depthCompare: 'less',\r\n                format: 'depth24plus',\r\n            },\r\n            primitive: { topology: 'triangle-strip' }\r\n        });\r\n    }\r\n    async init() {\r\n        this.pipeline = await this.pipelinePromise;\r\n        this.bindgroup = this.gpu.createBindGroup(this.pipeline, 0, [\r\n            { buffer: this.sliceBuffers.emitIndexSliceBuffer },\r\n            { buffer: this.sliceBuffers.uniformsBuffer },\r\n            { buffer: this.sliceBuffers.thumbnailViewportBuffer },\r\n            this.crossRenderPass.sliceView,\r\n            linearTextureSampler,\r\n        ], \"retinaBindGroup\");\r\n        if (this.descriptor.alphaShaderBindingResources) {\r\n            this.alphaBindgroup = this.gpu.createBindGroup(\r\n                this.pipeline, 1, this.descriptor.alphaShaderBindingResources, \"retinaAlphaBindGroup\"\r\n            );\r\n        }\r\n        return this;\r\n    }\r\n}\r\n/** \r\n * ---------------------------------\r\n * screen render pass\r\n * for float16 blending and convert color to srgb\r\n * ---------------------------------\r\n *  */\r\nconst screenRenderCode = StructDefUniformBuffer + `\r\n@group(0) @binding(0) var tsx_txt: texture_2d<f32>;\r\n@group(0) @binding(1) var tsx_splr: sampler;\r\n@group(0) @binding(2) var<uniform>tsx_uniforms : tsxUniformBuffer;\r\nstruct tsxvOutputType{\r\n    @builtin(position) position: vec4f,\r\n    @location(0) fragPosition: vec2<f32>,\r\n}\r\nstruct tsxfInputType{\r\n    @location(0) fragPosition: vec2<f32>,\r\n}\r\n@vertex fn mainVertex(@builtin(vertex_index) index : u32) -> tsxvOutputType {\r\n    const pos = array<vec2<f32>, 4>(\r\n        vec2<f32>(-1.0, -1.0),\r\n        vec2<f32>(-1.0, 1.0),\r\n        vec2<f32>(1.0, -1.0),\r\n        vec2<f32>(1.0, 1.0),\r\n    );\r\n    const uv = array<vec2<f32>, 4>(\r\n        vec2<f32>(0.0, 1.0),\r\n        vec2<f32>(0.0, 0.0),\r\n        vec2<f32>(1.0, 1.0),\r\n        vec2<f32>(1.0, 0.0),\r\n    );\r\n    return tsxvOutputType(vec4f(pos[index], 0.0, 1.0), uv[index]);\r\n}\r\n@fragment fn mainFragment(input: tsxfInputType) -> @location(0) vec4 < f32 > {\r\nlet color = textureSample(tsx_txt, tsx_splr, input.fragPosition);\r\nvar factor = 0.0;\r\nif(tsx_uniforms.eyeCross.z > 0.0 && tsx_uniforms.layerOpacity > 0.0){\r\n    let aspectedCross = tsx_uniforms.eyeCross.z * tsx_uniforms.screenAspect;\r\n    if (tsx_uniforms.eyeCross.x != 0.0) {\r\n        let cross1 = abs(input.fragPosition - vec2<f32>(0.25, 0.5)) * 2.0;\r\n        let cross2 = abs(input.fragPosition - vec2<f32>(0.75, 0.5)) * 2.0;\r\n        factor = step(cross1.x, 0.05 * aspectedCross) + step(cross2.x, 0.05 * aspectedCross) + step(cross1.y, tsx_uniforms.eyeCross.z * 0.05);\r\n        factor *= step(cross1.y, tsx_uniforms.eyeCross.z) * (step(cross1.x, aspectedCross) + step(cross2.x, aspectedCross));\r\n    } else {\r\n        let cross = abs(input.fragPosition - vec2<f32>(0.5, 0.5)) * 2.0;\r\n        factor = step(cross.x, 0.05 * aspectedCross) + step(cross.y, tsx_uniforms.eyeCross.z * 0.05);\r\n        factor *= step(cross.y, tsx_uniforms.eyeCross.z) * step(cross.x, aspectedCross);\r\n    }\r\n}\r\nreturn vec4f(mix(color.rgb, vec3<f32>(1.0) - color.rgb, clamp(factor, 0.0, 1.0)), 1.0);\r\n}\r\n`;\r\nclass ScreenRenderPass {\r\n    view: GPUTextureView;\r\n    depthView: GPUTextureView;\r\n    pipeline: GPURenderPipeline;\r\n    pipelinePromise: Promise<GPURenderPipeline>;\r\n    bindgroup: GPUBindGroup;\r\n    texture: GPUTexture;\r\n    depthTexture: GPUTexture;\r\n    private gpu: GPU;\r\n    private config: InternalSliceRendererConfig;\r\n    private sliceBuffers: RetinaSliceBufferMgr;\r\n    constructor(gpu: GPU, config: InternalSliceRendererConfig, sliceBuffers: RetinaSliceBufferMgr) {\r\n        this.gpu = gpu;\r\n        this.config = config;\r\n        this.sliceBuffers = sliceBuffers;\r\n        let screenRenderShaderModule = gpu.device.createShaderModule({\r\n            code: screenRenderCode\r\n        });\r\n        this.pipelinePromise = gpu.device.createRenderPipelineAsync({\r\n            layout: 'auto',\r\n            vertex: {\r\n                module: screenRenderShaderModule,\r\n                entryPoint: 'mainVertex',\r\n            },\r\n            fragment: {\r\n                module: screenRenderShaderModule,\r\n                entryPoint: 'mainFragment',\r\n                targets: [{\r\n                    format: gpu.preferredFormat\r\n                }],\r\n            },\r\n            primitive: { topology: 'triangle-strip' }\r\n        });\r\n    }\r\n    setSize(size: GPUExtent3DStrict) {\r\n        if (this.texture) this.texture.destroy();\r\n        if (this.depthTexture) this.depthTexture.destroy();\r\n\r\n        // if (!this.pipeline) throw \"TetraSliceRenderer: ScreenRenderPipeline is not initialized.\";\r\n        this.texture = this.gpu.device.createTexture({\r\n            size, format: this.config.enableFloat16Blend ? 'rgba16float' : this.gpu.preferredFormat,\r\n            usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING,\r\n        });\r\n        this.depthTexture = this.gpu.device.createTexture({\r\n            size, format: 'depth24plus',\r\n            usage: GPUTextureUsage.RENDER_ATTACHMENT,\r\n        });\r\n        this.view = this.texture.createView();\r\n        this.depthView = this.depthTexture.createView();\r\n\r\n        if (this.pipeline) {\r\n            this.bindgroup = this.gpu.createBindGroup(this.pipeline, 0, [\r\n                this.view,\r\n                linearTextureSampler,\r\n                { buffer: this.sliceBuffers.uniformsBuffer },\r\n            ], \"screenBindGroup\");\r\n        }\r\n        let aspect: number;\r\n        if ((size as GPUExtent3DDict).height) {\r\n            aspect = (size as GPUExtent3DDict).height / (size as GPUExtent3DDict).width;\r\n        } else {\r\n            aspect = size[1] / size[0];\r\n        }\r\n        this.gpu.device.queue.writeBuffer(this.sliceBuffers.uniformsBuffer, screenAspectBufferOffset, new Float32Array([aspect]));\r\n    }\r\n    async init() {\r\n        this.pipeline = await this.pipelinePromise;\r\n        this.bindgroup = this.gpu.createBindGroup(this.pipeline, 0, [\r\n            this.view,\r\n            linearTextureSampler,\r\n            { buffer: this.sliceBuffers.uniformsBuffer },\r\n        ], \"screenBindGroup\");\r\n    }\r\n}\r\nconst _vec4 = new Vec4;\r\nconst _vec42 = new Vec4;\r\n\r\nexport class WireFrameRenderPass {\r\n    private pipeline: GPURenderPipeline;\r\n    private pipelinePromise: Promise<GPURenderPipeline>;\r\n    dataBuffer: GPUBuffer;\r\n    private bindGroup: GPUBindGroup;\r\n    gpu: GPU;\r\n    private config: InternalSliceRendererConfig;\r\n    renderState: RenderState;\r\n    renderPassDesc: GPURenderPassDescriptor;\r\n    constructor(gpu: GPU, config: InternalSliceRendererConfig) {\r\n        this.gpu = gpu;\r\n        this.config = config;\r\n        const shaderModule = gpu.device.createShaderModule({\r\n            code: StructDefUniformBuffer + `\r\n@group(0) @binding(0) var<uniform> tsx_uniforms : tsxUniformBuffer;\r\n@vertex fn tsxVMain(@location(0) inPos: vec4f, @builtin(instance_index) idx: u32) -> @builtin(position) vec4f{\r\n    let stereoLR = f32(idx & 1) - 0.5;\r\n    let stereoLR_offset = -stereoLR * tsx_uniforms.eyeCross.y;\r\n    let se = sin(stereoLR_offset);\r\n    let ce = cos(stereoLR_offset);\r\n    var pureRotationMvMat = tsx_uniforms.retinaMV;\r\n    pureRotationMvMat[3].z = 0.0;\r\n    let eyeMat = mat4x4f(\r\n        ce,0,se,0,\r\n        0,1,0,0,\r\n        -se,0,ce,0,\r\n        0,0,tsx_uniforms.retinaMV[3].z,1\r\n    );\r\n    var glPosition = tsx_uniforms.retinaP * eyeMat * pureRotationMvMat * vec4(inPos.xyz, 1.0);\r\n    glPosition.x = (glPosition.x) * tsx_uniforms.screenAspect + step(0.0001, abs(tsx_uniforms.eyeCross.y)) * stereoLR * glPosition.w;\r\n    return glPosition;\r\n}\r\n@fragment fn tsxFMain()->@location(0) vec4f{\r\n    return vec4f(1.0,0.0,0.0,1.0);\r\n}`,\r\n        });\r\n        this.pipelinePromise = gpu.device.createRenderPipelineAsync({\r\n            layout: 'auto',\r\n            vertex: {\r\n                module: shaderModule,\r\n                entryPoint: \"tsxVMain\",\r\n                buffers: [\r\n                    {\r\n                        attributes: [\r\n                            {\r\n                                shaderLocation: 0,\r\n                                offset: 0,\r\n                                format: \"float32x4\",\r\n                            }\r\n                        ],\r\n                        arrayStride: 4 * 4,\r\n                    }\r\n                ]\r\n            },\r\n            primitive: {\r\n                topology: \"line-list\"\r\n            },\r\n            fragment: {\r\n                targets: [\r\n                    { format: this.config.enableFloat16Blend ? 'rgba16float' : this.gpu.preferredFormat },\r\n                ],\r\n                module: shaderModule,\r\n                entryPoint: \"tsxFMain\"\r\n            },\r\n            depthStencil: {\r\n                depthWriteEnabled: true,\r\n                depthCompare: 'less',\r\n                format: 'depth24plus',\r\n            }\r\n        });\r\n\r\n    }\r\n    async init() {\r\n        this.pipeline = await this.pipelinePromise;\r\n    }\r\n    render(buffer: GPUBuffer, vertices: number) {\r\n        if (!this.pipeline) return;\r\n        this.bindGroup ??= this.gpu.createBindGroup(this.pipeline, 0, [{\r\n            buffer: this.renderState.sliceBuffers.uniformsBuffer\r\n        }]);\r\n        const renderPassEncoder = this.renderState.commandEncoder.beginRenderPass(this.renderPassDesc);\r\n        renderPassEncoder.setPipeline(this.pipeline);\r\n        renderPassEncoder.setVertexBuffer(0, buffer);\r\n        renderPassEncoder.setBindGroup(0, this.bindGroup);\r\n        // todo: deal with no retina voxel / non stero mode\r\n        renderPassEncoder.draw(vertices, 2);\r\n        renderPassEncoder.end();\r\n    }\r\n}\r\n\r\nclass RenderState {\r\n    commandEncoder: GPUCommandEncoder;\r\n    computePassEncoder: GPUComputePassEncoder;\r\n    pipeline: TetraSlicePipeline;\r\n    tetraSliceBufferMgr: TetraSliceBufferMgr;\r\n    config: InternalSliceRendererConfig;\r\n    // slicePassEncoder: GPURenderPassEncoder;\r\n    sliceIndex: number;\r\n    needClear: boolean;\r\n    tetraBuffers: TetraSliceBufferMgr;\r\n    sliceBuffers: RetinaSliceBufferMgr;\r\n    crossRenderPass: CrossRenderPass;\r\n    frustumRange: Vec4[];\r\n    constructor(gpu: GPU, config: InternalSliceRendererConfig, sliceBuffers: RetinaSliceBufferMgr, tetraBuffers: TetraSliceBufferMgr, crossRenderPass: CrossRenderPass) {\r\n        this.commandEncoder = gpu.device.createCommandEncoder();\r\n        this.tetraBuffers = tetraBuffers;\r\n        this.sliceBuffers = sliceBuffers;\r\n        this.crossRenderPass = crossRenderPass;\r\n        this.config = config;\r\n    }\r\n    /** Set TetraSlicePipeline and prepare GPU resources.\r\n     *  Next calls should be function sliceTetras or setBindGroup.\r\n     */\r\n    beginTetras(pipeline: TetraSlicePipeline) {\r\n        // let { commandEncoder, sliceIndex, needClear } = this.renderState;\r\n        // clear triagle slice vertex output pointer to zero (emitIndex part)\r\n        this.commandEncoder.clearBuffer(this.sliceBuffers.emitIndexSliceBuffer, this.config.maxSlicesNumber << 4, 4 << this.config.sliceGroupSizeBit);\r\n        // clear triagle slice vertex output data to zero\r\n        this.commandEncoder.clearBuffer(pipeline.outputVaryBuffer[0]);\r\n        this.computePassEncoder = this.commandEncoder.beginComputePass();\r\n        this.computePassEncoder.setPipeline(pipeline.computePipeline);\r\n        this.computePassEncoder.setBindGroup(0, pipeline.computeBindGroup0);\r\n        this.pipeline = pipeline;\r\n    }\r\n    // todo  setBindGroupdrawTetras(bindGroups\r\n    setBindGroup(index: number, bindGroup: GPUBindGroup) {\r\n        this.computePassEncoder.setBindGroup(index, bindGroup);\r\n    }\r\n    /** Compute slice of given bindgroup attribute data.\r\n     *  beginTetras should be called at first to specify a tetraSlicePipeline\r\n     *  Next calls should be function sliceTetras, setBindGroup or drawTetras.\r\n     */\r\n    sliceTetras(vertexBindGroup: GPUBindGroup, tetraCount: number, instanceCount?: number) {\r\n        if (vertexBindGroup) this.computePassEncoder.setBindGroup(1, vertexBindGroup);\r\n        this.computePassEncoder.dispatchWorkgroups(Math.ceil(tetraCount / 256), instanceCount); // todo: change workgroups\r\n    }\r\n    /** This function draw slices on a internal framebuffer\r\n     *  Every beginTetras call should be end with drawTetras call\r\n     */\r\n    drawTetras(bindGroups?: { group: number, binding: GPUBindGroup }[]) {\r\n        this.computePassEncoder.end();\r\n\r\n        let slicePassEncoder = this.commandEncoder.beginRenderPass(\r\n            this.needClear ? this.crossRenderPass.descClear : this.crossRenderPass.descLoad\r\n        );\r\n        slicePassEncoder.setPipeline(this.pipeline.renderPipeline);\r\n        for (let i = 0; i < this.pipeline.vertexOutNum; i++) {\r\n            slicePassEncoder.setVertexBuffer(i, this.pipeline.outputVaryBuffer[i]);\r\n        }\r\n        if (bindGroups) {\r\n            for (let { group, binding } of bindGroups) {\r\n                slicePassEncoder.setBindGroup(group, binding);\r\n            }\r\n        }\r\n        // bitshift: outputBufferSize / 16 for vertices number, / sliceGroupSize for one stride\r\n        let bitshift = 4 + this.config.sliceGroupSizeBit;\r\n        let verticesStride = this.config.maxCrossSectionBufferSize >> bitshift;\r\n        let offsetVert = 0;\r\n        let sliceJsOffset = (this.sliceIndex << (2 + this.config.sliceGroupSizeBit)) + 3;\r\n        let vpShift = this.config.viewportCompressShift;\r\n        for (let c = 0; c < this.config.sliceGroupSize; c++, offsetVert += verticesStride) {\r\n            let vp = f32_to_u32(this.sliceBuffers.slicesJsBuffer[sliceJsOffset + (c << 2)]);\r\n            slicePassEncoder.setViewport(\r\n                ((vp >> 24) & 0xFF) << vpShift,\r\n                ((vp >> 16) & 0xFF) << vpShift,\r\n                ((vp >> 8) & 0xFF) << vpShift,\r\n                (vp & 0xFF) << vpShift,\r\n                0, 1\r\n            );\r\n            slicePassEncoder.draw(verticesStride, 1, offsetVert);\r\n        }\r\n        slicePassEncoder.end();\r\n        this.needClear = false;\r\n    }\r\n    drawRaytracing(pipeline: RaytracingPipeline, bindGroups?: GPUBindGroup[]) {\r\n        let slicePassEncoder = this.commandEncoder.beginRenderPass(\r\n            this.needClear ? this.crossRenderPass.descClear : this.crossRenderPass.descLoad\r\n        );\r\n        slicePassEncoder.setPipeline(pipeline.pipeline);\r\n        slicePassEncoder.setBindGroup(0, pipeline.bindGroup0);\r\n        if (bindGroups && bindGroups[0]) slicePassEncoder.setBindGroup(1, bindGroups[0]);\r\n        slicePassEncoder.draw(4, this.config.sliceGroupSize);\r\n        slicePassEncoder.end();\r\n        this.needClear = false;\r\n    }\r\n\r\n    testWithFrustumData(obb: AABB, camMat: AffineMat4 | Obj4, modelMat?: AffineMat4 | Obj4): boolean {\r\n        this.frustumRange ??= this.getFrustumRange(camMat);\r\n        if (!this.frustumRange) return true;\r\n        let relP = _vec4.copy((camMat as AffineMat4).vec ?? (camMat as Obj4).position);\r\n        if (modelMat) relP.subs(((modelMat as AffineMat4).vec ?? (modelMat as Obj4).position));\r\n        if (!modelMat) {\r\n            for (let f of this.frustumRange) {\r\n                if (obb.testPlane(new Plane(f, f.dot(relP))) === 1) return false;\r\n            }\r\n        } else if ((modelMat as AffineMat4).mat) {\r\n            for (let f of this.frustumRange) { // todo: .t() to optimise\r\n                if (obb.testPlane(new Plane(_vec42.mulmatvset((modelMat as AffineMat4).mat.t(), f), f.dot(relP))) === 1) return false;\r\n            }\r\n        } else {\r\n            for (let f of this.frustumRange) {\r\n                if (obb.testPlane(new Plane(_vec42.copy(f).rotatesconj((modelMat as Obj4).rotation), f.dot(relP))) === 1) return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    getFrustumRange(camMat: AffineMat4 | Obj4, allRange?: boolean) {\r\n        let minslice = this.sliceIndex << this.config.sliceGroupSizeBit;\r\n        let maxslice = minslice + this.config.sliceGroupSize - 1;\r\n        let isRetinaGroup = this.sliceBuffers.slicesJsBuffer[(minslice << 2) + 1];\r\n        let frustum: number[];\r\n        let camProj = 1 / this.sliceBuffers.camProjJsBuffer[1];\r\n        if (allRange) {\r\n            frustum = [-camProj, camProj, -camProj, camProj, -camProj, camProj];\r\n        } else if (isRetinaGroup === 0) {\r\n            minslice = this.sliceBuffers.slicesJsBuffer[minslice << 2] * camProj;\r\n            maxslice = this.sliceBuffers.slicesJsBuffer[maxslice << 2] * camProj;\r\n            switch (this.sliceBuffers.currentRetinaFacing) {\r\n                case RetinaSliceFacing.POSZ:\r\n                    frustum = [-camProj, camProj, -camProj, camProj, minslice, maxslice];\r\n                    break;\r\n                case RetinaSliceFacing.NEGZ:\r\n                    frustum = [-camProj, camProj, -camProj, camProj, -maxslice, -minslice];\r\n                    break;\r\n                case RetinaSliceFacing.POSX:\r\n                    frustum = [minslice, maxslice, -camProj, camProj, -camProj, camProj];\r\n                    break;\r\n                case RetinaSliceFacing.NEGX:\r\n                    frustum = [-maxslice, -minslice, -camProj, camProj, -camProj, camProj];\r\n                    break;\r\n                case RetinaSliceFacing.POSY:\r\n                    frustum = [-camProj, camProj, minslice, maxslice, -camProj, camProj];\r\n                    break;\r\n                case RetinaSliceFacing.NEGY:\r\n                    frustum = [-camProj, camProj, -maxslice, -minslice, -camProj, camProj];\r\n                    break;\r\n            }\r\n            // refacing = SliceFacing[this.currentRetinaFacing];\r\n        } else {\r\n            // isRetinaGroup = new Uint32Array(new Float32Array([isRetinaGroup]).buffer)[0];\r\n            // todo\r\n        }\r\n        if ((camMat as AffineMat4).mat) {\r\n            const m = (camMat as AffineMat4).mat;\r\n            return frustum ? [\r\n                new Vec4(-1, 0, 0, -frustum[0]).mulmatls(m),\r\n                new Vec4(1, 0, 0, frustum[1]).mulmatls(m),\r\n                new Vec4(0, -1, 0, -frustum[2]).mulmatls(m),\r\n                new Vec4(0, 1, 0, frustum[3]).mulmatls(m),\r\n                new Vec4(0, 0, -1, -frustum[4]).mulmatls(m),\r\n                new Vec4(0, 0, 1, frustum[5]).mulmatls(m),\r\n            ] : undefined;\r\n        } else {\r\n            const r = (camMat as Obj4).rotation;\r\n            return frustum ? [\r\n                new Vec4(-1, 0, 0, -frustum[0]).rotates(r),\r\n                new Vec4(1, 0, 0, frustum[1]).rotates(r),\r\n                new Vec4(0, -1, 0, -frustum[2]).rotates(r),\r\n                new Vec4(0, 1, 0, frustum[3]).rotates(r),\r\n                new Vec4(0, 0, -1, -frustum[4]).rotates(r),\r\n                new Vec4(0, 0, 1, frustum[5]).rotates(r),\r\n            ] : undefined;\r\n        }\r\n        // console.log({ isRetinaGroup, frustum,  refacing});\r\n    }\r\n}\r\nconst arrayBuffer = new ArrayBuffer(4);\r\nfunction f32_to_u32(f32: number) {\r\n    const b = new Float32Array(arrayBuffer);\r\n    b[0] = f32;\r\n    return new Uint32Array(b.buffer)[0];\r\n}\r\nfunction u32_to_f32(u32: number) {\r\n    const b = new Uint32Array(arrayBuffer);\r\n    b[0] = u32;\r\n    return new Float32Array(b.buffer)[0];\r\n}"],"names":[],"mappings":"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"}
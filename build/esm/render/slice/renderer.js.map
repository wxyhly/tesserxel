{"version":3,"file":"renderer.js","sources":["../../../../src/render/slice/renderer.ts"],"sourcesContent":["import { AffineMat4, Obj4 } from \"../../math/algebra/affine\";\r\nimport { Mat4 } from \"../../math/algebra/mat4\";\r\nimport { Vec4 } from \"../../math/algebra/vec4\";\r\nimport { _RAD2DEG } from \"../../math/const\";\r\nimport { OrthographicCamera, PerspectiveCamera, getOrthographicProjectionMatrix, getPerspectiveProjectionMatrix } from \"../../math/geometry/camera\";\r\nimport { AABB, Plane } from \"../../math/geometry/primitive\";\r\nimport { GPU } from \"../gpu\";\r\nimport { DefaultDisplayConfig, DisplayConfig, DisplayConfigName, EyeStereo, IWireframeRenderState, RaytracingPipelineDescriptor, RetinaRenderPassDescriptor, RetinaSliceFacing, SectionConfig, SliceRendererConfig, TetraSlicePipelineDescriptor } from \"./interfaces\";\r\nimport { RaytracingPipeline, StructDefSliceInfo, StructDefUniformBuffer, TetraSlicePipeline, refacingMatsCode } from \"./pipeline\";\r\nimport { RenderState as IRenderState, RetinaRenderPass as IRetinaRenderPass } from \"./interfaces\";\r\n/** Internal use for SliceRenderer's Display Configs */\r\nexport interface InternalDisplayConfig extends DisplayConfig {\r\n    opacity: number;\r\n    paddedSliceNum: number;\r\n    sliceGroupNum: number;\r\n    totalGroupNum: number;\r\n    enableStereo: boolean;\r\n}\r\n/** Internal use for SliceRenderer's Base Configs */\r\nexport interface InternalSliceRendererConfig extends SliceRendererConfig {\r\n    /** log2 of sliceGroupSize in SliceRendererConfig */\r\n    sliceGroupSizeBit: number;\r\n    /** A gpu device limit to set textures as large as possible */\r\n    maxTextureSize: number;\r\n    /** viewport data is compressed in gpu buffer, this gives the amount */\r\n    viewportCompressShift: number;\r\n    /** SliceTexture is a big 2d texuture containing all slices within a slice group*/\r\n    sliceTextureWidth: number;\r\n    sliceTextureHeight: number;\r\n}\r\nconst DefaultWorkGroupSize = 256;\r\nconst DefaultSliceGroupSize = 16;\r\nconst DefaultMaxSlicesNumber = 256;\r\nconst DefaultMaxCrossSectionBufferSize = 0x800000;\r\nconst DefaultEnableFloat16Blend = true;\r\nconst uniformsBufferLength = 64 + 64 + 16 + 4 + 4 + 4 + 4 + 12 + 4; // last 4 is padding\r\nconst retinaMVBufferOffset = 0;\r\nconst retinaProjectBufferOffset = 64;\r\nconst camProjBufferOffset = retinaProjectBufferOffset + 64;\r\nconst eyeCrossBufferOffset = camProjBufferOffset + 16;\r\nconst sliceOffsetBufferOffset = eyeCrossBufferOffset + 12;\r\nconst refacingBufferOffset = sliceOffsetBufferOffset + 4;\r\nconst screenAspectBufferOffset = refacingBufferOffset + 4;\r\nconst layerOpacityBufferOffset = screenAspectBufferOffset + 4;\r\nconst power2arr = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512];\r\nlet linearTextureSampler: GPUSampler;\r\n\r\nexport class SliceRenderer {\r\n\r\n    gpu: GPU;\r\n    private tetraBuffers: TetraSliceBufferMgr;\r\n    private sliceBuffers: RetinaSliceBufferMgr;\r\n    private crossRenderPass: CrossRenderPass;\r\n    private retinaRenderPass: RetinaRenderPass;\r\n    private screenRenderPass: ScreenRenderPass;\r\n    private rendererConfig: InternalSliceRendererConfig;\r\n    private displayConfig: InternalDisplayConfig;\r\n    private wireframeRenderPass: WireFrameRenderPass;\r\n\r\n    constructor(gpu: GPU, config?: SliceRendererConfig) {\r\n        if (!gpu.device) throw \"GPU is not initialized yet.\";\r\n        config ??= {};\r\n        config.maxSlicesNumber ??= DefaultMaxSlicesNumber;\r\n        config.enableFloat16Blend ??= DefaultEnableFloat16Blend;\r\n        config.maxCrossSectionBufferSize ??= DefaultMaxCrossSectionBufferSize;\r\n        config.sliceGroupSize ??= DefaultSliceGroupSize;\r\n        config.defaultWorkGroupSize ??= DefaultWorkGroupSize;\r\n\r\n        this.rendererConfig = config as InternalSliceRendererConfig;\r\n        this.rendererConfig.sliceGroupSizeBit = power2arr.indexOf(config.sliceGroupSize);\r\n        const maxTextureSize = gpu.device.limits.maxTextureDimension2D;\r\n        this.rendererConfig.maxTextureSize = maxTextureSize;\r\n        this.rendererConfig.sliceTextureWidth = maxTextureSize >> 1;\r\n        this.rendererConfig.sliceTextureHeight = maxTextureSize;\r\n        // viewport is compressed in gpu buffer by four u8s, therefore shift amount is maxSize >> 8\r\n        this.rendererConfig.viewportCompressShift = power2arr.indexOf(this.rendererConfig.maxTextureSize >> 8);\r\n        this.gpu = gpu;\r\n        this.wireframeRenderPass = new WireFrameRenderPass(gpu, this.rendererConfig);\r\n        this.sliceBuffers = new RetinaSliceBufferMgr(gpu, this.rendererConfig);\r\n        this.tetraBuffers = new TetraSliceBufferMgr(gpu, this.rendererConfig, this.sliceBuffers);\r\n        this.crossRenderPass = new CrossRenderPass(gpu);\r\n        this.retinaRenderPass = new RetinaRenderPass(gpu, this.rendererConfig, this.sliceBuffers, this.crossRenderPass);\r\n        this.screenRenderPass = new ScreenRenderPass(gpu, this.rendererConfig, this.sliceBuffers);\r\n        linearTextureSampler = gpu.device.createSampler({\r\n            magFilter: 'linear',\r\n            minFilter: 'linear'\r\n        });\r\n        this.displayConfig = {\r\n            sections: [], retinaResolution: 0, retinaLayers: 0,\r\n            retinaStereoEyeOffset: 0, sectionStereoEyeOffset: 0, crosshair: 0,\r\n            opacity: 1, paddedSliceNum: 0, sliceGroupNum: 0, totalGroupNum: 0, enableStereo: false\r\n        };\r\n        this.setDisplayConfig(DefaultDisplayConfig);\r\n    }\r\n    async init() {\r\n        await Promise.all([this.crossRenderPass.init(), this.retinaRenderPass.init(), this.screenRenderPass.init(), this.wireframeRenderPass.init()]);\r\n        return this;\r\n    }\r\n    createRetinaRenderPass(descriptor: RetinaRenderPassDescriptor): IRetinaRenderPass {\r\n        return new RetinaRenderPass(this.gpu, this.rendererConfig, this.sliceBuffers, this.crossRenderPass, descriptor) as IRetinaRenderPass;\r\n    }\r\n    setRetinaRenderPass(retinaRenderPass: IRetinaRenderPass) {\r\n        this.retinaRenderPass = retinaRenderPass as RetinaRenderPass;\r\n    }\r\n    getCurrentRetinaRenderPass() {\r\n        return this.retinaRenderPass as IRetinaRenderPass;\r\n    }\r\n    setDisplayConfig(config: DisplayConfig) {\r\n\r\n        /// Small buffers settings\r\n\r\n        if (config.canvasSize) {\r\n            this.displayConfig.canvasSize = config.canvasSize;\r\n            this.screenRenderPass.setSize(config.canvasSize);\r\n        }\r\n        if (config.screenBackgroundColor) this.displayConfig.screenBackgroundColor = config.screenBackgroundColor;\r\n        if (config.retinaClearColor) {\r\n            this.displayConfig.retinaClearColor = config.retinaClearColor\r\n            this.crossRenderPass.descClear.colorAttachments[0].clearValue = config.retinaClearColor;\r\n        }\r\n        config.retinaLayers ??= this.displayConfig.retinaLayers ?? 0;\r\n        config.opacity ??= this.displayConfig.opacity ?? 1;\r\n        config.crosshair ??= this.displayConfig.crosshair ?? 0;\r\n        config.retinaStereoEyeOffset ??= this.displayConfig.retinaStereoEyeOffset;\r\n        config.sectionStereoEyeOffset ??= this.displayConfig.sectionStereoEyeOffset;\r\n\r\n        if (config.opacity !== this.displayConfig.opacity || config.retinaLayers !== this.displayConfig.retinaLayers) {\r\n            // When sliceNum == 0, opacity is 0 -> detect opacity to not render crosshair\r\n            let value = config.retinaLayers ? config.opacity / config.retinaLayers : 0.0;\r\n            this.gpu.device.queue.writeBuffer(this.sliceBuffers.uniformsBuffer, layerOpacityBufferOffset, new Float32Array([value]));\r\n            this.displayConfig.opacity = config.opacity;\r\n        }\r\n        if (\r\n            config.retinaStereoEyeOffset !== this.displayConfig.retinaStereoEyeOffset ||\r\n            config.sectionStereoEyeOffset !== this.displayConfig.sectionStereoEyeOffset ||\r\n            config.crosshair !== this.displayConfig.crosshair\r\n        ) {\r\n            this.displayConfig.retinaStereoEyeOffset = config.retinaStereoEyeOffset;\r\n            this.displayConfig.sectionStereoEyeOffset = config.sectionStereoEyeOffset;\r\n            this.displayConfig.crosshair = config.crosshair;\r\n            this.gpu.device.queue.writeBuffer(this.sliceBuffers.uniformsBuffer, eyeCrossBufferOffset, new Float32Array([\r\n                config.sectionStereoEyeOffset, config.retinaStereoEyeOffset, config.crosshair\r\n            ]));\r\n            this.displayConfig.enableStereo = this.displayConfig.sectionStereoEyeOffset !== 0 || this.displayConfig.retinaStereoEyeOffset !== 0;\r\n        }\r\n\r\n        if (config.camera4D) this.sliceBuffers.setCameraProjectMatrix(config.camera4D);\r\n        if (config.camera3D) this.sliceBuffers.setRetinaProjectMatrix(config.camera3D);\r\n        if (config.retinaViewMatrix) this.sliceBuffers.setRetinaViewMatrix(config.retinaViewMatrix);\r\n\r\n        /// Small buffers settings end\r\n\r\n        if ((!config.sections) && (this.displayConfig.retinaLayers == config.retinaLayers\r\n        ) && (!config.retinaResolution)) return;\r\n\r\n        /// Retina and section configurations\r\n\r\n        this.sliceBuffers.setSlicesAndSections(this.displayConfig, config);\r\n\r\n    }\r\n    getSafeTetraNumInOnePass() {\r\n        // maximum vertices per slice\r\n        let maxVertices = this.rendererConfig.maxCrossSectionBufferSize >> (this.rendererConfig.sliceGroupSizeBit + 4);\r\n        // one tetra generate at most 6 vertices\r\n        return Math.floor(maxVertices / 6);\r\n    }\r\n    getStereoMode() { return this.getDisplayConfig('retinaStereoEyeOffset') !== 0 || this.getDisplayConfig('sectionStereoEyeOffset') !== 0; }\r\n    getMinResolutionMultiple() { return 1 << this.rendererConfig.viewportCompressShift; }\r\n    getDisplayConfig(configNames: 'canvasSize'): GPUExtent3DStrict;\r\n    getDisplayConfig(configNames: 'sections'): SectionConfig[];\r\n    getDisplayConfig(configNames: 'retinaViewMatrix'): Mat4;\r\n    getDisplayConfig(configNames: 'camera3D' | 'camera4D'): PerspectiveCamera | OrthographicCamera;\r\n    getDisplayConfig(configNames: \"screenBackgroundColor\" | \"retinaClearColor\"): GPUColor;\r\n    getDisplayConfig(configNames: 'retinaLayers' | 'retinaResolution' | 'opacity' | 'sectionStereoEyeOffset' | 'retinaStereoEyeOffset' | 'crosshair'): number;\r\n    getDisplayConfig(...configNames: DisplayConfigName[]) {\r\n        const cfg = this.displayConfig;\r\n        if (!configNames || !configNames.length) {\r\n            return {\r\n                canvasSize: cfg.canvasSize,\r\n                sections: this.sliceBuffers.deepCopySectionConfigs(cfg.sections),\r\n                retinaLayers: cfg.retinaLayers,\r\n                retinaResolution: cfg.retinaResolution,\r\n                opacity: cfg.opacity,\r\n                retinaStereoEyeOffset: cfg.retinaStereoEyeOffset,\r\n                sectionStereoEyeOffset: cfg.sectionStereoEyeOffset,\r\n                crosshair: cfg.crosshair,\r\n                screenBackgroundColor: cfg.screenBackgroundColor,\r\n                retinaClearColor: cfg.retinaClearColor,\r\n                camera4D: cfg.camera4D,\r\n                camera3D: cfg.camera3D,\r\n                retinaViewMatrix: cfg.retinaViewMatrix,\r\n            } as DisplayConfig;\r\n        }\r\n        if (configNames.length === 1) {\r\n            const name = configNames[0];\r\n            switch (name) {\r\n                case 'sections': return this.sliceBuffers.deepCopySectionConfigs(cfg.sections);\r\n                default: return cfg[name];\r\n            }\r\n        }\r\n        return configNames.map(name => name === 'sections' ? this.sliceBuffers.deepCopySectionConfigs(cfg.sections) : cfg[name]);\r\n    }\r\n    render(context: GPUCanvasContext, drawCall: (rs: IRenderState) => void, wireFrameDrawCall?: (rs: IWireframeRenderState) => void) {\r\n        this.sliceBuffers.updateBuffers(this.displayConfig.sliceGroupNum);\r\n\r\n        const gpu = this.gpu;\r\n        if (!this.crossRenderPass.clearRenderPipeline) throw \"SliceRenderer is not initailzed, forget to call 'await SliceRenderer.init()' ?\";\r\n        if (!this.retinaRenderPass.pipeline) throw \"SliceRenderer's current retinaRenderPass is not initailzed, forget to call 'await RetinaRenderPass.init()' ?\";\r\n        let canvasView = context.getCurrentTexture().createView();\r\n        const renderState = new RenderState(this.gpu, this.rendererConfig, this.sliceBuffers, this.tetraBuffers, this.crossRenderPass);\r\n        const commandEncoder = renderState.commandEncoder;\r\n        // todo: disable depth first, then add it\r\n        if (wireFrameDrawCall) {\r\n            this.wireframeRenderPass.renderPassDesc = {\r\n                colorAttachments: [{\r\n                    clearValue: this.displayConfig.screenBackgroundColor,\r\n                    view: this.screenRenderPass.view,\r\n                    loadOp: \"clear\" as GPULoadOp,\r\n                    storeOp: 'store' as GPUStoreOp\r\n                }],\r\n                depthStencilAttachment: {\r\n                    view: this.screenRenderPass.depthView,\r\n                    depthClearValue: 1.0,\r\n                    depthLoadOp: 'clear' as GPULoadOp,\r\n                    depthStoreOp: 'store' as GPUStoreOp,\r\n                }\r\n            };\r\n            this.wireframeRenderPass.renderState = renderState;\r\n            wireFrameDrawCall(this.wireframeRenderPass);\r\n            this.wireframeRenderPass.renderState = undefined;\r\n        }\r\n\r\n        for (let sliceIndex = 0; sliceIndex < this.displayConfig.totalGroupNum; sliceIndex++) {\r\n            renderState.needClear = true;\r\n            renderState.sliceIndex = sliceIndex;\r\n            renderState.frustumRange = undefined;\r\n            // set new slicegroup offset\r\n            commandEncoder.copyBufferToBuffer(this.sliceBuffers.sliceGroupOffsetBuffer, sliceIndex << 2, this.sliceBuffers.uniformsBuffer, sliceOffsetBufferOffset, 4);\r\n            drawCall(renderState);\r\n            if (renderState.needClear) {\r\n                // if drawCall is empty, we also need to clear texture\r\n                let clearPassEncoder = commandEncoder.beginRenderPass(this.crossRenderPass.descClear);\r\n                clearPassEncoder.setPipeline(this.crossRenderPass.clearRenderPipeline);\r\n                clearPassEncoder.draw(0);\r\n                clearPassEncoder.end();\r\n            }\r\n            const loadOp = (!wireFrameDrawCall) && sliceIndex === 0 ? 'clear' : \"load\" as GPULoadOp;\r\n            let retinaPassEncoder = commandEncoder.beginRenderPass({\r\n                colorAttachments: [{\r\n                    view: this.screenRenderPass.view,\r\n                    clearValue: this.displayConfig.screenBackgroundColor,\r\n                    loadOp,\r\n                    storeOp: 'store' as GPUStoreOp\r\n                }],\r\n\r\n                depthStencilAttachment: {\r\n                    view: this.screenRenderPass.depthView,\r\n                    depthClearValue: 1.0,\r\n                    depthLoadOp: loadOp,\r\n                    depthStoreOp: 'store' as GPUStoreOp,\r\n                }\r\n            });\r\n            retinaPassEncoder.setPipeline(this.retinaRenderPass.pipeline);\r\n            retinaPassEncoder.setBindGroup(0, this.retinaRenderPass.bindgroup);\r\n            if (this.retinaRenderPass.alphaBindgroup) {\r\n                retinaPassEncoder.setBindGroup(1, this.retinaRenderPass.alphaBindgroup);\r\n            }\r\n            let isSectionCount = this.displayConfig.sections.length && sliceIndex >= this.displayConfig.sliceGroupNum;\r\n            let lastCount = isSectionCount ? this.displayConfig.sections.length % this.rendererConfig.sliceGroupSize : 0;\r\n            let count = isSectionCount ? (\r\n                // if is section group\r\n                sliceIndex == this.displayConfig.totalGroupNum - 1 && lastCount ? lastCount : this.rendererConfig.sliceGroupSize\r\n            ) :\r\n                // if is not section group\r\n                this.displayConfig.enableStereo ? (this.rendererConfig.sliceGroupSize << 1) : this.rendererConfig.sliceGroupSize;\r\n            retinaPassEncoder.draw(4, count, 0, 0);\r\n            retinaPassEncoder.end();\r\n        }\r\n\r\n        let screenPassEncoder = commandEncoder.beginRenderPass({\r\n            colorAttachments: [{\r\n                view: canvasView,\r\n                clearValue: this.displayConfig.screenBackgroundColor,\r\n                loadOp: 'clear' as GPULoadOp,\r\n                storeOp: 'store' as GPUStoreOp\r\n            }]\r\n        });\r\n        screenPassEncoder.setPipeline(this.screenRenderPass.pipeline);\r\n        screenPassEncoder.setBindGroup(0, this.screenRenderPass.bindgroup);\r\n        screenPassEncoder.draw(4);\r\n        screenPassEncoder.end();\r\n        gpu.device.queue.submit([commandEncoder.finish()]);\r\n    }\r\n\r\n    async createTetraSlicePipeline(descriptor: TetraSlicePipelineDescriptor): Promise<TetraSlicePipeline> {\r\n        // lazy init buffer here, optimization for only raytracing rendering\r\n        if (!this.tetraBuffers.outputVaryBufferPool.length) this.tetraBuffers.init();\r\n        return await new TetraSlicePipeline().init(this.gpu, this.rendererConfig, descriptor, this.tetraBuffers);\r\n    }\r\n    async createRaytracingPipeline(descriptor: RaytracingPipelineDescriptor): Promise<RaytracingPipeline> {\r\n        return await new RaytracingPipeline().init(this.gpu, this.rendererConfig, descriptor, this.sliceBuffers);\r\n    }\r\n\r\n    /** for TetraSlicePipeline, vertex shader is internally a compute shader, so it doesn't share bindgroups with fragment shader.\r\n     *  for RaytracingPipeline, vertex shader and fragment shader are in one traditional render pipeline, they share bindgroups.\r\n     */\r\n    createVertexShaderBindGroup(pipeline: TetraSlicePipeline | RaytracingPipeline, index: number, buffers: GPUBuffer[], label?: string) {\r\n        if (index === 0) throw \"Unable to create BindGroup 0, which is occupied by internal usages.\";\r\n        return this.gpu.createBindGroup(\r\n            ((pipeline as TetraSlicePipeline).computePipeline ?\r\n                (pipeline as TetraSlicePipeline).computePipeline :\r\n                (pipeline as RaytracingPipeline).pipeline\r\n            ), index, buffers.map(e => ({ buffer: e })), \"VertexShaderBindGroup<\" + label + \">\"\r\n        );\r\n    }\r\n    /** for TetraSlicePipeline, vertex shader is internally a compute shader, so it doesn't share bindgroups with fragment shader.\r\n     *  for RaytracingPipeline, vertex shader and fragment shader are in one traditional render pipeline, they share bindgroups.\r\n     */\r\n    createFragmentShaderBindGroup(pipeline: TetraSlicePipeline | RaytracingPipeline, index: number, buffers: GPUBuffer[], label?: string) {\r\n        if (index === 0 && (pipeline as RaytracingPipeline).pipeline) throw \"Unable to create BindGroup 0, which is occupied by internal usages.\";\r\n        return this.gpu.createBindGroup(\r\n            ((pipeline as TetraSlicePipeline).computePipeline ?\r\n                (pipeline as TetraSlicePipeline).renderPipeline :\r\n                (pipeline as RaytracingPipeline).pipeline\r\n            ), index, buffers.map(e => ({ buffer: e })), \"FragmentShaderBindGroup<\" + label + \">\"\r\n        );\r\n    }\r\n}\r\n\r\n\r\n\r\nexport class RetinaSliceBufferMgr {\r\n\r\n    private queue: GPUQueue;\r\n    private rendererConfig: InternalSliceRendererConfig;\r\n    currentRetinaFacing: RetinaSliceFacing;\r\n    retinaMVMatChanged: boolean = true;\r\n    retinaFacingOrSlicesChanged: boolean = true;\r\n\r\n    uniformsBuffer: GPUBuffer;\r\n    thumbnailViewportBuffer: GPUBuffer;\r\n\r\n    retinaProjectJsBuffer = new Float32Array(16);\r\n    retinaMVMatJsBuffer = new Float32Array(16);\r\n    camProjJsBuffer = new Float32Array(4);\r\n    slicesJsBuffer = new Float32Array(4);\r\n    sliceGroupOffsetBuffer: GPUBuffer;\r\n    emitIndexSliceBuffer: GPUBuffer;\r\n\r\n    constructor(gpu: GPU, config: InternalSliceRendererConfig) {\r\n\r\n        this.emitIndexSliceBuffer = gpu.createBuffer(GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST, (4 << config.sliceGroupSizeBit) + (config.maxSlicesNumber << 4));\r\n\r\n        this.uniformsBuffer = gpu.createBuffer(GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST, uniformsBufferLength);\r\n        this.thumbnailViewportBuffer = gpu.createBuffer(GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST, 1024);\r\n\r\n        this.queue = gpu.device.queue;\r\n\r\n        const maxSliceGroupNum = Math.ceil(config.maxSlicesNumber / config.sliceGroupSize);\r\n        const sliceGroupOffsets = new Uint32Array(maxSliceGroupNum);\r\n        for (let i = 0; i < maxSliceGroupNum; i++) {\r\n            sliceGroupOffsets[i] = i * config.sliceGroupSize;\r\n        }\r\n        this.sliceGroupOffsetBuffer = gpu.createBuffer(GPUBufferUsage.COPY_SRC, sliceGroupOffsets);\r\n        this.rendererConfig = config;\r\n    }\r\n    updateBuffers(sliceGroupNum: number) {\r\n        if (this.retinaMVMatChanged) {\r\n            this.queue.writeBuffer(this.uniformsBuffer, retinaMVBufferOffset, this.retinaMVMatJsBuffer);\r\n            this.retinaMVMatChanged = false;\r\n        }\r\n        if (this.retinaFacingOrSlicesChanged) {\r\n            // refacing buffer stores not only refacing but also retina slices\r\n            this.queue.writeBuffer(this.uniformsBuffer, refacingBufferOffset, new Uint32Array([\r\n                this.currentRetinaFacing | ((sliceGroupNum) << (5 + this.rendererConfig.sliceGroupSizeBit))\r\n            ]));\r\n            this.retinaFacingOrSlicesChanged = false;\r\n        }\r\n    }\r\n    deepCopySectionConfigs(sectionConfigs: SectionConfig[], defaultRetinaResolution?: number) {\r\n        return sectionConfigs.map(e => ({\r\n            eyeStereo: e.eyeStereo ?? EyeStereo.None,\r\n            facing: e.facing,\r\n            slicePos: e.slicePos ?? 0,\r\n            viewport: {\r\n                x: e.viewport.x,\r\n                y: e.viewport.y,\r\n                width: e.viewport.width,\r\n                height: e.viewport.height,\r\n            },\r\n            resolution: e.resolution ?? defaultRetinaResolution\r\n        })) as SectionConfig[];\r\n    }\r\n    setSlicesAndSections(internalDisplayConfig: InternalDisplayConfig, displayConfig: DisplayConfig) {\r\n\r\n        let vpShift = this.rendererConfig.viewportCompressShift;\r\n        let prevRetinaResolution = internalDisplayConfig.retinaResolution;\r\n        if (displayConfig.retinaResolution) internalDisplayConfig.retinaResolution = (displayConfig.retinaResolution >> vpShift) << vpShift;\r\n\r\n        if (displayConfig.sections) {\r\n            // deepcopy\r\n            internalDisplayConfig.sections = this.deepCopySectionConfigs(displayConfig.sections, internalDisplayConfig.retinaResolution);\r\n        }\r\n\r\n        internalDisplayConfig.sections ??= [];\r\n        internalDisplayConfig.retinaLayers = displayConfig.retinaLayers;\r\n        let sections = internalDisplayConfig.sections;\r\n        let sliceStep = 2 / displayConfig.retinaLayers; // slice from -1 to 1\r\n        let sliceGroupNum = Math.ceil(displayConfig.retinaLayers / this.rendererConfig.sliceGroupSize);\r\n        let paddedSliceNum = sliceGroupNum << this.rendererConfig.sliceGroupSizeBit;\r\n        internalDisplayConfig.paddedSliceNum = paddedSliceNum;\r\n        let sectionNum = sections.length ?? 0;\r\n        let sectionGroupNum = Math.ceil(sectionNum / this.rendererConfig.sliceGroupSize);\r\n        let totalNum = paddedSliceNum + (sectionGroupNum << this.rendererConfig.sliceGroupSizeBit);\r\n        let slices = (this.slicesJsBuffer?.length === totalNum << 2) ? this.slicesJsBuffer : new Float32Array(totalNum << 2);\r\n        this.slicesJsBuffer = slices;\r\n        slices.fill(0);// todo : check neccesity?\r\n\r\n        let retinaWidth = internalDisplayConfig.retinaResolution;\r\n        let retinaX = 0, retinaY = 0;\r\n        for (let slice = -1, i = 0, sliceGroupOffset = 0; i < paddedSliceNum; slice += sliceStep, i++, sliceGroupOffset++) {\r\n            if (sliceGroupOffset === this.rendererConfig.sliceGroupSize) {\r\n                // start a new slice group\r\n                sliceGroupOffset = 0;\r\n                retinaX = 0;\r\n                retinaY = 0;\r\n            }\r\n            slices[(i << 2)] = slice; // slice pos. if slice > 1, discard in shader\r\n            slices[(i << 2) + 1] = 0; // leave 0 for retina slice (used only in cross section)\r\n            slices[(i << 2) + 2] = 0; // leave 0 for retina slice (used only in cross section)\r\n            let wshift = retinaWidth >> vpShift;\r\n            // a compressed viewport infomation\r\n            slices[(i << 2) + 3] = u32_to_f32(((retinaX >> vpShift) << 24) + ((retinaY >> vpShift) << 16) + (wshift << 8) + wshift);\r\n            if (retinaX + retinaWidth > this.rendererConfig.sliceTextureWidth ||\r\n                retinaY + retinaWidth > this.rendererConfig.sliceTextureHeight) {\r\n                this.setSlicesAndSections(internalDisplayConfig, { retinaResolution: prevRetinaResolution });\r\n                console.warn(\"Maximum retinaResolution reached\");\r\n                return;\r\n            }\r\n            retinaY += retinaWidth;\r\n            if (retinaY + retinaWidth > this.rendererConfig.sliceTextureHeight) {\r\n                retinaX += retinaWidth;\r\n                retinaY = 0;\r\n            }\r\n        }\r\n\r\n        internalDisplayConfig.sliceGroupNum = sliceGroupNum;\r\n        internalDisplayConfig.totalGroupNum = sliceGroupNum + sectionGroupNum;\r\n        if (sectionNum) {\r\n            let thumbnailViewportJsBuffer = new Float32Array(4 * 16);\r\n            let lastGroupPosition = sectionGroupNum - 1 << this.rendererConfig.sliceGroupSizeBit;\r\n            let lastGroupSlices = sections.length - lastGroupPosition;\r\n            // get max resolution widths per slice group\r\n\r\n            let deltaX = [];\r\n            let maxDx = 0;\r\n            for (let j = 0, sliceGroupOffset = 0, l = sections.length; j < l; j++, sliceGroupOffset++) {\r\n                let config = sections[j];\r\n                if (sliceGroupOffset === this.rendererConfig.sliceGroupSize) {\r\n                    sliceGroupOffset = 0;\r\n                    deltaX.push((maxDx >> vpShift) << vpShift);\r\n                    maxDx = 0;\r\n                }\r\n                maxDx = Math.max(maxDx, Math.ceil(config.resolution / config.viewport.height * config.viewport.width));\r\n            }\r\n            deltaX.push((maxDx >> 4) << 4);\r\n            retinaX = 0;\r\n            retinaY = 0;\r\n            let sliceGroup = 0;\r\n            for (let i = paddedSliceNum, j = 0, sliceGroupOffset = 0; i < totalNum; i++, j++, sliceGroupOffset++) {\r\n                let config = sections[j];\r\n                slices[(i << 2)] = config?.slicePos ?? 0;\r\n                slices[(i << 2) + 1] = u32_to_f32(((config?.facing) ?? 0) | ((config?.eyeStereo ?? 1) << 3));\r\n                slices[(i << 2) + 2] = u32_to_f32(j < lastGroupPosition ? this.rendererConfig.sliceGroupSize : lastGroupSlices);\r\n                if (config) {\r\n                    if (sliceGroupOffset === this.rendererConfig.sliceGroupSize) {\r\n                        retinaX = 0;\r\n                        retinaY = 0;\r\n                        sliceGroupOffset = 0;\r\n                        sliceGroup++;\r\n                    } else if (retinaY + config.resolution > this.rendererConfig.sliceTextureHeight) {\r\n                        retinaX += deltaX[sliceGroup];\r\n                        retinaY = 0;\r\n                    }\r\n\r\n                    let wshift = Math.ceil(config.resolution / config.viewport.height * config.viewport.width) >> vpShift;\r\n                    let hshift = config.resolution >> vpShift;\r\n                    slices[(i << 2) + 3] = u32_to_f32(\r\n                        (((retinaX >> vpShift)) << 24) + ((retinaY >> vpShift) << 16) + (wshift << 8) + hshift\r\n                    );\r\n                    thumbnailViewportJsBuffer[j << 2] = config.viewport.x;\r\n                    thumbnailViewportJsBuffer[(j << 2) + 1] = config.viewport.y;\r\n                    thumbnailViewportJsBuffer[(j << 2) + 2] = config.viewport.width;\r\n                    thumbnailViewportJsBuffer[(j << 2) + 3] = config.viewport.height;\r\n\r\n                    retinaY += (config.resolution >> vpShift) << vpShift;\r\n                }\r\n            }\r\n            this.queue.writeBuffer(this.thumbnailViewportBuffer, 0, thumbnailViewportJsBuffer);\r\n        }\r\n        this.queue.writeBuffer(this.emitIndexSliceBuffer, 0, slices);\r\n        this.retinaFacingOrSlicesChanged = true;\r\n    }\r\n    setRetinaProjectMatrix(camera: PerspectiveCamera | OrthographicCamera) {\r\n        if ((camera as PerspectiveCamera).fov) {\r\n            getPerspectiveProjectionMatrix(camera as PerspectiveCamera).mat4.writeBuffer(this.retinaProjectJsBuffer);\r\n        } else {\r\n            getOrthographicProjectionMatrix(camera as OrthographicCamera).mat4.writeBuffer(this.retinaProjectJsBuffer);\r\n        }\r\n        this.queue.writeBuffer(this.uniformsBuffer, retinaProjectBufferOffset, this.retinaProjectJsBuffer);\r\n    }\r\n    setRetinaViewMatrix(m: Mat4) {\r\n        let e = m.elem;\r\n        let facing = this.getFacing(e[8], e[9], e[10]);\r\n        if (facing !== this.currentRetinaFacing) {\r\n            this.retinaFacingOrSlicesChanged = true;\r\n            this.currentRetinaFacing = facing;\r\n        }\r\n        m.writeBuffer(this.retinaMVMatJsBuffer);\r\n        this.retinaMVMatChanged = true;\r\n    }\r\n    getRetinaCamera(): PerspectiveCamera | OrthographicCamera {\r\n        let c = this.retinaProjectJsBuffer;\r\n        let near = c[3] / c[2];\r\n        if (c[0] > 0) {\r\n            return {\r\n                fov: Math.atan(1 / c[1]) * _RAD2DEG * 2,\r\n                aspect: c[1] / c[0],\r\n                near,\r\n                far: c[2] * near / (1 + c[2])\r\n            };\r\n        } else {\r\n            return {\r\n                size: 1 / c[1],\r\n                aspect: - c[1] / c[0],\r\n                near,\r\n                far: near - 1.0 / c[2]\r\n            };\r\n        }\r\n    }\r\n    setCameraProjectMatrix(camera: PerspectiveCamera | OrthographicCamera) {\r\n        if ((camera as PerspectiveCamera).fov) {\r\n            getPerspectiveProjectionMatrix(camera as PerspectiveCamera).vec4.writeBuffer(this.camProjJsBuffer);\r\n        } else {\r\n            getOrthographicProjectionMatrix(camera as OrthographicCamera).vec4.writeBuffer(this.camProjJsBuffer);\r\n            this.camProjJsBuffer[0] = -this.camProjJsBuffer[0]; // use negative to mark Orthographic in shader\r\n        }\r\n        this.queue.writeBuffer(this.uniformsBuffer, camProjBufferOffset, this.camProjJsBuffer);\r\n    }\r\n    getFacing(x: number, y: number, z: number) {\r\n        let xa = Math.abs(x);\r\n        let ya = Math.abs(y);\r\n        let za = Math.abs(z);\r\n        switch (za > ya ? za > xa ? 2 : 0 : ya > xa ? 1 : 0) {\r\n            case 0:\r\n                return x > 0 ? RetinaSliceFacing.POSX : RetinaSliceFacing.NEGX;\r\n            case 1:\r\n                return y > 0 ? RetinaSliceFacing.POSY : RetinaSliceFacing.NEGY;\r\n            default:\r\n                return z > 0 ? RetinaSliceFacing.POSZ : RetinaSliceFacing.NEGZ;\r\n        }\r\n    }\r\n}\r\nclass CrossRenderPass {\r\n    descClear: GPURenderPassDescriptor;\r\n    descLoad: GPURenderPassDescriptor;\r\n    clearRenderPipelinePromise: Promise<GPURenderPipeline>;\r\n    clearRenderPipeline: GPURenderPipeline;\r\n    sliceTextureSize: { width: number, height: number };\r\n    sliceView: GPUTextureView;\r\n    constructor(gpu: GPU) {\r\n        // sliceTexture covered by sliceGroupSize x 2 atlas of sliceResolution x sliceResolution\r\n        let maxTextureSize = gpu.device.limits.maxTextureDimension2D;\r\n        let sliceTextureSize = { width: maxTextureSize >> 1, height: maxTextureSize };\r\n        this.sliceTextureSize = sliceTextureSize;\r\n        let sliceTexture = gpu.device.createTexture({\r\n            size: sliceTextureSize, format: gpu.preferredFormat,\r\n            usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING,\r\n        });\r\n        this.sliceView = sliceTexture.createView();\r\n\r\n        let depthTexture = gpu.device.createTexture({\r\n            size: sliceTextureSize, format: 'depth24plus',\r\n            usage: GPUTextureUsage.RENDER_ATTACHMENT,\r\n        });\r\n        let depthView = depthTexture.createView();\r\n        this.descClear = {\r\n            colorAttachments: [{\r\n                view: this.sliceView,\r\n                clearValue: { r: 0, g: 0, b: 0, a: 0.0 },\r\n                loadOp: 'clear' as GPULoadOp,\r\n                storeOp: 'store' as GPUStoreOp\r\n            }],\r\n            depthStencilAttachment: {\r\n                view: depthView,\r\n                depthClearValue: 1.0,\r\n                depthLoadOp: 'clear' as GPULoadOp,\r\n                depthStoreOp: 'store' as GPUStoreOp,\r\n            }\r\n        };\r\n\r\n        this.descLoad = {\r\n            colorAttachments: [{\r\n                view: this.sliceView,\r\n                loadOp: 'load' as GPULoadOp,\r\n                storeOp: 'store' as GPUStoreOp\r\n            }],\r\n            depthStencilAttachment: {\r\n                view: depthView,\r\n                depthLoadOp: 'load' as GPULoadOp,\r\n                depthStoreOp: 'store' as GPUStoreOp,\r\n            }\r\n        };\r\n        let clearModule = gpu.device.createShaderModule({\r\n            code:\r\n                \"@vertex fn v()->@builtin(position) vec4<f32>{ return vec4<f32>();} @fragment fn f()->@location(0) vec4<f32>{ return vec4<f32>();}\"\r\n        });\r\n        this.clearRenderPipelinePromise = gpu.device.createRenderPipelineAsync({\r\n            layout: 'auto',\r\n            vertex: {\r\n                module: clearModule,\r\n                entryPoint: 'v',\r\n            },\r\n            fragment: {\r\n                module: clearModule,\r\n                entryPoint: 'f',\r\n                targets: [{ format: gpu.preferredFormat }]\r\n            },\r\n            depthStencil: {\r\n                format: 'depth24plus',\r\n                depthCompare: 'less',\r\n                depthWriteEnabled: true\r\n            }\r\n        });\r\n    }\r\n    async init() {\r\n        this.clearRenderPipeline = await this.clearRenderPipelinePromise;\r\n    }\r\n}\r\nconst outputAttributeUsage = typeof GPUBufferUsage === 'undefined' ? null : GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST | GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX;\r\n\r\nexport class TetraSliceBufferMgr {\r\n    maxCrossSectionBufferSize: number;\r\n    gpu: GPU;\r\n    outputVaryBufferPool: Array<GPUBuffer> = []; // all the vary buffers for pipelines\r\n    private indicesInOutputBufferPool: Set<number>;\r\n    buffers: { buffer: GPUBuffer }[];\r\n    // outputVaryBuffer: GPUBuffer[];\r\n    constructor(gpu: GPU, config: InternalSliceRendererConfig, sliceBuffers: RetinaSliceBufferMgr) {\r\n        this.buffers = [\r\n            { buffer: sliceBuffers.emitIndexSliceBuffer },\r\n            { buffer: sliceBuffers.uniformsBuffer },\r\n            { buffer: sliceBuffers.thumbnailViewportBuffer },\r\n        ];\r\n        this.gpu = gpu;\r\n        this.maxCrossSectionBufferSize = config.maxCrossSectionBufferSize;\r\n    }\r\n    init() {\r\n        // lazy init buffer in creeating first tetraslice pipeline, optimization for only raytracing rendering\r\n        this.outputVaryBufferPool.push(this.gpu.createBuffer(outputAttributeUsage, this.maxCrossSectionBufferSize, \"Output buffer for builtin(position)\"));\r\n    }\r\n    prepareNewPipeline() {\r\n        this.indicesInOutputBufferPool = new Set;\r\n        this.indicesInOutputBufferPool.add(0); // default builtin(position) buffer\r\n        return [this.outputVaryBufferPool[0]];\r\n    }\r\n    destroy() {\r\n        for (const buffer of this.outputVaryBufferPool) {\r\n            buffer.destroy();\r\n        }\r\n    }\r\n    ////// caution: data race here\r\n    requireOutputBuffer(id: number, size: number, outBuffers: GPUBuffer[]): GPUBuffer {\r\n        if (id === 0) return this.outputVaryBufferPool[0];\r\n        let expectedSize = this.maxCrossSectionBufferSize * size;\r\n        for (let i = 0; i < this.outputVaryBufferPool.length; i++) {\r\n            if (this.indicesInOutputBufferPool.has(i)) continue; // we can't bind the same buffer again\r\n            let buffer = this.outputVaryBufferPool[i];\r\n            if (buffer.size === expectedSize) {\r\n                // found unused exactly sized buffer\r\n                this.indicesInOutputBufferPool.add(i);\r\n                outBuffers.push(buffer);\r\n                return buffer;\r\n            }\r\n        }\r\n        // no buffer found, we need to create\r\n        let buffer = this.gpu.createBuffer(outputAttributeUsage, expectedSize, \"Output buffer for \" + size + \" vec4(s)\");\r\n        this.indicesInOutputBufferPool.add(this.outputVaryBufferPool.length);\r\n        this.outputVaryBufferPool.push(buffer);\r\n        outBuffers.push(buffer);\r\n        return buffer;\r\n    }\r\n}\r\nclass RetinaRenderPass implements IRetinaRenderPass {\r\n    pipeline: GPURenderPipeline;\r\n    pipelinePromise: Promise<GPURenderPipeline>;\r\n    bindgroup: GPUBindGroup;\r\n    alphaBindgroup: GPUBindGroup;\r\n    crossRenderPass: CrossRenderPass;\r\n    readonly __brand: \"RetinaRenderPass\";\r\n    private gpu: GPU;\r\n    private config: InternalSliceRendererConfig;\r\n    private sliceBuffers: RetinaSliceBufferMgr;\r\n    descriptor: RetinaRenderPassDescriptor\r\n\r\n    constructor(gpu: GPU, config: InternalSliceRendererConfig, sliceBuffers: RetinaSliceBufferMgr, crossRenderPass: CrossRenderPass, descriptor?: RetinaRenderPassDescriptor) {\r\n        this.gpu = gpu;\r\n        this.config = config;\r\n        this.descriptor = descriptor ?? {};\r\n        this.sliceBuffers = sliceBuffers;\r\n        this.crossRenderPass = crossRenderPass;\r\n        let retinaRenderCode = refacingMatsCode + StructDefSliceInfo + StructDefUniformBuffer + `\r\nstruct tsxvOutputType{\r\n    @builtin(position) position : vec4<f32>,\r\n    @location(0) relativeFragPosition : vec3<f32>,\r\n    @location(1) crossHair : f32,\r\n    @location(2) rayForCalOpacity : vec4<f32>,\r\n    @location(3) retinaCoord : vec3<f32>,\r\n    @location(4) normalForCalOpacity : vec4<f32>,\r\n}\r\nstruct tsxfInputType{\r\n    @location(0) relativeFragPosition : vec3<f32>,\r\n    @location(1) crossHair : f32,\r\n    @location(2) rayForCalOpacity : vec4<f32>,\r\n    @location(3) retinaCoord : vec3<f32>,\r\n    @location(4) normalForCalOpacity : vec4<f32>,\r\n}\r\n@group(0) @binding(0) var<storage,read> slice : array<tsxSliceInfo,${this.config.maxSlicesNumber}>;\r\n@group(0) @binding(1) var<uniform> tsx_uniforms : tsxUniformBuffer;\r\n@group(0) @binding(2) var<uniform> thumbnailViewport : array<vec4<f32>,16>;\r\n\r\n@vertex fn mainVertex(@builtin(vertex_index) vindex : u32, @builtin(instance_index) iindex : u32) -> tsxvOutputType {\r\n    const pos = array<vec2<f32>, 4>(\r\n        vec2<f32>(-1.0, -1.0),\r\n        vec2<f32>(-1.0, 1.0),\r\n        vec2<f32>( 1.0, -1.0),\r\n        vec2<f32>( 1.0, 1.0),\r\n    );\r\n    var sindex = iindex;\r\n    var pos2d = pos[vindex];\r\n    let stereoLR = f32(iindex & 1) - 0.5;\r\n    if (slice[tsx_uniforms.sliceOffset].flag == 0 && tsx_uniforms.eyeCross.y != 0.0){\r\n        sindex = iindex >> 1;\r\n    }\r\n    let s = slice[sindex + tsx_uniforms.sliceOffset];\r\n    // let coord = vec2<f32>(pos2d.x, -pos2d.y) * 0.5 + 0.5;\r\n    let ray = vec4<f32>(pos2d, s.slicePos, 1.0);\r\n    var retinaCoord: vec4<f32>;\r\n    var glPosition: vec4<f32>;\r\n    var camRay: vec4<f32>;\r\n    var normal: vec4<f32>;\r\n    let x = f32(((s.viewport >> 24) & 0xFF) << ${this.config.viewportCompressShift}) * ${1 / this.config.sliceTextureWidth};\r\n    let y = f32(((s.viewport >> 16) & 0xFF) << ${this.config.viewportCompressShift}) * ${1 / this.config.sliceTextureHeight};\r\n    let w = f32(((s.viewport >> 8 ) & 0xFF) << ${this.config.viewportCompressShift}) * ${1 / this.config.sliceTextureWidth};\r\n    let h = f32((s.viewport & 0xFF) << ${this.config.viewportCompressShift}) * ${1 / this.config.sliceTextureHeight};\r\n    var crossHair : f32;\r\n    if (slice[tsx_uniforms.sliceOffset].flag == 0){\r\n        crossHair = 0.0;\r\n        let stereoLR_offset = -stereoLR * tsx_uniforms.eyeCross.y;\r\n        let se = sin(stereoLR_offset);\r\n        let ce = cos(stereoLR_offset);\r\n        var pureRotationMvMat = tsx_uniforms.retinaMV;\r\n        pureRotationMvMat[3].z = 0.0;\r\n        let eyeMat = mat4x4<f32>(\r\n            ce,0,se,0,\r\n            0,1,0,0,\r\n            -se,0,ce,0,\r\n            0,0,tsx_uniforms.retinaMV[3].z,1\r\n        );\r\n        let omat = eyeMat * pureRotationMvMat * tsx_refacingMats[tsx_uniforms.refacing & 7];\r\n        camRay = omat * ray;\r\n        retinaCoord = tsx_refacingMats[tsx_uniforms.refacing & 7] * ray;\r\n        glPosition = tsx_uniforms.retinaP * camRay;\r\n        if(tsx_uniforms.retinaP[3].w > 0){ // Orthographic\r\n            camRay = vec4<f32>(0.0,0.0,-1.0,1.0);\r\n        }\r\n        normal = omat[2];\r\n        // todo: viewport of retina slices\r\n        glPosition.x = (glPosition.x) * tsx_uniforms.screenAspect + step(0.0001, abs(tsx_uniforms.eyeCross.y)) * stereoLR * glPosition.w;\r\n    }else{\r\n        let vp = thumbnailViewport[sindex + tsx_uniforms.sliceOffset - (tsx_uniforms.refacing >> 5)];\r\n        crossHair = tsx_uniforms.eyeCross.z / vp.w * step(abs(s.slicePos),0.1);\r\n        glPosition = vec4<f32>(ray.x * vp.z * tsx_uniforms.screenAspect + vp.x, ray.y * vp.w + vp.y,0.5,1.0);\r\n        camRay = vec4<f32>(pos[vindex].x * vp.z / vp.w,pos[vindex].y,0.0,1.0); // for rendering crosshair\r\n    }\r\n    \r\n    let texelCoord = array<vec2<f32>, 4>(\r\n        vec2<f32>(x, y+h),\r\n        vec2<f32>(x, y),\r\n        vec2<f32>( x+w, y+h),\r\n        vec2<f32>( x+w, y),\r\n    );\r\n    return tsxvOutputType(\r\n        glPosition,\r\n        vec3<f32>(texelCoord[vindex], s.slicePos),\r\n        crossHair,\r\n        camRay,\r\n        retinaCoord.xyz,\r\n        normal\r\n    );\r\n}\r\n\r\n@group(0) @binding(3) var tsx_txt: texture_2d<f32>;\r\n@group(0) @binding(4) var tsx_splr: sampler;\r\n${descriptor?.alphaShader?.code ?? `\r\nfn mainAlpha(color: vec4<f32>, retinaCoord: vec3<f32>) -> f32{\r\n    return color.a;\r\n}\r\n`}\r\n@fragment fn mainFragment(input : tsxfInputType) -> @location(0) vec4<f32> {\r\n    let color = textureSample(tsx_txt, tsx_splr, input.relativeFragPosition.xy);\r\n    var alpha: f32 = 1.0;\r\n    var factor = 0.0;\r\n    if (slice[tsx_uniforms.sliceOffset].flag == 0){\r\n        let dotvalue = dot(normalize(input.rayForCalOpacity.xyz), input.normalForCalOpacity.xyz);\r\n        let factor = tsx_uniforms.layerOpacity / (clamp(-dotvalue,0.0,1.0));\r\n        alpha = clamp(${descriptor?.alphaShader?.entryPoint ?? \"mainAlpha\"}(color, input.retinaCoord) * factor,0.0,1.0);\r\n    }else if (input.crossHair > 0.0) {\r\n    let cross = abs(input.rayForCalOpacity.xy);\r\n    factor = step(cross.x, input.crossHair * 0.05) + step(cross.y, input.crossHair * 0.05);\r\n    factor *= step(cross.x, input.crossHair) * step(cross.y, input.crossHair);\r\n}\r\nreturn vec4<f32>(mix(color.rgb, vec3<f32>(1.0) - color.rgb, clamp(factor, 0.0, 1.0)), alpha);\r\n}\r\n`;\r\n        const retinaRenderShaderModule = gpu.device.createShaderModule({\r\n            code: retinaRenderCode\r\n        });\r\n        this.pipelinePromise = gpu.device.createRenderPipelineAsync({\r\n            layout: 'auto',\r\n            vertex: {\r\n                module: retinaRenderShaderModule,\r\n                entryPoint: 'mainVertex',\r\n            },\r\n            fragment: {\r\n                module: retinaRenderShaderModule,\r\n                entryPoint: 'mainFragment',\r\n                targets: [{\r\n                    format: this.config.enableFloat16Blend ? 'rgba16float' : this.gpu.preferredFormat,\r\n                    blend: {\r\n                        color: {\r\n                            srcFactor: \"src-alpha\" as GPUBlendFactor,\r\n                            dstFactor: \"one-minus-src-alpha\" as GPUBlendFactor,\r\n                            operation: \"add\" as GPUBlendOperation\r\n                        },\r\n                        alpha: {}\r\n                    }\r\n                }],\r\n            },\r\n            depthStencil: {\r\n                depthWriteEnabled: true,\r\n                depthCompare: 'less',\r\n                format: 'depth24plus',\r\n            },\r\n            primitive: { topology: 'triangle-strip' }\r\n        });\r\n    }\r\n    async init() {\r\n        this.pipeline = await this.pipelinePromise;\r\n        this.bindgroup = this.gpu.createBindGroup(this.pipeline, 0, [\r\n            { buffer: this.sliceBuffers.emitIndexSliceBuffer },\r\n            { buffer: this.sliceBuffers.uniformsBuffer },\r\n            { buffer: this.sliceBuffers.thumbnailViewportBuffer },\r\n            this.crossRenderPass.sliceView,\r\n            linearTextureSampler,\r\n        ], \"retinaBindGroup\");\r\n        if (this.descriptor.alphaShaderBindingResources) {\r\n            this.alphaBindgroup = this.gpu.createBindGroup(\r\n                this.pipeline, 1, this.descriptor.alphaShaderBindingResources, \"retinaAlphaBindGroup\"\r\n            );\r\n        }\r\n        return this;\r\n    }\r\n}\r\n/** \r\n * ---------------------------------\r\n * screen render pass\r\n * for float16 blending and convert color to srgb\r\n * ---------------------------------\r\n *  */\r\nconst screenRenderCode = StructDefUniformBuffer + `\r\n@group(0) @binding(0) var tsx_txt: texture_2d<f32>;\r\n@group(0) @binding(1) var tsx_splr: sampler;\r\n@group(0) @binding(2) var<uniform>tsx_uniforms : tsxUniformBuffer;\r\nstruct tsxvOutputType{\r\n    @builtin(position) position: vec4<f32>,\r\n    @location(0) fragPosition: vec2<f32>,\r\n}\r\nstruct tsxfInputType{\r\n    @location(0) fragPosition: vec2<f32>,\r\n}\r\n@vertex fn mainVertex(@builtin(vertex_index) index : u32) -> tsxvOutputType {\r\n    const pos = array<vec2<f32>, 4>(\r\n        vec2<f32>(-1.0, -1.0),\r\n        vec2<f32>(-1.0, 1.0),\r\n        vec2<f32>(1.0, -1.0),\r\n        vec2<f32>(1.0, 1.0),\r\n    );\r\n    const uv = array<vec2<f32>, 4>(\r\n        vec2<f32>(0.0, 1.0),\r\n        vec2<f32>(0.0, 0.0),\r\n        vec2<f32>(1.0, 1.0),\r\n        vec2<f32>(1.0, 0.0),\r\n    );\r\n    return tsxvOutputType(vec4<f32>(pos[index], 0.0, 1.0), uv[index]);\r\n}\r\n@fragment fn mainFragment(input: tsxfInputType) -> @location(0) vec4 < f32 > {\r\nlet color = textureSample(tsx_txt, tsx_splr, input.fragPosition);\r\nvar factor = 0.0;\r\nif(tsx_uniforms.eyeCross.z > 0.0 && tsx_uniforms.layerOpacity > 0.0){\r\n    let aspectedCross = tsx_uniforms.eyeCross.z * tsx_uniforms.screenAspect;\r\n    if (tsx_uniforms.eyeCross.x != 0.0) {\r\n        let cross1 = abs(input.fragPosition - vec2<f32>(0.25, 0.5)) * 2.0;\r\n        let cross2 = abs(input.fragPosition - vec2<f32>(0.75, 0.5)) * 2.0;\r\n        factor = step(cross1.x, 0.05 * aspectedCross) + step(cross2.x, 0.05 * aspectedCross) + step(cross1.y, tsx_uniforms.eyeCross.z * 0.05);\r\n        factor *= step(cross1.y, tsx_uniforms.eyeCross.z) * (step(cross1.x, aspectedCross) + step(cross2.x, aspectedCross));\r\n    } else {\r\n        let cross = abs(input.fragPosition - vec2<f32>(0.5, 0.5)) * 2.0;\r\n        factor = step(cross.x, 0.05 * aspectedCross) + step(cross.y, tsx_uniforms.eyeCross.z * 0.05);\r\n        factor *= step(cross.y, tsx_uniforms.eyeCross.z) * step(cross.x, aspectedCross);\r\n    }\r\n}\r\nreturn vec4<f32>(mix(color.rgb, vec3<f32>(1.0) - color.rgb, clamp(factor, 0.0, 1.0)), 1.0);\r\n}\r\n`;\r\nclass ScreenRenderPass {\r\n    view: GPUTextureView;\r\n    depthView: GPUTextureView;\r\n    pipeline: GPURenderPipeline;\r\n    pipelinePromise: Promise<GPURenderPipeline>;\r\n    bindgroup: GPUBindGroup;\r\n    texture: GPUTexture;\r\n    depthTexture: GPUTexture;\r\n    private gpu: GPU;\r\n    private config: InternalSliceRendererConfig;\r\n    private sliceBuffers: RetinaSliceBufferMgr;\r\n    constructor(gpu: GPU, config: InternalSliceRendererConfig, sliceBuffers: RetinaSliceBufferMgr) {\r\n        this.gpu = gpu;\r\n        this.config = config;\r\n        this.sliceBuffers = sliceBuffers;\r\n        let screenRenderShaderModule = gpu.device.createShaderModule({\r\n            code: screenRenderCode\r\n        });\r\n        this.pipelinePromise = gpu.device.createRenderPipelineAsync({\r\n            layout: 'auto',\r\n            vertex: {\r\n                module: screenRenderShaderModule,\r\n                entryPoint: 'mainVertex',\r\n            },\r\n            fragment: {\r\n                module: screenRenderShaderModule,\r\n                entryPoint: 'mainFragment',\r\n                targets: [{\r\n                    format: gpu.preferredFormat\r\n                }],\r\n            },\r\n            primitive: { topology: 'triangle-strip' }\r\n        });\r\n    }\r\n    setSize(size: GPUExtent3DStrict) {\r\n        if (this.texture) this.texture.destroy();\r\n        if (this.depthTexture) this.depthTexture.destroy();\r\n\r\n        // if (!this.pipeline) throw \"TetraSliceRenderer: ScreenRenderPipeline is not initialized.\";\r\n        this.texture = this.gpu.device.createTexture({\r\n            size, format: this.config.enableFloat16Blend ? 'rgba16float' : this.gpu.preferredFormat,\r\n            usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING,\r\n        });\r\n        this.depthTexture = this.gpu.device.createTexture({\r\n            size, format: 'depth24plus',\r\n            usage: GPUTextureUsage.RENDER_ATTACHMENT,\r\n        });\r\n        this.view = this.texture.createView();\r\n        this.depthView = this.depthTexture.createView();\r\n\r\n        if (this.pipeline) {\r\n            this.bindgroup = this.gpu.createBindGroup(this.pipeline, 0, [\r\n                this.view,\r\n                linearTextureSampler,\r\n                { buffer: this.sliceBuffers.uniformsBuffer },\r\n            ], \"screenBindGroup\");\r\n        }\r\n        let aspect: number;\r\n        if ((size as GPUExtent3DDict).height) {\r\n            aspect = (size as GPUExtent3DDict).height / (size as GPUExtent3DDict).width;\r\n        } else {\r\n            aspect = size[1] / size[0];\r\n        }\r\n        this.gpu.device.queue.writeBuffer(this.sliceBuffers.uniformsBuffer, screenAspectBufferOffset, new Float32Array([aspect]));\r\n    }\r\n    async init() {\r\n        this.pipeline = await this.pipelinePromise;\r\n        this.bindgroup = this.gpu.createBindGroup(this.pipeline, 0, [\r\n            this.view,\r\n            linearTextureSampler,\r\n            { buffer: this.sliceBuffers.uniformsBuffer },\r\n        ], \"screenBindGroup\");\r\n    }\r\n}\r\nconst _vec4 = new Vec4;\r\nconst _vec42 = new Vec4;\r\n\r\nexport class WireFrameRenderPass {\r\n    private pipeline: GPURenderPipeline;\r\n    private pipelinePromise: Promise<GPURenderPipeline>;\r\n    dataBuffer: GPUBuffer;\r\n    private bindGroup: GPUBindGroup;\r\n    gpu: GPU;\r\n    private config: InternalSliceRendererConfig;\r\n    renderState: RenderState;\r\n    renderPassDesc: GPURenderPassDescriptor;\r\n    constructor(gpu: GPU, config: InternalSliceRendererConfig) {\r\n        this.gpu = gpu;\r\n        this.config = config;\r\n        const shaderModule = gpu.device.createShaderModule({\r\n            code: StructDefUniformBuffer + `\r\n@group(0) @binding(0) var<uniform> tsx_uniforms : tsxUniformBuffer;\r\n@vertex fn tsxVMain(@location(0) inPos: vec4<f32>, @builtin(instance_index) idx: u32) -> @builtin(position) vec4<f32>{\r\n    let stereoLR = f32(idx & 1) - 0.5;\r\n    let stereoLR_offset = -stereoLR * tsx_uniforms.eyeCross.y;\r\n    let se = sin(stereoLR_offset);\r\n    let ce = cos(stereoLR_offset);\r\n    var pureRotationMvMat = tsx_uniforms.retinaMV;\r\n    pureRotationMvMat[3].z = 0.0;\r\n    let eyeMat = mat4x4<f32>(\r\n        ce,0,se,0,\r\n        0,1,0,0,\r\n        -se,0,ce,0,\r\n        0,0,tsx_uniforms.retinaMV[3].z,1\r\n    );\r\n    var glPosition = tsx_uniforms.retinaP * eyeMat * pureRotationMvMat * vec4(inPos.xyz, 1.0);\r\n    glPosition.x = (glPosition.x) * tsx_uniforms.screenAspect + step(0.0001, abs(tsx_uniforms.eyeCross.y)) * stereoLR * glPosition.w;\r\n    return glPosition;\r\n}\r\n@fragment fn tsxFMain()->@location(0) vec4<f32>{\r\n    return vec4<f32>(1.0,0.0,0.0,1.0);\r\n}`,\r\n        });\r\n        this.pipelinePromise = gpu.device.createRenderPipelineAsync({\r\n            layout: 'auto',\r\n            vertex: {\r\n                module: shaderModule,\r\n                entryPoint: \"tsxVMain\",\r\n                buffers: [\r\n                    {\r\n                        attributes: [\r\n                            {\r\n                                shaderLocation: 0,\r\n                                offset: 0,\r\n                                format: \"float32x4\",\r\n                            }\r\n                        ],\r\n                        arrayStride: 4 * 4,\r\n                    }\r\n                ]\r\n            },\r\n            primitive: {\r\n                topology: \"line-list\"\r\n            },\r\n            fragment: {\r\n                targets: [\r\n                    { format: this.config.enableFloat16Blend ? 'rgba16float' : this.gpu.preferredFormat },\r\n                ],\r\n                module: shaderModule,\r\n                entryPoint: \"tsxFMain\"\r\n            },\r\n            depthStencil: {\r\n                depthWriteEnabled: true,\r\n                depthCompare: 'less',\r\n                format: 'depth24plus',\r\n            }\r\n        });\r\n\r\n    }\r\n    async init() {\r\n        this.pipeline = await this.pipelinePromise;\r\n    }\r\n    render(buffer: GPUBuffer, vertices: number) {\r\n        if (!this.pipeline) return;\r\n        this.bindGroup ??= this.gpu.createBindGroup(this.pipeline, 0, [{\r\n            buffer: this.renderState.sliceBuffers.uniformsBuffer\r\n        }]);\r\n        const renderPassEncoder = this.renderState.commandEncoder.beginRenderPass(this.renderPassDesc);\r\n        renderPassEncoder.setPipeline(this.pipeline);\r\n        renderPassEncoder.setVertexBuffer(0, buffer);\r\n        renderPassEncoder.setBindGroup(0, this.bindGroup);\r\n        // todo: deal with no retina voxel / non stero mode\r\n        renderPassEncoder.draw(vertices, 2);\r\n        renderPassEncoder.end();\r\n    }\r\n}\r\n\r\nclass RenderState {\r\n    commandEncoder: GPUCommandEncoder;\r\n    computePassEncoder: GPUComputePassEncoder;\r\n    pipeline: TetraSlicePipeline;\r\n    tetraSliceBufferMgr: TetraSliceBufferMgr;\r\n    config: InternalSliceRendererConfig;\r\n    // slicePassEncoder: GPURenderPassEncoder;\r\n    sliceIndex: number;\r\n    needClear: boolean;\r\n    tetraBuffers: TetraSliceBufferMgr;\r\n    sliceBuffers: RetinaSliceBufferMgr;\r\n    crossRenderPass: CrossRenderPass;\r\n    frustumRange: Vec4[];\r\n    constructor(gpu: GPU, config: InternalSliceRendererConfig, sliceBuffers: RetinaSliceBufferMgr, tetraBuffers: TetraSliceBufferMgr, crossRenderPass: CrossRenderPass) {\r\n        this.commandEncoder = gpu.device.createCommandEncoder();\r\n        this.tetraBuffers = tetraBuffers;\r\n        this.sliceBuffers = sliceBuffers;\r\n        this.crossRenderPass = crossRenderPass;\r\n        this.config = config;\r\n    }\r\n    /** Set TetraSlicePipeline and prepare GPU resources.\r\n     *  Next calls should be function sliceTetras or setBindGroup.\r\n     */\r\n    beginTetras(pipeline: TetraSlicePipeline) {\r\n        // let { commandEncoder, sliceIndex, needClear } = this.renderState;\r\n        // clear triagle slice vertex output pointer to zero (emitIndex part)\r\n        this.commandEncoder.clearBuffer(this.sliceBuffers.emitIndexSliceBuffer, this.config.maxSlicesNumber << 4, 4 << this.config.sliceGroupSizeBit);\r\n        // clear triagle slice vertex output data to zero\r\n        this.commandEncoder.clearBuffer(pipeline.outputVaryBuffer[0]);\r\n        this.computePassEncoder = this.commandEncoder.beginComputePass();\r\n        this.computePassEncoder.setPipeline(pipeline.computePipeline);\r\n        this.computePassEncoder.setBindGroup(0, pipeline.computeBindGroup0);\r\n        this.pipeline = pipeline;\r\n    }\r\n    // todo 写清楚 setBindGroup、drawTetras(bindGroups的区别\r\n    setBindGroup(index: number, bindGroup: GPUBindGroup) {\r\n        this.computePassEncoder.setBindGroup(index, bindGroup);\r\n    }\r\n    /** Compute slice of given bindgroup attribute data.\r\n     *  beginTetras should be called at first to specify a tetraSlicePipeline\r\n     *  Next calls should be function sliceTetras, setBindGroup or drawTetras.\r\n     */\r\n    sliceTetras(vertexBindGroup: GPUBindGroup, tetraCount: number, instanceCount?: number) {\r\n        if (vertexBindGroup) this.computePassEncoder.setBindGroup(1, vertexBindGroup);\r\n        this.computePassEncoder.dispatchWorkgroups(Math.ceil(tetraCount / 256), instanceCount); // todo: change workgroups\r\n    }\r\n    /** This function draw slices on a internal framebuffer\r\n     *  Every beginTetras call should be end with drawTetras call\r\n     */\r\n    drawTetras(bindGroups?: { group: number, binding: GPUBindGroup }[]) {\r\n        this.computePassEncoder.end();\r\n\r\n        let slicePassEncoder = this.commandEncoder.beginRenderPass(\r\n            this.needClear ? this.crossRenderPass.descClear : this.crossRenderPass.descLoad\r\n        );\r\n        slicePassEncoder.setPipeline(this.pipeline.renderPipeline);\r\n        for (let i = 0; i < this.pipeline.vertexOutNum; i++) {\r\n            slicePassEncoder.setVertexBuffer(i, this.pipeline.outputVaryBuffer[i]);\r\n        }\r\n        if (bindGroups) {\r\n            for (let { group, binding } of bindGroups) {\r\n                slicePassEncoder.setBindGroup(group, binding);\r\n            }\r\n        }\r\n        // bitshift: outputBufferSize / 16 for vertices number, / sliceGroupSize for one stride\r\n        let bitshift = 4 + this.config.sliceGroupSizeBit;\r\n        let verticesStride = this.config.maxCrossSectionBufferSize >> bitshift;\r\n        let offsetVert = 0;\r\n        let sliceJsOffset = (this.sliceIndex << (2 + this.config.sliceGroupSizeBit)) + 3;\r\n        let vpShift = this.config.viewportCompressShift;\r\n        for (let c = 0; c < this.config.sliceGroupSize; c++, offsetVert += verticesStride) {\r\n            let vp = f32_to_u32(this.sliceBuffers.slicesJsBuffer[sliceJsOffset + (c << 2)]);\r\n            slicePassEncoder.setViewport(\r\n                ((vp >> 24) & 0xFF) << vpShift,\r\n                ((vp >> 16) & 0xFF) << vpShift,\r\n                ((vp >> 8) & 0xFF) << vpShift,\r\n                (vp & 0xFF) << vpShift,\r\n                0, 1\r\n            );\r\n            slicePassEncoder.draw(verticesStride, 1, offsetVert);\r\n        }\r\n        slicePassEncoder.end();\r\n        this.needClear = false;\r\n    }\r\n    drawRaytracing(pipeline: RaytracingPipeline, bindGroups?: GPUBindGroup[]) {\r\n        let slicePassEncoder = this.commandEncoder.beginRenderPass(\r\n            this.needClear ? this.crossRenderPass.descClear : this.crossRenderPass.descLoad\r\n        );\r\n        slicePassEncoder.setPipeline(pipeline.pipeline);\r\n        slicePassEncoder.setBindGroup(0, pipeline.bindGroup0);\r\n        if (bindGroups && bindGroups[0]) slicePassEncoder.setBindGroup(1, bindGroups[0]);\r\n        slicePassEncoder.draw(4, this.config.sliceGroupSize);\r\n        slicePassEncoder.end();\r\n        this.needClear = false;\r\n    }\r\n\r\n    testWithFrustumData(obb: AABB, camMat: AffineMat4 | Obj4, modelMat?: AffineMat4 | Obj4): boolean {\r\n        this.frustumRange ??= this.getFrustumRange(camMat);\r\n        if (!this.frustumRange) return true;\r\n        let relP = _vec4.copy((camMat as AffineMat4).vec ?? (camMat as Obj4).position);\r\n        if (modelMat) relP.subs(((modelMat as AffineMat4).vec ?? (modelMat as Obj4).position));\r\n        if (!modelMat) {\r\n            for (let f of this.frustumRange) {\r\n                if (obb.testPlane(new Plane(f, f.dot(relP))) === 1) return false;\r\n            }\r\n        } else if ((modelMat as AffineMat4).mat) {\r\n            for (let f of this.frustumRange) { // todo: .t() to optimise\r\n                if (obb.testPlane(new Plane(_vec42.mulmatvset((modelMat as AffineMat4).mat.t(), f), f.dot(relP))) === 1) return false;\r\n            }\r\n        } else {\r\n            for (let f of this.frustumRange) {\r\n                if (obb.testPlane(new Plane(_vec42.copy(f).rotatesconj((modelMat as Obj4).rotation), f.dot(relP))) === 1) return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    getFrustumRange(camMat: AffineMat4 | Obj4, allRange?: boolean) {\r\n        let minslice = this.sliceIndex << this.config.sliceGroupSizeBit;\r\n        let maxslice = minslice + this.config.sliceGroupSize - 1;\r\n        let isRetinaGroup = this.sliceBuffers.slicesJsBuffer[(minslice << 2) + 1];\r\n        let frustum: number[];\r\n        let camProj = 1 / this.sliceBuffers.camProjJsBuffer[1];\r\n        if (allRange) {\r\n            frustum = [-camProj, camProj, -camProj, camProj, -camProj, camProj];\r\n        } else if (isRetinaGroup === 0) {\r\n            minslice = this.sliceBuffers.slicesJsBuffer[minslice << 2] * camProj;\r\n            maxslice = this.sliceBuffers.slicesJsBuffer[maxslice << 2] * camProj;\r\n            switch (this.sliceBuffers.currentRetinaFacing) {\r\n                case RetinaSliceFacing.POSZ:\r\n                    frustum = [-camProj, camProj, -camProj, camProj, minslice, maxslice];\r\n                    break;\r\n                case RetinaSliceFacing.NEGZ:\r\n                    frustum = [-camProj, camProj, -camProj, camProj, -maxslice, -minslice];\r\n                    break;\r\n                case RetinaSliceFacing.POSX:\r\n                    frustum = [minslice, maxslice, -camProj, camProj, -camProj, camProj];\r\n                    break;\r\n                case RetinaSliceFacing.NEGX:\r\n                    frustum = [-maxslice, -minslice, -camProj, camProj, -camProj, camProj];\r\n                    break;\r\n                case RetinaSliceFacing.POSY:\r\n                    frustum = [-camProj, camProj, minslice, maxslice, -camProj, camProj];\r\n                    break;\r\n                case RetinaSliceFacing.NEGY:\r\n                    frustum = [-camProj, camProj, -maxslice, -minslice, -camProj, camProj];\r\n                    break;\r\n            }\r\n            // refacing = SliceFacing[this.currentRetinaFacing];\r\n        } else {\r\n            // isRetinaGroup = new Uint32Array(new Float32Array([isRetinaGroup]).buffer)[0];\r\n            // todo\r\n        }\r\n        if ((camMat as AffineMat4).mat) {\r\n            const m = (camMat as AffineMat4).mat;\r\n            return frustum ? [\r\n                new Vec4(-1, 0, 0, -frustum[0]).mulmatls(m),\r\n                new Vec4(1, 0, 0, frustum[1]).mulmatls(m),\r\n                new Vec4(0, -1, 0, -frustum[2]).mulmatls(m),\r\n                new Vec4(0, 1, 0, frustum[3]).mulmatls(m),\r\n                new Vec4(0, 0, -1, -frustum[4]).mulmatls(m),\r\n                new Vec4(0, 0, 1, frustum[5]).mulmatls(m),\r\n            ] : undefined;\r\n        } else {\r\n            const r = (camMat as Obj4).rotation;\r\n            return frustum ? [\r\n                new Vec4(-1, 0, 0, -frustum[0]).rotates(r),\r\n                new Vec4(1, 0, 0, frustum[1]).rotates(r),\r\n                new Vec4(0, -1, 0, -frustum[2]).rotates(r),\r\n                new Vec4(0, 1, 0, frustum[3]).rotates(r),\r\n                new Vec4(0, 0, -1, -frustum[4]).rotates(r),\r\n                new Vec4(0, 0, 1, frustum[5]).rotates(r),\r\n            ] : undefined;\r\n        }\r\n        // console.log({ isRetinaGroup, frustum,  refacing});\r\n    }\r\n}\r\nconst arrayBuffer = new ArrayBuffer(4);\r\nfunction f32_to_u32(f32: number) {\r\n    const b = new Float32Array(arrayBuffer);\r\n    b[0] = f32;\r\n    return new Uint32Array(b.buffer)[0];\r\n}\r\nfunction u32_to_f32(u32: number) {\r\n    const b = new Uint32Array(arrayBuffer);\r\n    b[0] = u32;\r\n    return new Float32Array(b.buffer)[0];\r\n}"],"names":[],"mappings":"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"}
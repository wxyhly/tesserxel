{"version":3,"file":"wgsl.js","sources":["../../../src/render/wgsl.ts"],"sourcesContent":["import { ArgumentInfo, ArrayInfo, Attribute, MemberInfo, ResourceType, TypeInfo, WgslReflect } from \"wgsl_reflect\";\r\n\r\nexport { WgslReflect, ResourceType,TypeInfo };\r\nexport function parseTypeName(type: TypeInfo) {\r\n    return type.name + ((type as ArrayInfo).format ? `<${parseTypeName((type as ArrayInfo).format)}${(type as ArrayInfo).count ? \",\" + (type as ArrayInfo).count : \"\"}>` : \"\");\r\n}\r\nexport function parseAttr(attrs: Array<Attribute>) {\r\n    // todo: match just one attribute\r\n    return attrs ? Array.from(new Set(attrs.map(a => a.name + (a.value ? `(${a.value})` : \"\")))).join(\" \") : \"\";\r\n}\r\nexport function getFnInputAndOutput(\r\n    reflect: WgslReflect, fn: ReturnType<WgslReflect[\"_functions\"][\"get\"]>,\r\n    expectInput: { [name: string]: string }, expectOutput: string[]\r\n) {\r\n    let input: Set<string> = new Set();\r\n    let output: { [name: string]: string | { expr: string, type: string } } = {\r\n        \"return\": \"_ouput_of_\" + fn.node.name\r\n    };\r\n    let call = `\r\n                let _ouput_of_${fn.node.name} = ${fn.node.name}(${fn.node.args.map(a => getInput(a as any as ArgumentInfo)).join(\", \")});\r\n                `;\r\n    getOutput(fn.node.returnType as any as TypeInfo, \"_ouput_of_\" + fn.node.name);\r\n    return { input, call, output: output as { [name: string]: { expr: string, type: string } } };\r\n\r\n    function getInput(arg: ArgumentInfo | MemberInfo) {\r\n        let attr = parseAttr(arg.attributes ? arg.attributes.concat(arg.type.attributes ?? []) : arg.type.attributes);\r\n        let varName = expectInput[attr];\r\n        if (varName) {\r\n            input.add(attr);\r\n            return varName;\r\n        } else {\r\n            let struct = reflect.structs.filter(s => s.name === arg.type.name)[0];\r\n            if (!struct) {\r\n                console.error(\"invalid entry point function args\");\r\n            }\r\n            let str = arg.type.name + \"(\";\r\n            for (let m of struct.members) {\r\n                str += getInput(m) + \",\";\r\n            }\r\n            str += \")\";\r\n            return str;\r\n        }\r\n    }\r\n    function getOutput(type: TypeInfo, prefix: string) {\r\n        let varName = parseAttr(type.attributes);\r\n        if (expectOutput.includes(varName)) {\r\n            output[varName] = {\r\n                expr: prefix,\r\n                type: parseTypeName(type)\r\n            }; return;\r\n        } else {\r\n            let struct = reflect.structs.filter(s => s.name === type.name)[0];\r\n            if (!struct) { return; }\r\n            for (let m of struct.members) {\r\n                if (m.attributes) {\r\n                    m.type.attributes = m.type.attributes ? m.type.attributes : m.attributes;\r\n                }\r\n                getOutput(m.type, prefix + \".\" + m.name);\r\n            }\r\n        }\r\n    }\r\n}"],"names":[],"mappings":"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"}
{"version":3,"file":"wgslparser.js","sources":["../../../src/render/wgslparser.ts"],"sourcesContent":["// @ts-nocheck\r\nexport namespace wgslreflect {\r\n    export declare type ReflectAttribute = {\r\n        name: string;\r\n        value?: string;\r\n    };\r\n    export declare type ReflectType = {\r\n        name: string;\r\n        attributes: Array<ReflectAttribute>;\r\n        format?: ReflectType;\r\n        count?: string;\r\n    };\r\n    export declare type ReflectArg = {\r\n        name: string;\r\n        type: ReflectType;\r\n        attributes: Array<ReflectAttribute>;\r\n        _type: \"arg\";\r\n    };\r\n    export declare type ReflectMember = {\r\n        name: string;\r\n        type: ReflectType;\r\n        attributes: Array<ReflectAttribute>;\r\n        _type: \"member\";\r\n    };\r\n    export declare type ReflectFunction = {\r\n        args: Array<ReflectArg>;\r\n        attributes: Array<ReflectAttribute>;\r\n        name: string;\r\n        return: ReflectType;\r\n        _type: \"function\";\r\n    };\r\n    // export declare class WgslReflect {\r\n    //     functions: Array<ReflectFunction>;\r\n    //     structs: Array<ReflectStruct>;\r\n    //     constructor(code: string);\r\n    // };\r\n    export declare type ReflectStruct = {\r\n        name: string;\r\n        members: Array<ReflectMember>;\r\n        attributes: Array<ReflectAttribute>;\r\n        _type: \"struct\";\r\n    };\r\n    /** expectedInput:\r\n     *  {\r\n     *      \"location(0)\": \"_attribute0\",\r\n     *      ...\r\n     *  }\r\n     *  input: set{ \"location(0)\", ...}\r\n     *  expectedOutput: \r\n     *  Array{\"builtin(position)\", \"location(0)\", ...}\r\n     *  output: {\r\n     *      \"builtin(position)\": \"_output_of_fn.pos\",\r\n     *      ...\r\n     *  }\r\n     * */\r\n    export function parseTypeName(type: ReflectType) {\r\n        return type.name + (type.format ? `<${parseTypeName(type.format)}${type.count ? \",\" + type.count : \"\"}>` : \"\");\r\n    }\r\n    export function parseAttr(attrs: Array<ReflectAttribute>) {\r\n        // todo: match just one attribute\r\n        return attrs ? attrs.map(a => a.name + (a.value ? `(${a.value})` : \"\")).join(\" \") : \"\";\r\n    }\r\n    export function getFnInputAndOutput(\r\n        reflect: WgslReflect, fn: ReflectFunction,\r\n        expectInput: { [name: string]: string }, expectOutput: string[]\r\n    ) {\r\n        let input: Set<string> = new Set();\r\n        let output: { [name: string]: { expr: string, type: string } } = {\r\n            \"return\": \"_ouput_of_\" + fn.name\r\n        };\r\n        let call = `\r\n                let _ouput_of_${fn.name} = ${fn.name}(${fn.args.map(a => getInput(a)).join(\", \")});\r\n                `;\r\n        getOutput(fn.return, \"_ouput_of_\" + fn.name);\r\n        return { input, call, output };\r\n\r\n        function getInput(arg: ReflectArg | ReflectMember) {\r\n            let attr = parseAttr(arg.attributes ? arg.attributes.concat(arg.type.attributes ?? []) : arg.type.attributes);\r\n            let varName = expectInput[attr];\r\n            if (varName) {\r\n                input.add(attr);\r\n                return varName;\r\n            } else {\r\n                let struct = reflect.structs.filter(s => s.name === arg.type.name)[0];\r\n                if (!struct) {\r\n                    console.error(\"invalid entry point function args\");\r\n                }\r\n                let str = arg.type.name + \"(\";\r\n                for (let m of struct.members) {\r\n                    str += getInput(m) + \",\";\r\n                }\r\n                str += \")\";\r\n                return str;\r\n            }\r\n        }\r\n        function getOutput(type: ReflectType, prefix: string) {\r\n            let varName = parseAttr(type.attributes);\r\n            if (expectOutput.includes(varName)) {\r\n                output[varName] = {\r\n                    expr: prefix,\r\n                    type: parseTypeName(type)\r\n                }; return;\r\n            } else {\r\n                let struct = reflect.structs.filter(s => s.name === type.name)[0];\r\n                if (!struct) { return; }\r\n                for (let m of struct.members) {\r\n                    if (m.attributes) {\r\n                        m.type.attributes = m.type.attributes ? m.type.attributes.concat(m.attributes) : m.attributes;\r\n                    }\r\n                    getOutput(m.type, prefix + \".\" + m.name);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @author Brendan Duncan / https://github.com/brendan-duncan\r\n     */\r\n\r\n    class Token {\r\n        constructor(type, lexeme, line) {\r\n            this._type = type;\r\n            this._lexeme = lexeme;\r\n            this._line = line;\r\n        }\r\n\r\n        toString() {\r\n            return this._lexeme;\r\n        }\r\n    }\r\n\r\n    Token.EOF = { name: \"EOF\", type: \"token\", rule: -1 };\r\n\r\n    let Keyword = {};\r\n\r\n    class WgslScanner {\r\n        constructor(source) {\r\n            this._source = source || \"\";\r\n            this._tokens = [];\r\n            this._start = 0;\r\n            this._current = 0;\r\n            this._line = 1;\r\n        }\r\n\r\n        scanTokens() {\r\n            while (!this._isAtEnd()) {\r\n                this._start = this._current;\r\n                if (!this.scanToken())\r\n                    throw `Invalid syntax at line ${this._line}`;\r\n            }\r\n\r\n            this._tokens.push(new Token(Token.EOF, \"\", this._line));\r\n            return this._tokens;\r\n        }\r\n\r\n        scanToken() {\r\n            // Find the longest consecutive set of characters that match a rule.\r\n            let lexeme = this._advance();\r\n\r\n            // Skip line-feed, adding to the line counter.\r\n            if (lexeme == \"\\n\") {\r\n                this._line++;\r\n                return true;\r\n            }\r\n\r\n            // Skip whitespace\r\n            if (this._isWhitespace(lexeme)) {\r\n                return true;\r\n            }\r\n\r\n            if (lexeme == \"/\") {\r\n                // If it's a // comment, skip everything until the next line-feed.\r\n                if (this._peekAhead() == \"/\") {\r\n                    while (lexeme != \"\\n\") {\r\n                        if (this._isAtEnd())\r\n                            return true;\r\n                        lexeme = this._advance();\r\n                    }\r\n                    // skip the linefeed\r\n                    this._line++;\r\n                    return true;\r\n                } else if (this._peekAhead() == \"*\") {\r\n                    // If it's a /* block comment, skip everything until the matching */,\r\n                    // allowing for nested block comments.\r\n                    this._advance();\r\n                    let commentLevel = 1;\r\n                    while (commentLevel > 0) {\r\n                        if (this._isAtEnd())\r\n                            return true;\r\n                        lexeme = this._advance();\r\n                        if (lexeme == \"\\n\") {\r\n                            this._line++;\r\n                        } else if (lexeme == \"*\") {\r\n                            if (this._peekAhead() == \"/\") {\r\n                                this._advance();\r\n                                commentLevel--;\r\n                                if (commentLevel == 0) {\r\n                                    return true;\r\n                                }\r\n                            }\r\n                        } else if (lexeme == \"/\") {\r\n                            if (this._peekAhead() == \"*\") {\r\n                                this._advance();\r\n                                commentLevel++;\r\n                            }\r\n                        }\r\n                    }\r\n                    return true;\r\n                }\r\n            }\r\n\r\n            let matchToken = null;\r\n\r\n            for (; ;) {\r\n                let matchedToken = this._findToken(lexeme);\r\n\r\n                // The exception to \"longest lexeme\" rule is '>>'. In the case of 1>>2, it's a shift_right.\r\n                // In the case of array<vec4<f32>>, it's two greater_than's (one to close the vec4,\r\n                // and one to close the array).\r\n                // I don't know of a great way to resolve this, so '>>' is special-cased and if\r\n                // there was a less_than up to some number of tokens previously, and the token prior to\r\n                // that is a keyword that requires a '<', then it will be split into two greater_than's;\r\n                // otherwise it's a shift_right.\r\n                if (lexeme == \">\" && this._peekAhead() == \">\") {\r\n                    let foundLessThan = false;\r\n                    let ti = this._tokens.length - 1;\r\n                    for (let count = 0; count < 4 && ti >= 0; ++count, --ti) {\r\n                        if (this._tokens[ti]._type == Token.less_than) {\r\n                            if (ti > 0 && Token.template_types.indexOf(this._tokens[ti - 1]._type) != -1) {\r\n                                foundLessThan = true;\r\n                            }\r\n                            break;\r\n                        }\r\n                    }\r\n                    // If there was a less_than in the recent token history, then this is probably a\r\n                    // greater_than.\r\n                    if (foundLessThan) {\r\n                        this._addToken(matchedToken);\r\n                        return true;\r\n                    }\r\n                }\r\n\r\n                // The current lexeme may not match any rule, but some token types may be invalid for\r\n                // part of the string but valid after a few more characters.\r\n                // For example, 0x.5 is a hex_float_literal. But as it's being scanned,\r\n                // \"0\" is a int_literal, then \"0x\" is invalid. If we stopped there, it would return\r\n                // the int_literal \"0\", but that's incorrect. So if we look forward a few characters,\r\n                // we'd get \"0x.\", which is still invalid, followed by \"0x.5\" which is the correct\r\n                // hex_float_literal. So that means if we hit an non-matching string, we should look\r\n                // ahead up to two characters to see if the string starts matching a valid rule again.\r\n                if (!matchedToken) {\r\n                    let lookAheadLexeme = lexeme;\r\n                    let lookAhead = 0;\r\n                    const maxLookAhead = 2;\r\n                    for (let li = 0; li < maxLookAhead; ++li) {\r\n                        lookAheadLexeme += this._peekAhead(li);\r\n                        matchedToken = this._findToken(lookAheadLexeme);\r\n                        if (matchedToken) {\r\n                            lookAhead = li;\r\n                            break;\r\n                        }\r\n                    }\r\n\r\n                    if (!matchedToken) {\r\n                        if (!matchToken)\r\n                            return false;\r\n                        this._current--;\r\n                        this._addToken(matchToken);\r\n                        return true;\r\n                    }\r\n\r\n                    lexeme = lookAheadLexeme;\r\n                    this._current += lookAhead + 1;\r\n                }\r\n\r\n                matchToken = matchedToken;\r\n\r\n                if (this._isAtEnd())\r\n                    break;\r\n\r\n                lexeme += this._advance();\r\n            }\r\n\r\n            // We got to the end of the input stream. Then the token we've ready so far is it.\r\n            if (matchToken === null)\r\n                return false;\r\n\r\n            this._addToken(matchToken);\r\n            return true;\r\n        }\r\n\r\n        _findToken(lexeme) {\r\n            for (const name in Keyword) {\r\n                const token = Keyword[name];\r\n                if (this._match(lexeme, token.rule)) {\r\n                    return token;\r\n                }\r\n            }\r\n            for (const name in Token.Tokens) {\r\n                const token = Token.Tokens[name];\r\n                if (this._match(lexeme, token.rule)) {\r\n                    return token;\r\n                }\r\n            }\r\n            return null;\r\n        }\r\n\r\n        _match(lexeme, rule) {\r\n            if (typeof (rule) == \"string\") {\r\n                if (rule == lexeme) {\r\n                    return true;\r\n                }\r\n            } else {\r\n                // regex\r\n                const match = rule.exec(lexeme);\r\n                if (match && match.index == 0 && match[0] == lexeme)\r\n                    return true;\r\n            }\r\n            return false;\r\n        }\r\n\r\n        _isAtEnd() {\r\n            return this._current >= this._source.length;\r\n        }\r\n\r\n        _isWhitespace(c) {\r\n            return c == \" \" || c == \"\\t\" || c == \"\\r\";\r\n        }\r\n\r\n        _advance(amount) {\r\n            let c = this._source[this._current];\r\n            amount = amount || 0;\r\n            amount++;\r\n            this._current += amount;\r\n            return c;\r\n        }\r\n\r\n        _peekAhead(offset) {\r\n            offset = offset || 0;\r\n            if (this._current + offset >= this._source.length) return \"\\0\";\r\n            return this._source[this._current + offset];\r\n        }\r\n\r\n        _addToken(type) {\r\n            const text = this._source.substring(this._start, this._current);\r\n            this._tokens.push(new Token(type, text, this._line));\r\n        }\r\n    }\r\n\r\n    Token.WgslTokens = {\r\n        decimal_float_literal:\r\n            /((-?[0-9]*\\.[0-9]+|-?[0-9]+\\.[0-9]*)((e|E)(\\+|-)?[0-9]+)?f?)|(-?[0-9]+(e|E)(\\+|-)?[0-9]+f?)/,\r\n        hex_float_literal:\r\n            /-?0x((([0-9a-fA-F]*\\.[0-9a-fA-F]+|[0-9a-fA-F]+\\.[0-9a-fA-F]*)((p|P)(\\+|-)?[0-9]+f?)?)|([0-9a-fA-F]+(p|P)(\\+|-)?[0-9]+f?))/,\r\n        int_literal:\r\n            /-?0x[0-9a-fA-F]+|0|-?[1-9][0-9]*/,\r\n        uint_literal:\r\n            /0x[0-9a-fA-F]+u|0u|[1-9][0-9]*u/,\r\n        ident:\r\n            /[a-zA-Z][0-9a-zA-Z_]*/,\r\n        and:\r\n            '&',\r\n        and_and:\r\n            '&&',\r\n        arrow:\r\n            '->',\r\n        attr:\r\n            '@',\r\n        attr_left:\r\n            '[[',\r\n        attr_right:\r\n            ']]',\r\n        forward_slash:\r\n            '/',\r\n        bang:\r\n            '!',\r\n        bracket_left:\r\n            '[',\r\n        bracket_right:\r\n            ']',\r\n        brace_left:\r\n            '{',\r\n        brace_right:\r\n            '}',\r\n        colon:\r\n            ':',\r\n        comma:\r\n            ',',\r\n        equal:\r\n            '=',\r\n        equal_equal:\r\n            '==',\r\n        not_equal:\r\n            '!=',\r\n        greater_than:\r\n            '>',\r\n        greater_than_equal:\r\n            '>=',\r\n        shift_right:\r\n            '>>',\r\n        less_than:\r\n            '<',\r\n        less_than_equal:\r\n            '<=',\r\n        shift_left:\r\n            '<<',\r\n        modulo:\r\n            '%',\r\n        minus:\r\n            '-',\r\n        minus_minus:\r\n            '--',\r\n        period:\r\n            '.',\r\n        plus:\r\n            '+',\r\n        plus_plus:\r\n            '++',\r\n        or:\r\n            '|',\r\n        or_or:\r\n            '||',\r\n        paren_left:\r\n            '(',\r\n        paren_right:\r\n            ')',\r\n        semicolon:\r\n            ';',\r\n        star:\r\n            '*',\r\n        tilde:\r\n            '~',\r\n        underscore:\r\n            '_',\r\n        xor:\r\n            '^',\r\n\r\n        plus_equal:\r\n            '+=',\r\n        minus_equal:\r\n            '-=',\r\n        times_equal:\r\n            '*=',\r\n        division_equal:\r\n            '/=',\r\n        modulo_equal:\r\n            '%=',\r\n        and_equal:\r\n            '&=',\r\n        or_equal:\r\n            '|=',\r\n        xor_equal:\r\n            '^=',\r\n        shift_right_equal:\r\n            '>>=',\r\n        shift_left_equal:\r\n            '<<=',\r\n    };\r\n\r\n    Token.WgslKeywords = [\r\n        \"array\",\r\n        \"atomic\",\r\n        \"bool\",\r\n        \"f32\",\r\n        \"i32\",\r\n        \"mat2x2\",\r\n        \"mat2x3\",\r\n        \"mat2x4\",\r\n        \"mat3x2\",\r\n        \"mat3x3\",\r\n        \"mat3x4\",\r\n        \"mat4x2\",\r\n        \"mat4x3\",\r\n        \"mat4x4\",\r\n        \"ptr\",\r\n        \"sampler\",\r\n        \"sampler_comparison\",\r\n        \"struct\",\r\n        \"texture_1d\",\r\n        \"texture_2d\",\r\n        \"texture_2d_array\",\r\n        \"texture_3d\",\r\n        \"texture_cube\",\r\n        \"texture_cube_array\",\r\n        \"texture_multisampled_2d\",\r\n        \"texture_storage_1d\",\r\n        \"texture_storage_2d\",\r\n        \"texture_storage_2d_array\",\r\n        \"texture_storage_3d\",\r\n        \"texture_depth_2d\",\r\n        \"texture_depth_2d_array\",\r\n        \"texture_depth_cube\",\r\n        \"texture_depth_cube_array\",\r\n        \"texture_depth_multisampled_2d\",\r\n        \"u32\",\r\n        \"vec2\",\r\n        \"vec3\",\r\n        \"vec4\",\r\n        \"bitcast\",\r\n        \"block\",\r\n        \"break\",\r\n        \"case\",\r\n        \"continue\",\r\n        \"continuing\",\r\n        \"default\",\r\n        \"discard\",\r\n        \"else\",\r\n        \"elseif\",\r\n        \"enable\",\r\n        \"fallthrough\",\r\n        \"false\",\r\n        \"fn\",\r\n        \"for\",\r\n        \"function\",\r\n        \"if\",\r\n        \"let\",\r\n        \"const\",\r\n        \"loop\",\r\n        \"while\",\r\n        \"private\",\r\n        \"read\",\r\n        \"read_write\",\r\n        \"return\",\r\n        \"storage\",\r\n        \"switch\",\r\n        \"true\",\r\n        \"type\",\r\n        \"uniform\",\r\n        \"var\",\r\n        \"workgroup\",\r\n        \"write\",\r\n        \"r8unorm\",\r\n        \"r8snorm\",\r\n        \"r8uint\",\r\n        \"r8sint\",\r\n        \"r16uint\",\r\n        \"r16sint\",\r\n        \"r16float\",\r\n        \"rg8unorm\",\r\n        \"rg8snorm\",\r\n        \"rg8uint\",\r\n        \"rg8sint\",\r\n        \"r32uint\",\r\n        \"r32sint\",\r\n        \"r32float\",\r\n        \"rg16uint\",\r\n        \"rg16sint\",\r\n        \"rg16float\",\r\n        \"rgba8unorm\",\r\n        \"rgba8unorm_srgb\",\r\n        \"rgba8snorm\",\r\n        \"rgba8uint\",\r\n        \"rgba8sint\",\r\n        \"bgra8unorm\",\r\n        \"bgra8unorm_srgb\",\r\n        \"rgb10a2unorm\",\r\n        \"rg11b10float\",\r\n        \"rg32uint\",\r\n        \"rg32sint\",\r\n        \"rg32float\",\r\n        \"rgba16uint\",\r\n        \"rgba16sint\",\r\n        \"rgba16float\",\r\n        \"rgba32uint\",\r\n        \"rgba32sint\",\r\n        \"rgba32float\",\r\n        \"static_assert\"\r\n    ];\r\n\r\n    Token.WgslReserved = [\r\n        \"asm\",\r\n        \"bf16\",\r\n        \"do\",\r\n        \"enum\",\r\n        \"f16\",\r\n        \"f64\",\r\n        \"handle\",\r\n        \"i8\",\r\n        \"i16\",\r\n        \"i64\",\r\n        \"mat\",\r\n        \"premerge\",\r\n        \"regardless\",\r\n        \"typedef\",\r\n        \"u8\",\r\n        \"u16\",\r\n        \"u64\",\r\n        \"unless\",\r\n        \"using\",\r\n        \"vec\",\r\n        \"void\"\r\n    ];\r\n\r\n    function _InitTokens() {\r\n        Token.Tokens = {};\r\n        for (let token in Token.WgslTokens) {\r\n            Token.Tokens[token] = {\r\n                name: token,\r\n                type: \"token\",\r\n                rule: Token.WgslTokens[token],\r\n                toString: function () { return token; }\r\n            };\r\n            Token[token] = Token.Tokens[token];\r\n        }\r\n\r\n        for (let i = 0, l = Token.WgslKeywords.length; i < l; ++i) {\r\n            Keyword[Token.WgslKeywords[i]] = {\r\n                name: Token.WgslKeywords[i],\r\n                type: \"keyword\",\r\n                rule: Token.WgslKeywords[i],\r\n                toString: function () { return Token.WgslKeywords[i]; }\r\n            };\r\n        }\r\n\r\n        for (let i = 0, l = Token.WgslReserved.length; i < l; ++i) {\r\n            Keyword[Token.WgslReserved[i]] = {\r\n                name: Token.WgslReserved[i],\r\n                type: \"reserved\",\r\n                rule: Token.WgslReserved[i],\r\n                toString: function () { return Token.WgslReserved[i]; }\r\n            };\r\n        }\r\n\r\n        // WGSL grammar has a few keywords that have different token names than the strings they\r\n        // represent. Aliasing them here.\r\n\r\n        Keyword.int32 = Keyword.i32;\r\n        Keyword.uint32 = Keyword.u32;\r\n        Keyword.float32 = Keyword.f32;\r\n        Keyword.pointer = Keyword.ptr;\r\n\r\n        // The grammar has a few rules where the rule can match to any one of a given set of keywords\r\n        // or tokens. Defining those here.\r\n\r\n        Token.storage_class = [\r\n            Keyword.function,\r\n            Keyword.private,\r\n            Keyword.workgroup,\r\n            Keyword.uniform,\r\n            Keyword.storage\r\n        ];\r\n\r\n        Token.access_mode = [\r\n            Keyword.read,\r\n            Keyword.write,\r\n            Keyword.read_write\r\n        ];\r\n\r\n        Token.sampler_type = [\r\n            Keyword.sampler,\r\n            Keyword.sampler_comparison\r\n        ];\r\n\r\n        Token.sampled_texture_type = [\r\n            Keyword.texture_1d,\r\n            Keyword.texture_2d,\r\n            Keyword.texture_2d_array,\r\n            Keyword.texture_3d,\r\n            Keyword.texture_cube,\r\n            Keyword.texture_cube_array\r\n        ];\r\n\r\n        Token.multisampled_texture_type = [\r\n            Keyword.texture_multisampled_2d\r\n        ];\r\n\r\n        Token.storage_texture_type = [\r\n            Keyword.texture_storage_1d,\r\n            Keyword.texture_storage_2d,\r\n            Keyword.texture_storage_2d_array,\r\n            Keyword.texture_storage_3d\r\n        ];\r\n\r\n        Token.depth_texture_type = [\r\n            Keyword.texture_depth_2d,\r\n            Keyword.texture_depth_2d_array,\r\n            Keyword.texture_depth_cube,\r\n            Keyword.texture_depth_cube_array,\r\n            Keyword.texture_depth_multisampled_2d\r\n        ];\r\n\r\n        Token.any_texture_type = [\r\n            ...Token.sampled_texture_type,\r\n            ...Token.multisampled_texture_type,\r\n            ...Token.storage_texture_type,\r\n            ...Token.depth_texture_type\r\n        ];\r\n\r\n        Token.texel_format = [\r\n            Keyword.r8unorm,\r\n            Keyword.r8snorm,\r\n            Keyword.r8uint,\r\n            Keyword.r8sint,\r\n            Keyword.r16uint,\r\n            Keyword.r16sint,\r\n            Keyword.r16float,\r\n            Keyword.rg8unorm,\r\n            Keyword.rg8snorm,\r\n            Keyword.rg8uint,\r\n            Keyword.rg8sint,\r\n            Keyword.r32uint,\r\n            Keyword.r32sint,\r\n            Keyword.r32float,\r\n            Keyword.rg16uint,\r\n            Keyword.rg16sint,\r\n            Keyword.rg16float,\r\n            Keyword.rgba8unorm,\r\n            Keyword.rgba8unorm_srgb,\r\n            Keyword.rgba8snorm,\r\n            Keyword.rgba8uint,\r\n            Keyword.rgba8sint,\r\n            Keyword.bgra8unorm,\r\n            Keyword.bgra8unorm_srgb,\r\n            Keyword.rgb10a2unorm,\r\n            Keyword.rg11b10float,\r\n            Keyword.rg32uint,\r\n            Keyword.rg32sint,\r\n            Keyword.rg32float,\r\n            Keyword.rgba16uint,\r\n            Keyword.rgba16sint,\r\n            Keyword.rgba16float,\r\n            Keyword.rgba32uint,\r\n            Keyword.rgba32sint,\r\n            Keyword.rgba32float\r\n        ];\r\n\r\n        Token.const_literal = [\r\n            Token.int_literal,\r\n            Token.uint_literal,\r\n            Token.decimal_float_literal,\r\n            Token.hex_float_literal,\r\n            Keyword.true,\r\n            Keyword.false\r\n        ];\r\n\r\n        Token.literal_or_ident = [\r\n            Token.ident,\r\n            Token.int_literal,\r\n            Token.uint_literal,\r\n            Token.decimal_float_literal,\r\n            Token.hex_float_literal,\r\n        ];\r\n\r\n        Token.element_count_expression = [\r\n            Token.int_literal,\r\n            Token.uint_literal,\r\n            Token.ident\r\n        ];\r\n\r\n        Token.template_types = [\r\n            Keyword.vec2,\r\n            Keyword.vec3,\r\n            Keyword.vec4,\r\n            Keyword.mat2x2,\r\n            Keyword.mat2x3,\r\n            Keyword.mat2x4,\r\n            Keyword.mat3x2,\r\n            Keyword.mat3x3,\r\n            Keyword.mat3x4,\r\n            Keyword.mat4x2,\r\n            Keyword.mat4x3,\r\n            Keyword.mat4x4,\r\n            Keyword.atomic,\r\n\r\n            Keyword.bitcast,\r\n\r\n            ...Token.any_texture_type,\r\n        ];\r\n\r\n        // The grammar calls out 'block', but attribute grammar is defined to use a 'ident'.\r\n        // The attribute grammar should be ident | block.\r\n        Token.attribute_name = [\r\n            Token.ident,\r\n            Keyword.block,\r\n        ];\r\n\r\n        Token.assignment_operators = [\r\n            Token.equal,\r\n            Token.plus_equal,\r\n            Token.minus_equal,\r\n            Token.times_equal,\r\n            Token.division_equal,\r\n            Token.modulo_equal,\r\n            Token.and_equal,\r\n            Token.or_equal,\r\n            Token.xor_equal,\r\n            Token.shift_right_equal,\r\n            Token.shift_left_equal\r\n        ];\r\n\r\n        Token.increment_operators = [\r\n            Token.plus_plus,\r\n            Token.minus_minus\r\n        ];\r\n    }\r\n    _InitTokens();\r\n\r\n    /**\r\n     * @author Brendan Duncan / https://github.com/brendan-duncan\r\n     */\r\n\r\n    class AST {\r\n        constructor(type, options) {\r\n            this._type = type;\r\n            if (options) {\r\n                for (let option in options) {\r\n                    this[option] = options[option];\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    class WgslParser {\r\n        constructor() {\r\n            this._tokens = [];\r\n            this._current = 0;\r\n        }\r\n\r\n        parse(tokensOrCode) {\r\n            this._initialize(tokensOrCode);\r\n\r\n            let statements = [];\r\n            while (!this._isAtEnd()) {\r\n                const statement = this._global_decl_or_directive();\r\n                if (!statement)\r\n                    break;\r\n                statements.push(statement);\r\n            }\r\n            return statements;\r\n        }\r\n\r\n        _initialize(tokensOrCode) {\r\n            if (tokensOrCode) {\r\n                if (typeof (tokensOrCode) == \"string\") {\r\n                    const scanner = new WgslScanner(tokensOrCode);\r\n                    this._tokens = scanner.scanTokens();\r\n                } else {\r\n                    this._tokens = tokensOrCode;\r\n                }\r\n            } else {\r\n                this._tokens = [];\r\n            }\r\n            this._current = 0;\r\n        }\r\n\r\n        _error(token, message) {\r\n            console.error(token, message);\r\n            return { token, message, toString: function () { return `${message}`; } };\r\n        }\r\n\r\n        _isAtEnd() { return this._current >= this._tokens.length || this._peek()._type == Token.EOF; }\r\n\r\n        _match(types) {\r\n            if (types.length === undefined) {\r\n                if (this._check(types)) {\r\n                    this._advance();\r\n                    return true;\r\n                }\r\n                return false;\r\n            }\r\n\r\n            for (let i = 0, l = types.length; i < l; ++i) {\r\n                const type = types[i];\r\n                if (this._check(type)) {\r\n                    this._advance();\r\n                    return true;\r\n                }\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        _consume(types, message) {\r\n            if (this._check(types)) return this._advance();\r\n            throw this._error(this._peek(), message);\r\n        }\r\n\r\n        _check(types) {\r\n            if (this._isAtEnd()) return false;\r\n            if (types.length !== undefined) {\r\n                let t = this._peek()._type;\r\n                return types.indexOf(t) != -1;\r\n            }\r\n            return this._peek()._type == types;\r\n        }\r\n\r\n        _advance() {\r\n            if (!this._isAtEnd()) this._current++;\r\n            return this._previous();\r\n        }\r\n\r\n        _peek() {\r\n            return this._tokens[this._current];\r\n        }\r\n\r\n        _previous() {\r\n            return this._tokens[this._current - 1];\r\n        }\r\n\r\n        _global_decl_or_directive() {\r\n            // semicolon\r\n            // global_variable_decl semicolon\r\n            // global_constant_decl semicolon\r\n            // type_alias semicolon\r\n            // struct_decl\r\n            // function_decl\r\n            // enable_directive\r\n\r\n            // Ignore any stand-alone semicolons\r\n            while (this._match(Token.semicolon) && !this._isAtEnd());\r\n\r\n            if (this._match(Keyword.type)) {\r\n                const type = this._type_alias();\r\n                this._consume(Token.semicolon, \"Expected ';'\");\r\n                return type;\r\n            }\r\n\r\n            if (this._match(Keyword.enable)) {\r\n                const enable = this._enable_directive();\r\n                this._consume(Token.semicolon, \"Expected ';'\");\r\n                return enable;\r\n            }\r\n\r\n            // The following statements have an optional attribute*\r\n            const attrs = this._attribute();\r\n\r\n            if (this._check(Keyword.var)) {\r\n                const _var = this._global_variable_decl();\r\n                _var.attributes = attrs;\r\n                this._consume(Token.semicolon, \"Expected ';'.\");\r\n                return _var;\r\n            }\r\n\r\n            if (this._check(Keyword.let) || this._check(Keyword.const)) {\r\n                const _let = this._global_constant_decl();\r\n                _let.attributes = attrs;\r\n                this._consume(Token.semicolon, \"Expected ';'.\");\r\n                return _let;\r\n            }\r\n\r\n            if (this._check(Keyword.struct)) {\r\n                const _struct = this._struct_decl();\r\n                _struct.attributes = attrs;\r\n                return _struct;\r\n            }\r\n\r\n            if (this._check(Keyword.fn)) {\r\n                const _fn = this._function_decl();\r\n                _fn.attributes = attrs;\r\n                return _fn;\r\n            }\r\n\r\n            return null;\r\n        }\r\n\r\n        _function_decl() {\r\n            // attribute* function_header compound_statement\r\n            // function_header: fn ident paren_left param_list? paren_right (arrow attribute* type_decl)?\r\n            if (!this._match(Keyword.fn))\r\n                return null;\r\n\r\n            const name = this._consume(Token.ident, \"Expected function name.\").toString();\r\n\r\n            this._consume(Token.paren_left, \"Expected '(' for function arguments.\");\r\n\r\n            const args = [];\r\n            if (!this._check(Token.paren_right)) {\r\n                do {\r\n                    if (this._check(Token.paren_right))\r\n                        break;\r\n                    const argAttrs = this._attribute();\r\n\r\n                    const name = this._consume(Token.ident, \"Expected argument name.\").toString();\r\n\r\n                    this._consume(Token.colon, \"Expected ':' for argument type.\");\r\n\r\n                    const typeAttrs = this._attribute();\r\n                    const type = this._type_decl();\r\n                    type.attributes = typeAttrs;\r\n\r\n                    args.push(new AST(\"arg\", { name, attributes: argAttrs, type }));\r\n                } while (this._match(Token.comma));\r\n            }\r\n\r\n            this._consume(Token.paren_right, \"Expected ')' after function arguments.\");\r\n\r\n            let _return = null;\r\n            if (this._match(Token.arrow)) {\r\n                const attrs = this._attribute();\r\n                _return = this._type_decl();\r\n                _return.attributes = attrs;\r\n            }\r\n\r\n            const body = this._compound_statement();\r\n\r\n            return new AST(\"function\", { name, args, return: _return, body });\r\n        }\r\n\r\n        _compound_statement() {\r\n            // brace_left statement* brace_right\r\n            const statements = [];\r\n            this._consume(Token.brace_left, \"Expected '{' for block.\");\r\n            while (!this._check(Token.brace_right)) {\r\n                const statement = this._statement();\r\n                if (statement)\r\n                    statements.push(statement);\r\n            }\r\n            this._consume(Token.brace_right, \"Expected '}' for block.\");\r\n\r\n            return statements;\r\n        }\r\n\r\n        _statement() {\r\n            // semicolon\r\n            // return_statement semicolon\r\n            // if_statement\r\n            // switch_statement\r\n            // loop_statement\r\n            // for_statement\r\n            // func_call_statement semicolon\r\n            // variable_statement semicolon\r\n            // break_statement semicolon\r\n            // continue_statement semicolon\r\n            // discard semicolon\r\n            // assignment_statement semicolon\r\n            // compound_statement\r\n            // increment_statement semicolon\r\n            // decrement_statement semicolon\r\n            // static_assert_statement semicolon\r\n\r\n            // Ignore any stand-alone semicolons\r\n            while (this._match(Token.semicolon) && !this._isAtEnd());\r\n\r\n            if (this._check(Keyword.if))\r\n                return this._if_statement();\r\n\r\n            if (this._check(Keyword.switch))\r\n                return this._switch_statement();\r\n\r\n            if (this._check(Keyword.loop))\r\n                return this._loop_statement();\r\n\r\n            if (this._check(Keyword.for))\r\n                return this._for_statement();\r\n\r\n            if (this._check(Keyword.while))\r\n                return this._while_statement();\r\n\r\n            if (this._check(Keyword.static_assert))\r\n                return this._static_assert_statement();\r\n\r\n            if (this._check(Token.brace_left))\r\n                return this._compound_statement();\r\n\r\n            let result = null;\r\n            if (this._check(Keyword.return))\r\n                result = this._return_statement();\r\n            else if (this._check([Keyword.var, Keyword.let, Keyword.const]))\r\n                result = this._variable_statement();\r\n            else if (this._match(Keyword.discard))\r\n                result = new AST(\"discard\");\r\n            else if (this._match(Keyword.break))\r\n                result = new AST(\"break\");\r\n            else if (this._match(Keyword.continue))\r\n                result = new AST(\"continue\");\r\n            else\r\n                result = this._increment_decrement_statement() || this._func_call_statement() || this._assignment_statement();\r\n\r\n            if (result != null)\r\n                this._consume(Token.semicolon, \"Expected ';' after statement.\");\r\n\r\n            return result;\r\n        }\r\n\r\n        _static_assert_statement() {\r\n            if (!this._match(Keyword.static_assert))\r\n                return null;\r\n            let expression = this._optional_paren_expression();\r\n            return new AST(\"static_assert\", { expression });\r\n        }\r\n\r\n        _while_statement() {\r\n            if (!this._match(Keyword.while))\r\n                return null;\r\n            let condition = this._optional_paren_expression();\r\n            const block = this._compound_statement();\r\n            return new AST(\"while\", { condition, block });\r\n        }\r\n\r\n        _for_statement() {\r\n            // for paren_left for_header paren_right compound_statement\r\n            if (!this._match(Keyword.for))\r\n                return null;\r\n\r\n            this._consume(Token.paren_left, \"Expected '('.\");\r\n\r\n            // for_header: (variable_statement assignment_statement func_call_statement)? semicolon short_circuit_or_expression? semicolon (assignment_statement func_call_statement)?\r\n            const init = !this._check(Token.semicolon) ? this._for_init() : null;\r\n            this._consume(Token.semicolon, \"Expected ';'.\");\r\n            const condition = !this._check(Token.semicolon) ? this._short_circuit_or_expression() : null;\r\n            this._consume(Token.semicolon, \"Expected ';'.\");\r\n            const increment = !this._check(Token.paren_right) ? this._for_increment() : null;\r\n\r\n            this._consume(Token.paren_right, \"Expected ')'.\");\r\n\r\n            const body = this._compound_statement();\r\n\r\n            return new AST(\"for\", { init, condition, increment, body });\r\n        }\r\n\r\n        _for_init() {\r\n            // (variable_statement assignment_statement func_call_statement)?\r\n            return this._variable_statement() || this._func_call_statement() || this._assignment_statement();\r\n        }\r\n\r\n        _for_increment() {\r\n            // (assignment_statement func_call_statement)?\r\n            return this._increment_decrement_statement() || this._func_call_statement() || this._assignment_statement();\r\n        }\r\n\r\n        _variable_statement() {\r\n            // variable_decl\r\n            // variable_decl equal short_circuit_or_expression\r\n            // let (ident variable_ident_decl) equal short_circuit_or_expression\r\n            // const (ident variable_ident_decl) equal short_circuit_or_expression\r\n            if (this._check(Keyword.var)) {\r\n                const _var = this._variable_decl();\r\n                let value = null;\r\n                if (this._match(Token.equal))\r\n                    value = this._short_circuit_or_expression();\r\n\r\n                return new AST(\"var\", { var: _var, value });\r\n            }\r\n\r\n            if (this._match(Keyword.let)) {\r\n                const name = this._consume(Token.ident, \"Expected name for let.\").toString();\r\n                let type = null;\r\n                if (this._match(Token.colon)) {\r\n                    const typeAttrs = this._attribute();\r\n                    type = this._type_decl();\r\n                    type.attributes = typeAttrs;\r\n                }\r\n                this._consume(Token.equal, \"Expected '=' for let.\");\r\n                const value = this._short_circuit_or_expression();\r\n                return new AST(\"let\", { name, type, value });\r\n            }\r\n\r\n            if (this._match(Keyword.const)) {\r\n                const name = this._consume(Token.ident, \"Expected name for const.\").toString();\r\n                let type = null;\r\n                if (this._match(Token.colon)) {\r\n                    const typeAttrs = this._attribute();\r\n                    type = this._type_decl();\r\n                    type.attributes = typeAttrs;\r\n                }\r\n                this._consume(Token.equal, \"Expected '=' for const.\");\r\n                const value = this._short_circuit_or_expression();\r\n                return new AST(\"const\", { name, type, value });\r\n            }\r\n\r\n            return null;\r\n        }\r\n\r\n        _increment_decrement_statement() {\r\n            const savedPos = this._current;\r\n\r\n            const _var = this._unary_expression();\r\n            if (_var == null)\r\n                return null;\r\n\r\n            if (!this._check(Token.increment_operators)) {\r\n                this._current = savedPos;\r\n                return null;\r\n            }\r\n\r\n            const type = this._consume(Token.increment_operators, \"Expected increment operator\");\r\n\r\n            return new AST(\"increment\", { type, var: _var });\r\n        }\r\n\r\n        _assignment_statement() {\r\n            // (unary_expression underscore) equal short_circuit_or_expression\r\n            let _var = null;\r\n\r\n            if (this._check(Token.brace_right))\r\n                return null;\r\n\r\n            let isUnderscore = this._match(Token.underscore);\r\n            if (!isUnderscore)\r\n                _var = this._unary_expression();\r\n\r\n            if (!isUnderscore && _var == null)\r\n                return null;\r\n\r\n            const type = this._consume(Token.assignment_operators, \"Expected assignment operator.\");\r\n\r\n            const value = this._short_circuit_or_expression();\r\n\r\n            return new AST(\"assign\", { type, var: _var, value });\r\n        }\r\n\r\n        _func_call_statement() {\r\n            // ident argument_expression_list\r\n            if (!this._check(Token.ident))\r\n                return null;\r\n\r\n            const savedPos = this._current;\r\n            const name = this._consume(Token.ident, \"Expected function name.\");\r\n            const args = this._argument_expression_list();\r\n\r\n            if (args === null) {\r\n                this._current = savedPos;\r\n                return null;\r\n            }\r\n\r\n            return new AST(\"call\", { name, args });\r\n        }\r\n\r\n        _loop_statement() {\r\n            // loop brace_left statement* continuing_statement? brace_right\r\n            if (!this._match(Keyword.loop))\r\n                return null;\r\n\r\n            this._consume(Token.brace_left, \"Expected '{' for loop.\");\r\n\r\n            // statement*\r\n            const statements = [];\r\n            let statement = this._statement();\r\n            while (statement !== null) {\r\n                statements.push(statement);\r\n                statement = this._statement();\r\n            }\r\n\r\n            // continuing_statement: continuing compound_statement\r\n            let continuing = null;\r\n            if (this._match(Keyword.continuing))\r\n                continuing = this._compound_statement();\r\n\r\n            this._consume(Token.brace_right, \"Expected '}' for loop.\");\r\n\r\n            return new AST(\"loop\", { statements, continuing });\r\n        }\r\n\r\n        _switch_statement() {\r\n            // switch optional_paren_expression brace_left switch_body+ brace_right\r\n            if (!this._match(Keyword.switch))\r\n                return null;\r\n\r\n            const condition = this._optional_paren_expression();\r\n            this._consume(Token.brace_left);\r\n            const body = this._switch_body();\r\n            if (body == null || body.length == 0)\r\n                throw this._error(this._previous(), \"Expected 'case' or 'default'.\");\r\n            this._consume(Token.brace_right);\r\n            return new AST(\"switch\", { condition, body });\r\n        }\r\n\r\n        _switch_body() {\r\n            // case case_selectors colon brace_left case_body? brace_right\r\n            // default colon brace_left case_body? brace_right\r\n            const cases = [];\r\n            if (this._match(Keyword.case)) {\r\n                this._consume(Keyword.case);\r\n                const selector = this._case_selectors();\r\n                this._consume(Token.colon, \"Exected ':' for switch case.\");\r\n                this._consume(Token.brace_left, \"Exected '{' for switch case.\");\r\n                const body = this._case_body();\r\n                this._consume(Token.brace_right, \"Exected '}' for switch case.\");\r\n                cases.push(new AST(\"case\", { selector, body }));\r\n            }\r\n\r\n            if (this._match(Keyword.default)) {\r\n                this._consume(Token.colon, \"Exected ':' for switch default.\");\r\n                this._consume(Token.brace_left, \"Exected '{' for switch default.\");\r\n                const body = this._case_body();\r\n                this._consume(Token.brace_right, \"Exected '}' for switch default.\");\r\n                cases.push(new AST(\"default\", { body }));\r\n            }\r\n\r\n            if (this._check([Keyword.default, Keyword.case])) {\r\n                const _cases = this._switch_body();\r\n                cases.push(_cases[0]);\r\n            }\r\n\r\n            return cases;\r\n        }\r\n\r\n        _case_selectors() {\r\n            // const_literal (comma const_literal)* comma?\r\n            const selectors = [this._consume(Token.const_literal, \"Expected constant literal\").toString()];\r\n            while (this._match(Token.comma)) {\r\n                selectors.push(this._consume(Token.const_literal, \"Expected constant literal\").toString());\r\n            }\r\n            return selectors;\r\n        }\r\n\r\n        _case_body() {\r\n            // statement case_body?\r\n            // fallthrough semicolon\r\n            if (this._match(Keyword.fallthrough)) {\r\n                this._consume(Token.semicolon);\r\n                return [];\r\n            }\r\n\r\n            const statement = this._statement();\r\n            if (statement == null)\r\n                return [];\r\n\r\n            const nextStatement = this._case_body();\r\n            if (nextStatement.length == 0)\r\n                return [statement];\r\n\r\n            return [statement, nextStatement[0]];\r\n        }\r\n\r\n        _if_statement() {\r\n            // if optional_paren_expression compound_statement elseif_statement? else_statement?\r\n            if (!this._match(Keyword.if))\r\n                return null;\r\n\r\n            const condition = this._optional_paren_expression();\r\n            const block = this._compound_statement();\r\n\r\n            let elseif = null;\r\n            if (this._match(Keyword.elseif))\r\n                elseif = this._elseif_statement();\r\n\r\n            let _else = null;\r\n            if (this._match(Keyword.else))\r\n                _else = this._compound_statement();\r\n\r\n            return new AST(\"if\", { condition, block, elseif, else: _else });\r\n        }\r\n\r\n        _elseif_statement() {\r\n            // else_if optional_paren_expression compound_statement elseif_statement?\r\n            const elseif = [];\r\n            const condition = this._optional_paren_expression();\r\n            const block = this._compound_statement();\r\n            elseif.push(new AST(\"elseif\", { condition, block }));\r\n            if (this._match(Keyword.elseif))\r\n                elseif.push(this._elseif_statement()[0]);\r\n            return elseif;\r\n        }\r\n\r\n        _return_statement() {\r\n            // return short_circuit_or_expression?\r\n            if (!this._match(Keyword.return))\r\n                return null;\r\n            const value = this._short_circuit_or_expression();\r\n            return new AST(\"return\", { value: value });\r\n        }\r\n\r\n        _short_circuit_or_expression() {\r\n            // short_circuit_and_expression\r\n            // short_circuit_or_expression or_or short_circuit_and_expression\r\n            let expr = this._short_circuit_and_expr();\r\n            while (this._match(Token.or_or)) {\r\n                expr = new AST(\"compareOp\", {\r\n                    operator: this._previous().toString(),\r\n                    left: expr,\r\n                    right: this._short_circuit_and_expr()\r\n                });\r\n            }\r\n            return expr;\r\n        }\r\n\r\n        _short_circuit_and_expr() {\r\n            // inclusive_or_expression\r\n            // short_circuit_and_expression and_and inclusive_or_expression\r\n            let expr = this._inclusive_or_expression();\r\n            while (this._match(Token.and_and)) {\r\n                expr = new AST(\"compareOp\", {\r\n                    operator: this._previous().toString(),\r\n                    left: expr,\r\n                    right: this._inclusive_or_expression()\r\n                });\r\n            }\r\n            return expr;\r\n        }\r\n\r\n        _inclusive_or_expression() {\r\n            // exclusive_or_expression\r\n            // inclusive_or_expression or exclusive_or_expression\r\n            let expr = this._exclusive_or_expression();\r\n            while (this._match(Token.or)) {\r\n                expr = new AST(\"binaryOp\", {\r\n                    operator: this._previous().toString(),\r\n                    left: expr,\r\n                    right: this._exclusive_or_expression()\r\n                });\r\n            }\r\n            return expr;\r\n        }\r\n\r\n        _exclusive_or_expression() {\r\n            // and_expression\r\n            // exclusive_or_expression xor and_expression\r\n            let expr = this._and_expression();\r\n            while (this._match(Token.xor)) {\r\n                expr = new AST(\"binaryOp\", {\r\n                    operator: this._previous().toString(),\r\n                    left: expr,\r\n                    right: this._and_expression()\r\n                });\r\n            }\r\n            return expr;\r\n        }\r\n\r\n        _and_expression() {\r\n            // equality_expression\r\n            // and_expression and equality_expression\r\n            let expr = this._equality_expression();\r\n            while (this._match(Token.and)) {\r\n                expr = new AST(\"binaryOp\", {\r\n                    operator: this._previous().toString(),\r\n                    left: expr,\r\n                    right: this._equality_expression()\r\n                });\r\n            }\r\n            return expr;\r\n        }\r\n\r\n        _equality_expression() {\r\n            // relational_expression\r\n            // relational_expression equal_equal relational_expression\r\n            // relational_expression not_equal relational_expression\r\n            const expr = this._relational_expression();\r\n            if (this._match([Token.equal_equal, Token.not_equal])) {\r\n                return new AST(\"compareOp\", {\r\n                    operator: this._previous().toString(),\r\n                    left: expr,\r\n                    right: this._relational_expression()\r\n                });\r\n            }\r\n            return expr;\r\n        }\r\n\r\n        _relational_expression() {\r\n            // shift_expression\r\n            // relational_expression less_than shift_expression\r\n            // relational_expression greater_than shift_expression\r\n            // relational_expression less_than_equal shift_expression\r\n            // relational_expression greater_than_equal shift_expression\r\n            let expr = this._shift_expression();\r\n            while (this._match([Token.less_than, Token.greater_than, Token.less_than_equal,\r\n            Token.greater_than_equal])) {\r\n                expr = new AST(\"compareOp\", {\r\n                    operator: this._previous().toString(),\r\n                    left: expr,\r\n                    right: this._shift_expression()\r\n                });\r\n            }\r\n            return expr;\r\n        }\r\n\r\n        _shift_expression() {\r\n            // additive_expression\r\n            // shift_expression shift_left additive_expression\r\n            // shift_expression shift_right additive_expression\r\n            let expr = this._additive_expression();\r\n            while (this._match([Token.shift_left, Token.shift_right])) {\r\n                expr = new AST(\"binaryOp\", {\r\n                    operator: this._previous().toString(),\r\n                    left: expr,\r\n                    right: this._additive_expression()\r\n                });\r\n            }\r\n            return expr;\r\n        }\r\n\r\n        _additive_expression() {\r\n            // multiplicative_expression\r\n            // additive_expression plus multiplicative_expression\r\n            // additive_expression minus multiplicative_expression\r\n            let expr = this._multiplicative_expression();\r\n            while (this._match([Token.plus, Token.minus])) {\r\n                expr = new AST(\"binaryOp\", {\r\n                    operator: this._previous().toString(),\r\n                    left: expr,\r\n                    right: this._multiplicative_expression()\r\n                });\r\n            }\r\n            return expr;\r\n        }\r\n\r\n        _multiplicative_expression() {\r\n            // unary_expression\r\n            // multiplicative_expression star unary_expression\r\n            // multiplicative_expression forward_slash unary_expression\r\n            // multiplicative_expression modulo unary_expression\r\n            let expr = this._unary_expression();\r\n            while (this._match([Token.star, Token.forward_slash, Token.modulo])) {\r\n                expr = new AST(\"binaryOp\", {\r\n                    operator: this._previous().toString(),\r\n                    left: expr,\r\n                    right: this._unary_expression()\r\n                });\r\n            }\r\n            return expr;\r\n        }\r\n\r\n        _unary_expression() {\r\n            // singular_expression\r\n            // minus unary_expression\r\n            // bang unary_expression\r\n            // tilde unary_expression\r\n            // star unary_expression\r\n            // and unary_expression\r\n            if (this._match([Token.minus, Token.bang, Token.tilde, Token.star, Token.and])) {\r\n                return new AST(\"unaryOp\", {\r\n                    operator: this._previous().toString(), right: this._unary_expression()\r\n                });\r\n            }\r\n            return this._singular_expression();\r\n        }\r\n\r\n        _singular_expression() {\r\n            // primary_expression postfix_expression ?\r\n            const expr = this._primary_expression();\r\n            const p = this._postfix_expression();\r\n            if (p)\r\n                expr.postfix = p;\r\n            return expr;\r\n        }\r\n\r\n        _postfix_expression() {\r\n            // bracket_left short_circuit_or_expression bracket_right postfix_expression?\r\n            if (this._match(Token.bracket_left)) {\r\n                const expr = this._short_circuit_or_expression();\r\n                this._consume(Token.bracket_right, \"Expected ']'.\");\r\n                const p = this._postfix_expression();\r\n                if (p)\r\n                    expr.postfix = p;\r\n                return expr;\r\n            }\r\n\r\n            // period ident postfix_expression?\r\n            if (this._match(Token.period)) {\r\n                const name = this._consume(Token.ident, \"Expected member name.\");\r\n                const p = this._postfix_expression();\r\n                if (p)\r\n                    name.postfix = p;\r\n                return name;\r\n            }\r\n\r\n            return null;\r\n        }\r\n\r\n        _primary_expression() {\r\n            // ident argument_expression_list?\r\n            if (this._match(Token.ident)) {\r\n                const name = this._previous().toString();\r\n                if (this._check(Token.paren_left)) {\r\n                    const args = this._argument_expression_list();\r\n                    return new AST(\"call_expr\", { name, args });\r\n                }\r\n                return new AST(\"variable_expr\", { name });\r\n            }\r\n\r\n            // const_literal\r\n            if (this._match(Token.const_literal)) {\r\n                return new AST(\"literal_expr\", { value: this._previous().toString() });\r\n            }\r\n\r\n            // paren_expression\r\n            if (this._check(Token.paren_left)) {\r\n                return this._paren_expression();\r\n            }\r\n\r\n            // bitcast less_than type_decl greater_than paren_expression\r\n            if (this._match(Keyword.bitcast)) {\r\n                this._consume(Token.less_than, \"Expected '<'.\");\r\n                const type = this._type_decl();\r\n                this._consume(Token.greater_than, \"Expected '>'.\");\r\n                const value = this._paren_expression();\r\n                return new AST(\"bitcast_expr\", { type, value });\r\n            }\r\n\r\n            // type_decl argument_expression_list\r\n            const type = this._type_decl();\r\n            const args = this._argument_expression_list();\r\n            return new AST(\"typecast_expr\", { type, args });\r\n        }\r\n\r\n        _argument_expression_list() {\r\n            // paren_left ((short_circuit_or_expression comma)* short_circuit_or_expression comma?)? paren_right\r\n            if (!this._match(Token.paren_left))\r\n                return null;\r\n\r\n            const args = [];\r\n            do {\r\n                if (this._check(Token.paren_right))\r\n                    break;\r\n                const arg = this._short_circuit_or_expression();\r\n                args.push(arg);\r\n            } while (this._match(Token.comma));\r\n            this._consume(Token.paren_right, \"Expected ')' for agument list\");\r\n\r\n            return args;\r\n        }\r\n\r\n        _optional_paren_expression() {\r\n            // [paren_left] short_circuit_or_expression [paren_right]\r\n            this._match(Token.paren_left);\r\n            const expr = this._short_circuit_or_expression();\r\n            this._match(Token.paren_right);\r\n            return new AST(\"grouping_expr\", { contents: expr });\r\n        }\r\n\r\n        _paren_expression() {\r\n            // paren_left short_circuit_or_expression paren_right\r\n            this._consume(Token.paren_left, \"Expected '('.\");\r\n            const expr = this._short_circuit_or_expression();\r\n            this._consume(Token.paren_right, \"Expected ')'.\");\r\n            return new AST(\"grouping_expr\", { contents: expr });\r\n        }\r\n\r\n        _struct_decl() {\r\n            // attribute* struct ident struct_body_decl\r\n            if (!this._match(Keyword.struct))\r\n                return null;\r\n\r\n            const name = this._consume(Token.ident, \"Expected name for struct.\").toString();\r\n\r\n            // struct_body_decl: brace_left (struct_member comma)* struct_member comma? brace_right\r\n            this._consume(Token.brace_left, \"Expected '{' for struct body.\");\r\n            const members = [];\r\n            while (!this._check(Token.brace_right)) {\r\n                // struct_member: attribute* variable_ident_decl\r\n                const memberAttrs = this._attribute();\r\n\r\n                const memberName = this._consume(Token.ident, \"Expected variable name.\").toString();\r\n\r\n                this._consume(Token.colon, \"Expected ':' for struct member type.\");\r\n\r\n                const typeAttrs = this._attribute();\r\n                const memberType = this._type_decl();\r\n                memberType.attributes = typeAttrs;\r\n\r\n                if (!this._check(Token.brace_right))\r\n                    this._consume(Token.comma, \"Expected ',' for struct member.\");\r\n                else\r\n                    this._match(Token.comma); // trailing comma optional.\r\n\r\n                members.push(new AST(\"member\", {\r\n                    name: memberName,\r\n                    attributes: memberAttrs,\r\n                    type: memberType\r\n                }));\r\n            }\r\n\r\n            this._consume(Token.brace_right, \"Expected '}' after struct body.\");\r\n\r\n            return new AST(\"struct\", { name, members });\r\n        }\r\n\r\n        _global_variable_decl() {\r\n            // attribute* variable_decl (equal const_expression)?\r\n            const _var = this._variable_decl();\r\n            if (this._match(Token.equal))\r\n                _var.value = this._const_expression();\r\n            return _var;\r\n        }\r\n\r\n        _global_constant_decl() {\r\n            // attribute* let (ident variable_ident_decl) global_const_initializer?\r\n            if (!this._match(Keyword.let) && !this._match(Keyword.const))\r\n                return null;\r\n\r\n            const name = this._consume(Token.ident, \"Expected variable name\");\r\n            let type = null;\r\n            if (this._match(Token.colon)) {\r\n                const attrs = this._attribute();\r\n                type = this._type_decl();\r\n                type.attributes = attrs;\r\n            }\r\n            let value = null;\r\n            if (this._match(Token.equal)) {\r\n                value = this._const_expression();\r\n            }\r\n            return new AST(\"let\", { name: name.toString(), type, value });\r\n        }\r\n\r\n        _const_expression() {\r\n            // type_decl paren_left ((const_expression comma)* const_expression comma?)? paren_right\r\n            // const_literal\r\n            if (this._match(Token.const_literal))\r\n                return this._previous().toString();\r\n\r\n            const type = this._type_decl();\r\n\r\n            this._consume(Token.paren_left, \"Expected '('.\");\r\n\r\n            let args = [];\r\n            while (!this._check(Token.paren_right)) {\r\n                args.push(this._const_expression());\r\n                if (!this._check(Token.comma))\r\n                    break;\r\n                this._advance();\r\n            }\r\n\r\n            this._consume(Token.paren_right, \"Expected ')'.\");\r\n\r\n            return new AST(\"create\", { type, args });\r\n        }\r\n\r\n        _variable_decl() {\r\n            // var variable_qualifier? (ident variable_ident_decl)\r\n            if (!this._match(Keyword.var))\r\n                return null;\r\n\r\n            // variable_qualifier: less_than storage_class (comma access_mode)? greater_than\r\n            let storage = null;\r\n            let access = null;\r\n            if (this._match(Token.less_than)) {\r\n                storage = this._consume(Token.storage_class, \"Expected storage_class.\").toString();\r\n                if (this._match(Token.comma))\r\n                    access = this._consume(Token.access_mode, \"Expected access_mode.\").toString();\r\n                this._consume(Token.greater_than, \"Expected '>'.\");\r\n            }\r\n\r\n            const name = this._consume(Token.ident, \"Expected variable name\");\r\n            let type = null;\r\n            if (this._match(Token.colon)) {\r\n                const attrs = this._attribute();\r\n                type = this._type_decl();\r\n                type.attributes = attrs;\r\n            }\r\n\r\n            return new AST(\"var\", { name: name.toString(), type, storage, access });\r\n        }\r\n\r\n        _enable_directive() {\r\n            // enable ident semicolon\r\n            const name = this._consume(Token.ident, \"identity expected.\");\r\n            return new AST(\"enable\", { name: name.toString() });\r\n        }\r\n\r\n        _type_alias() {\r\n            // type ident equal type_decl\r\n            const name = this._consume(Token.ident, \"identity expected.\");\r\n            this._consume(Token.equal, \"Expected '=' for type alias.\");\r\n            const alias = this._type_decl();\r\n            return new AST(\"alias\", { name: name.toString(), alias });\r\n        }\r\n\r\n        _type_decl() {\r\n            // ident\r\n            // bool\r\n            // float32\r\n            // int32\r\n            // uint32\r\n            // vec2 less_than type_decl greater_than\r\n            // vec3 less_than type_decl greater_than\r\n            // vec4 less_than type_decl greater_than\r\n            // mat2x2 less_than type_decl greater_than\r\n            // mat2x3 less_than type_decl greater_than\r\n            // mat2x4 less_than type_decl greater_than\r\n            // mat3x2 less_than type_decl greater_than\r\n            // mat3x3 less_than type_decl greater_than\r\n            // mat3x4 less_than type_decl greater_than\r\n            // mat4x2 less_than type_decl greater_than\r\n            // mat4x3 less_than type_decl greater_than\r\n            // mat4x4 less_than type_decl greater_than\r\n            // atomic less_than type_decl greater_than\r\n            // pointer less_than storage_class comma type_decl (comma access_mode)? greater_than\r\n            // array_type_decl\r\n            // texture_sampler_types\r\n\r\n            if (this._check([Token.ident, ...Token.texel_format, Keyword.bool, Keyword.float32, Keyword.int32, Keyword.uint32])) {\r\n                const type = this._advance();\r\n                return new AST(\"type\", { name: type.toString() });\r\n            }\r\n\r\n            if (this._check(Token.template_types)) {\r\n                let type = this._advance().toString();\r\n                this._consume(Token.less_than, \"Expected '<' for type.\");\r\n                const format = this._type_decl();\r\n                let access = null;\r\n                if (this._match(Token.comma))\r\n                    access = this._consume(Token.access_mode, \"Expected access_mode for pointer\").toString();\r\n                this._consume(Token.greater_than, \"Expected '>' for type.\");\r\n                return new AST(type, { name: type, format, access });\r\n            }\r\n\r\n            // pointer less_than storage_class comma type_decl (comma access_mode)? greater_than\r\n            if (this._match(Keyword.pointer)) {\r\n                let pointer = this._previous().toString();\r\n                this._consume(Token.less_than, \"Expected '<' for pointer.\");\r\n                const storage = this._consume(Token.storage_class, \"Expected storage_class for pointer\");\r\n                this._consume(Token.comma, \"Expected ',' for pointer.\");\r\n                const decl = this._type_decl();\r\n                let access = null;\r\n                if (this._match(Token.comma))\r\n                    access = this._consume(Token.access_mode, \"Expected access_mode for pointer\").toString();\r\n                this._consume(Token.greater_than, \"Expected '>' for pointer.\");\r\n                return new AST(\"pointer\", { name: pointer, storage: storage.toString(), decl, access });\r\n            }\r\n\r\n            // texture_sampler_types\r\n            let type = this._texture_sampler_types();\r\n            if (type)\r\n                return type;\r\n\r\n            // The following type_decl's have an optional attribyte_list*\r\n            const attrs = this._attribute();\r\n\r\n            // attribute* array less_than type_decl (comma element_count_expression)? greater_than\r\n            if (this._match(Keyword.array)) {\r\n                const array = this._previous();\r\n                this._consume(Token.less_than, \"Expected '<' for array type.\");\r\n                const format = this._type_decl();\r\n                let count = null;\r\n                if (this._match(Token.comma))\r\n                    count = this._consume(Token.element_count_expression, \"Expected element_count for array.\").toString();\r\n                this._consume(Token.greater_than, \"Expected '>' for array.\");\r\n\r\n                return new AST(\"array\", { name: array.toString(), attributes: attrs, format, count });\r\n            }\r\n\r\n            return null;\r\n        }\r\n\r\n        _texture_sampler_types() {\r\n            // sampler_type\r\n            if (this._match(Token.sampler_type))\r\n                return new AST(\"sampler\", { name: this._previous().toString() });\r\n\r\n            // depth_texture_type\r\n            if (this._match(Token.depth_texture_type))\r\n                return new AST(\"sampler\", { name: this._previous().toString() });\r\n\r\n            // sampled_texture_type less_than type_decl greater_than\r\n            // multisampled_texture_type less_than type_decl greater_than\r\n            if (this._match(Token.sampled_texture_type) ||\r\n                this._match(Token.multisampled_texture_type)) {\r\n                const sampler = this._previous();\r\n                this._consume(Token.less_than, \"Expected '<' for sampler type.\");\r\n                const format = this._type_decl();\r\n                this._consume(Token.greater_than, \"Expected '>' for sampler type.\");\r\n                return new AST(\"sampler\", { name: sampler.toString(), format });\r\n            }\r\n\r\n            // storage_texture_type less_than texel_format comma access_mode greater_than\r\n            if (this._match(Token.storage_texture_type)) {\r\n                const sampler = this._previous();\r\n                this._consume(Token.less_than, \"Expected '<' for sampler type.\");\r\n                const format = this._consume(Token.texel_format, \"Invalid texel format.\").toString();\r\n                this._consume(Token.comma, \"Expected ',' after texel format.\");\r\n                const access = this._consume(Token.access_mode, \"Expected access mode for storage texture type.\").toString();\r\n                this._consume(Token.greater_than, \"Expected '>' for sampler type.\");\r\n                return new AST(\"sampler\", { name: sampler.toString(), format, access });\r\n            }\r\n\r\n            return null;\r\n        }\r\n\r\n        _attribute() {\r\n            // attr ident paren_left (literal_or_ident comma)* literal_or_ident paren_right\r\n            // attr ident\r\n\r\n            let attributes = [];\r\n\r\n            while (this._match(Token.attr)) {\r\n                const name = this._consume(Token.attribute_name, \"Expected attribute name\");\r\n                const attr = new AST(\"attribute\", { name: name.toString() });\r\n                if (this._match(Token.paren_left)) {\r\n                    // literal_or_ident\r\n                    attr.value = this._consume(Token.literal_or_ident, \"Expected attribute value\").toString();\r\n                    if (this._check(Token.comma)) {\r\n                        this._advance();\r\n                        attr.value = [attr.value];\r\n                        do {\r\n                            const v = this._consume(Token.literal_or_ident, \"Expected attribute value\").toString();\r\n                            attr.value.push(v);\r\n                        } while (this._match(Token.comma));\r\n                    }\r\n                    this._consume(Token.paren_right, \"Expected ')'\");\r\n                }\r\n                attributes.push(attr);\r\n            }\r\n\r\n            // Deprecated:\r\n            // attr_left (attribute comma)* attribute attr_right\r\n            while (this._match(Token.attr_left)) {\r\n                if (!this._check(Token.attr_right)) {\r\n                    do {\r\n                        const name = this._consume(Token.attribute_name, \"Expected attribute name\");\r\n                        const attr = new AST(\"attribute\", { name: name.toString() });\r\n                        if (this._match(Token.paren_left)) {\r\n                            // literal_or_ident\r\n                            attr.value = this._consume(Token.literal_or_ident, \"Expected attribute value\").toString();\r\n                            if (this._check(Token.comma)) {\r\n                                this._advance();\r\n                                attr.value = [attr.value];\r\n                                do {\r\n                                    const v = this._consume(Token.literal_or_ident, \"Expected attribute value\").toString();\r\n                                    attr.value.push(v);\r\n                                } while (this._match(Token.comma));\r\n                            }\r\n                            this._consume(Token.paren_right, \"Expected ')'\");\r\n                        }\r\n                        attributes.push(attr);\r\n                    } while (this._match(Token.comma));\r\n\r\n                }\r\n                // Consume ]]\r\n                this._consume(Token.attr_right, \"Expected ']]' after attribute declarations\");\r\n            }\r\n\r\n            if (attributes.length == 0)\r\n                return null;\r\n\r\n            return attributes;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @author Brendan Duncan / https://github.com/brendan-duncan\r\n     */\r\n\r\n    export class WgslReflect {\r\n        functions: Array<ReflectFunction>;\r\n        structs: Array<ReflectStruct>;\r\n        constructor(code: string) {\r\n            if (code)\r\n                this.initialize(code);\r\n        }\r\n\r\n        initialize(code) {\r\n            const parser = new WgslParser();\r\n            this.ast = parser.parse(code);\r\n\r\n            // All top-level structs in the shader.\r\n            this.structs = [];\r\n            // All top-level uniform vars in the shader.\r\n            this.uniforms = [];\r\n            // All top-level storage vars in the shader.\r\n            this.storage = [];\r\n            // All top-level texture vars in the shader;\r\n            this.textures = [];\r\n            // All top-level sampler vars in the shader.\r\n            this.samplers = [];\r\n            // All top-level functions in the shader.\r\n            this.functions = [];\r\n            // All top-level type aliases in the shader.\r\n            this.aliases = [];\r\n            // All entry functions in the shader: vertex, fragment, and/or compute.\r\n            this.entry = {\r\n                vertex: [],\r\n                fragment: [],\r\n                compute: []\r\n            };\r\n\r\n            for (const node of this.ast) {\r\n                if (node._type == \"struct\")\r\n                    this.structs.push(node);\r\n\r\n                if (node._type == \"alias\")\r\n                    this.aliases.push(node);\r\n\r\n                if (this.isUniformVar(node)) {\r\n                    const group = this.getAttribute(node, \"group\");\r\n                    node.group = group && group.value ? parseInt(group.value) : 0;\r\n                    const binding = this.getAttribute(node, \"binding\");\r\n                    node.binding = binding && binding.value ? parseInt(binding.value) : 0;\r\n                    this.uniforms.push(node);\r\n                }\r\n\r\n                if (this.isStorageVar(node)) {\r\n                    const group = this.getAttribute(node, \"group\");\r\n                    node.group = group && group.value ? parseInt(group.value) : 0;\r\n                    const binding = this.getAttribute(node, \"binding\");\r\n                    node.binding = binding && binding.value ? parseInt(binding.value) : 0;\r\n                    this.storage.push(node);\r\n                }\r\n\r\n                if (this.isTextureVar(node)) {\r\n                    const group = this.getAttribute(node, \"group\");\r\n                    node.group = group && group.value ? parseInt(group.value) : 0;\r\n                    const binding = this.getAttribute(node, \"binding\");\r\n                    node.binding = binding && binding.value ? parseInt(binding.value) : 0;\r\n                    this.textures.push(node);\r\n                }\r\n\r\n                if (this.isSamplerVar(node)) {\r\n                    const group = this.getAttribute(node, \"group\");\r\n                    node.group = group && group.value ? parseInt(group.value) : 0;\r\n                    const binding = this.getAttribute(node, \"binding\");\r\n                    node.binding = binding && binding.value ? parseInt(binding.value) : 0;\r\n                    this.samplers.push(node);\r\n                }\r\n\r\n                if (node._type == \"function\") {\r\n                    this.functions.push(node);\r\n                    const vertexStage = this.getAttribute(node, \"vertex\");\r\n                    const fragmentStage = this.getAttribute(node, \"fragment\");\r\n                    const computeStage = this.getAttribute(node, \"compute\");\r\n                    const stage = vertexStage || fragmentStage || computeStage;\r\n                    if (stage) {\r\n                        node.inputs = this._getInputs(node);\r\n                        if (this.entry[stage.name])\r\n                            this.entry[stage.name].push(node);\r\n                        else\r\n                            this.entry[stage.name] = [node];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        isTextureVar(node) {\r\n            return node._type == \"var\" && WgslReflect.TextureTypes.indexOf(node.type.name) != -1;\r\n        }\r\n\r\n        isSamplerVar(node) {\r\n            return node._type == \"var\" && WgslReflect.SamplerTypes.indexOf(node.type.name) != -1;\r\n        }\r\n\r\n        isUniformVar(node) {\r\n            return node && node._type == \"var\" && node.storage == \"uniform\";\r\n        }\r\n\r\n        isStorageVar(node) {\r\n            return node && node._type == \"var\" && node.storage == \"storage\";\r\n        }\r\n\r\n        _getInputs(args, inputs) {\r\n            if (args._type == \"function\")\r\n                args = args.args;\r\n            if (!inputs)\r\n                inputs = [];\r\n\r\n            for (const arg of args) {\r\n                const input = this._getInputInfo(arg);\r\n                if (input)\r\n                    inputs.push(input);\r\n                const struct = this.getStruct(arg.type);\r\n                if (struct)\r\n                    this._getInputs(struct.members, inputs);\r\n            }\r\n\r\n            return inputs;\r\n        }\r\n\r\n        _getInputInfo(node) {\r\n            const location = this.getAttribute(node, \"location\") || this.getAttribute(node, \"builtin\");\r\n            if (location) {\r\n                let input = {\r\n                    name: node.name,\r\n                    type: node.type,\r\n                    input: node,\r\n                    locationType: location.name,\r\n                    location: this._parseInt(location.value)\r\n                };\r\n                const interpolation = this.getAttribute(node, \"interpolation\");\r\n                if (interpolation)\r\n                    input.interpolation = interpolation.value;\r\n                return input;\r\n            }\r\n            return null;\r\n        }\r\n\r\n        _parseInt(s) {\r\n            const n = parseInt(s);\r\n            return isNaN(n) ? s : n;\r\n        }\r\n\r\n        getAlias(name) {\r\n            if (!name) return null;\r\n            if (name.constructor === AST) {\r\n                if (name._type != \"type\")\r\n                    return null;\r\n                name = name.name;\r\n            }\r\n            for (const u of this.aliases) {\r\n                if (u.name == name)\r\n                    return u.alias;\r\n            }\r\n            return null;\r\n        }\r\n\r\n        getStruct(name) {\r\n            if (!name) return null;\r\n            if (name.constructor === AST) {\r\n                if (name._type == \"struct\")\r\n                    return name;\r\n                if (name._type != \"type\")\r\n                    return null;\r\n                name = name.name;\r\n            }\r\n            for (const u of this.structs) {\r\n                if (u.name == name)\r\n                    return u;\r\n            }\r\n            return null;\r\n        }\r\n\r\n        getAttribute(node, name) {\r\n            if (!node || !node.attributes) return null;\r\n            for (let a of node.attributes) {\r\n                if (a.name == name)\r\n                    return a;\r\n            }\r\n            return null;\r\n        }\r\n\r\n        getBindGroups() {\r\n            const groups = [];\r\n\r\n            function _makeRoom(group, binding) {\r\n                if (group >= groups.length)\r\n                    groups.length = group + 1;\r\n                if (groups[group] === undefined)\r\n                    groups[group] = [];\r\n\r\n                if (binding >= groups[group].length)\r\n                    groups[group].length = binding + 1;\r\n            }\r\n\r\n            for (const u of this.uniforms) {\r\n                _makeRoom(u.group, u.binding);\r\n                const group = groups[u.group];\r\n                group[u.binding] = { type: 'buffer', resource: this.getUniformBufferInfo(u) };\r\n            }\r\n\r\n            for (const u of this.storage) {\r\n                _makeRoom(u.group, u.binding);\r\n                const group = groups[u.group];\r\n                group[u.binding] = { type: 'storage', resource: this.getStorageBufferInfo(u) };\r\n            }\r\n\r\n            for (const t of this.textures) {\r\n                _makeRoom(t.group, t.binding);\r\n                const group = groups[t.group];\r\n                group[t.binding] = { type: 'texture', resource: t };\r\n            }\r\n\r\n            for (const t of this.samplers) {\r\n                _makeRoom(t.group, t.binding);\r\n                const group = groups[t.group];\r\n                group[t.binding] = { type: 'sampler', resource: t };\r\n            }\r\n\r\n            return groups;\r\n        }\r\n\r\n        getStorageBufferInfo(node) {\r\n            if (!this.isStorageVar(node))\r\n                return null;\r\n\r\n            let group = this.getAttribute(node, \"group\");\r\n            let binding = this.getAttribute(node, \"binding\");\r\n\r\n            group = group && group.value ? parseInt(group.value) : 0;\r\n            binding = binding && binding.value ? parseInt(binding.value) : 0;\r\n\r\n            return { name: node.name, type: node.type, group, binding };\r\n        }\r\n\r\n        getUniformBufferInfo(node) {\r\n            if (!this.isUniformVar(node))\r\n                return null;\r\n\r\n            let group = this.getAttribute(node, \"group\");\r\n            let binding = this.getAttribute(node, \"binding\");\r\n\r\n            group = group && group.value ? parseInt(group.value) : 0;\r\n            binding = binding && binding.value ? parseInt(binding.value) : 0;\r\n\r\n            const struct = this.getStruct(node.type);\r\n\r\n            let offset = 0;\r\n            let lastSize = 0;\r\n            let lastOffset = 0;\r\n            let structAlign = 0;\r\n            let buffer = { name: node.name, type: 'uniform', align: 0, size: 0, members: [], group, binding };\r\n\r\n            for (let mi = 0, ml = struct.members.length; mi < ml; ++mi) {\r\n                let member = struct.members[mi];\r\n                let name = member.name;\r\n\r\n                let info = this.getTypeInfo(member);\r\n                if (!info)\r\n                    continue;\r\n\r\n                let type = member.type;\r\n                let align = info.align;\r\n                let size = info.size;\r\n                offset = this._roundUp(align, offset + lastSize);\r\n                lastSize = size;\r\n                lastOffset = offset;\r\n                structAlign = Math.max(structAlign, align);\r\n\r\n                let u = { name, offset, size, type, member };\r\n                buffer.members.push(u);\r\n            }\r\n\r\n            buffer.size = this._roundUp(structAlign, lastOffset + lastSize);\r\n            buffer.align = structAlign;\r\n\r\n            return buffer;\r\n        }\r\n\r\n        getTypeInfo(type) {\r\n            let explicitSize = 0;\r\n            const sizeAttr = this.getAttribute(type, \"size\");\r\n            if (sizeAttr)\r\n                explicitSize = parseInt(sizeAttr.value);\r\n\r\n            let explicitAlign = 0;\r\n            const alignAttr = this.getAttribute(type, \"align\");\r\n            if (alignAttr)\r\n                explicitAlign = parseInt(alignAttr.value);\r\n\r\n            if (type._type == \"member\")\r\n                type = type.type;\r\n\r\n            if (type._type == \"type\") {\r\n                const alias = this.getAlias(type.name);\r\n                if (alias) {\r\n                    type = alias;\r\n                } else {\r\n                    const struct = this.getStruct(type.name);\r\n                    if (struct)\r\n                        type = struct;\r\n                }\r\n            }\r\n\r\n            const info = WgslReflect.TypeInfo[type.name];\r\n            if (info) {\r\n                return {\r\n                    align: Math.max(explicitAlign, info.align),\r\n                    size: Math.max(explicitSize, info.size)\r\n                };\r\n            }\r\n\r\n            if (type.name == \"array\") {\r\n                let align = 8;\r\n                let size = 8;\r\n                // Type                 AlignOf(T)          Sizeof(T)\r\n                // array<E, N>          AlignOf(E)          N * roundUp(AlignOf(E), SizeOf(E))\r\n                // array<E>             AlignOf(E)          N * roundUp(AlignOf(E), SizeOf(E))  (N determined at runtime)\r\n                //\r\n                // @stride(Q)\r\n                // array<E, N>          AlignOf(E)          N * Q\r\n                //\r\n                // @stride(Q)\r\n                // array<E>             AlignOf(E)          Nruntime * Q\r\n                //const E = type.format.name;\r\n                const E = this.getTypeInfo(type.format);\r\n                if (E) {\r\n                    size = E.size;\r\n                    align = E.align;\r\n                }\r\n\r\n                const N = parseInt(type.count || 1);\r\n\r\n                const stride = this.getAttribute(type, \"stride\");\r\n                if (stride) {\r\n                    size = N * parseInt(stride.value);\r\n                } else {\r\n                    size = N * this._roundUp(align, size);\r\n                }\r\n\r\n                if (explicitSize)\r\n                    size = explicitSize;\r\n\r\n                return {\r\n                    align: Math.max(explicitAlign, align),\r\n                    size: Math.max(explicitSize, size)\r\n                };\r\n            }\r\n\r\n            if (type._type == \"struct\") {\r\n                let align = 0;\r\n                let size = 0;\r\n                // struct S     AlignOf:    max(AlignOfMember(S, M1), ... , AlignOfMember(S, MN))\r\n                //              SizeOf:     roundUp(AlignOf(S), OffsetOfMember(S, L) + SizeOfMember(S, L))\r\n                //                          Where L is the last member of the structure\r\n                let offset = 0;\r\n                let lastSize = 0;\r\n                let lastOffset = 0;\r\n                for (const m of type.members) {\r\n                    const mi = this.getTypeInfo(m);\r\n                    align = Math.max(mi.align, align);\r\n                    offset = this._roundUp(mi.align, offset + lastSize);\r\n                    lastSize = mi.size;\r\n                    lastOffset = offset;\r\n                }\r\n                size = this._roundUp(align, lastOffset + lastSize);\r\n\r\n                return {\r\n                    align: Math.max(explicitAlign, align),\r\n                    size: Math.max(explicitSize, size)\r\n                };\r\n            }\r\n\r\n            return null;\r\n        }\r\n\r\n        _roundUp(k, n) {\r\n            return Math.ceil(n / k) * k;\r\n        }\r\n    }\r\n\r\n\r\n    // Type                 AlignOf(T)          Sizeof(T)\r\n    // i32, u32, or f32     4                   4\r\n    // atomic<T>            4                   4\r\n    // vec2<T>              8                   8\r\n    // vec3<T>              16                  12\r\n    // vec4<T>              16                  16\r\n    // mat2x2<f32>          8                   16\r\n    // mat3x2<f32>          8                   24\r\n    // mat4x2<f32>          8                   32\r\n    // mat2x3<f32>          16                  32\r\n    // mat3x3<f32>          16                  48\r\n    // mat4x3<f32>          16                  64\r\n    // mat2x4<f32>          16                  32\r\n    // mat3x4<f32>          16                  48\r\n    // mat4x4<f32>          16                  64\r\n    WgslReflect.TypeInfo = {\r\n        \"i32\": { align: 4, size: 4 },\r\n        \"u32\": { align: 4, size: 4 },\r\n        \"f32\": { align: 4, size: 4 },\r\n        \"atomic\": { align: 4, size: 4 },\r\n        \"vec2\": { align: 8, size: 8 },\r\n        \"vec3\": { align: 16, size: 12 },\r\n        \"vec4\": { align: 16, size: 16 },\r\n        \"mat2x2\": { align: 8, size: 16 },\r\n        \"mat3x2\": { align: 8, size: 24 },\r\n        \"mat4x2\": { align: 8, size: 32 },\r\n        \"mat2x3\": { align: 16, size: 32 },\r\n        \"mat3x3\": { align: 16, size: 48 },\r\n        \"mat4x3\": { align: 16, size: 64 },\r\n        \"mat2x4\": { align: 16, size: 32 },\r\n        \"mat3x4\": { align: 16, size: 48 },\r\n        \"mat4x4\": { align: 16, size: 64 },\r\n    };\r\n\r\n    WgslReflect.TextureTypes = Token.any_texture_type.map((t) => { return t.name; });\r\n    WgslReflect.SamplerTypes = Token.sampler_type.map((t) => { return t.name; });\r\n\r\n    // export { AST, Keyword, Token, WgslParser, WgslReflect, WgslScanner };\r\n}"],"names":[],"mappings":"AAAA;AACM,IAAW,YAwyEhB;AAxyED,CAAA,UAAiB,WAAW,EAAA;AAyCxB;;;;;;;;;;;;AAYK;IACL,SAAgB,aAAa,CAAC,IAAiB,EAAA;AAC3C,QAAA,OAAO,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,MAAM,GAAG,IAAI,aAAa,CAAC,IAAI,CAAC,MAAM,CAAC,CAAG,EAAA,IAAI,CAAC,KAAK,GAAG,GAAG,GAAG,IAAI,CAAC,KAAK,GAAG,EAAE,CAAG,CAAA,CAAA,GAAG,EAAE,CAAC,CAAC;KAClH;AAFe,IAAA,WAAA,CAAA,aAAa,gBAE5B,CAAA;IACD,SAAgB,SAAS,CAAC,KAA8B,EAAA;;AAEpD,QAAA,OAAO,KAAK,GAAG,KAAK,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC,IAAI,IAAI,CAAC,CAAC,KAAK,GAAG,CAAA,CAAA,EAAI,CAAC,CAAC,KAAK,GAAG,GAAG,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,EAAE,CAAC;KAC1F;AAHe,IAAA,WAAA,CAAA,SAAS,YAGxB,CAAA;IACD,SAAgB,mBAAmB,CAC/B,OAAoB,EAAE,EAAmB,EACzC,WAAuC,EAAE,YAAsB,EAAA;AAE/D,QAAA,IAAI,KAAK,GAAgB,IAAI,GAAG,EAAE,CAAC;AACnC,QAAA,IAAI,MAAM,GAAuD;AAC7D,YAAA,QAAQ,EAAE,YAAY,GAAG,EAAE,CAAC,IAAI;SACnC,CAAC;AACF,QAAA,IAAI,IAAI,GAAG,CAAA;gCACa,EAAE,CAAC,IAAI,CAAA,GAAA,EAAM,EAAE,CAAC,IAAI,CAAA,CAAA,EAAI,EAAE,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,IAAI,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA;iBAC/E,CAAC;QACV,SAAS,CAAC,EAAE,CAAC,MAAM,EAAE,YAAY,GAAG,EAAE,CAAC,IAAI,CAAC,CAAC;AAC7C,QAAA,OAAO,EAAE,KAAK,EAAE,IAAI,EAAE,MAAM,EAAE,CAAC;QAE/B,SAAS,QAAQ,CAAC,GAA+B,EAAA;AAC7C,YAAA,IAAI,IAAI,GAAG,SAAS,CAAC,GAAG,CAAC,UAAU,GAAG,GAAG,CAAC,UAAU,CAAC,MAAM,CAAC,GAAG,CAAC,IAAI,CAAC,UAAU,IAAI,EAAE,CAAC,GAAG,GAAG,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;AAC9G,YAAA,IAAI,OAAO,GAAG,WAAW,CAAC,IAAI,CAAC,CAAC;AAChC,YAAA,IAAI,OAAO,EAAE;AACT,gBAAA,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;AAChB,gBAAA,OAAO,OAAO,CAAC;AAClB,aAAA;AAAM,iBAAA;gBACH,IAAI,MAAM,GAAG,OAAO,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,CAAC,IAAI,KAAK,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;gBACtE,IAAI,CAAC,MAAM,EAAE;AACT,oBAAA,OAAO,CAAC,KAAK,CAAC,mCAAmC,CAAC,CAAC;AACtD,iBAAA;gBACD,IAAI,GAAG,GAAG,GAAG,CAAC,IAAI,CAAC,IAAI,GAAG,GAAG,CAAC;AAC9B,gBAAA,KAAK,IAAI,CAAC,IAAI,MAAM,CAAC,OAAO,EAAE;AAC1B,oBAAA,GAAG,IAAI,QAAQ,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC;AAC5B,iBAAA;gBACD,GAAG,IAAI,GAAG,CAAC;AACX,gBAAA,OAAO,GAAG,CAAC;AACd,aAAA;SACJ;AACD,QAAA,SAAS,SAAS,CAAC,IAAiB,EAAE,MAAc,EAAA;YAChD,IAAI,OAAO,GAAG,SAAS,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;AACzC,YAAA,IAAI,YAAY,CAAC,QAAQ,CAAC,OAAO,CAAC,EAAE;gBAChC,MAAM,CAAC,OAAO,CAAC,GAAG;AACd,oBAAA,IAAI,EAAE,MAAM;AACZ,oBAAA,IAAI,EAAE,aAAa,CAAC,IAAI,CAAC;iBAC5B,CAAC;gBAAC,OAAO;AACb,aAAA;AAAM,iBAAA;gBACH,IAAI,MAAM,GAAG,OAAO,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,CAAC,IAAI,KAAK,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;gBAClE,IAAI,CAAC,MAAM,EAAE;oBAAE,OAAO;AAAE,iBAAA;AACxB,gBAAA,KAAK,IAAI,CAAC,IAAI,MAAM,CAAC,OAAO,EAAE;oBAC1B,IAAI,CAAC,CAAC,UAAU,EAAE;AACd,wBAAA,CAAC,CAAC,IAAI,CAAC,UAAU,GAAG,CAAC,CAAC,IAAI,CAAC,UAAU,GAAG,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,UAAU,CAAC;AACjG,qBAAA;AACD,oBAAA,SAAS,CAAC,CAAC,CAAC,IAAI,EAAE,MAAM,GAAG,GAAG,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC;AAC5C,iBAAA;AACJ,aAAA;SACJ;KACJ;AAnDe,IAAA,WAAA,CAAA,mBAAmB,sBAmDlC,CAAA;AAED;;AAEG;AAEH,IAAA,MAAM,KAAK,CAAA;AACP,QAAA,WAAA,CAAY,IAAI,EAAE,MAAM,EAAE,IAAI,EAAA;AAC1B,YAAA,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC;AAClB,YAAA,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC;AACtB,YAAA,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC;SACrB;QAED,QAAQ,GAAA;YACJ,OAAO,IAAI,CAAC,OAAO,CAAC;SACvB;AACJ,KAAA;AAED,IAAA,KAAK,CAAC,GAAG,GAAG,EAAE,IAAI,EAAE,KAAK,EAAE,IAAI,EAAE,OAAO,EAAE,IAAI,EAAE,CAAC,CAAC,EAAE,CAAC;IAErD,IAAI,OAAO,GAAG,EAAE,CAAC;AAEjB,IAAA,MAAM,WAAW,CAAA;AACb,QAAA,WAAA,CAAY,MAAM,EAAA;AACd,YAAA,IAAI,CAAC,OAAO,GAAG,MAAM,IAAI,EAAE,CAAC;AAC5B,YAAA,IAAI,CAAC,OAAO,GAAG,EAAE,CAAC;AAClB,YAAA,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC;AAChB,YAAA,IAAI,CAAC,QAAQ,GAAG,CAAC,CAAC;AAClB,YAAA,IAAI,CAAC,KAAK,GAAG,CAAC,CAAC;SAClB;QAED,UAAU,GAAA;AACN,YAAA,OAAO,CAAC,IAAI,CAAC,QAAQ,EAAE,EAAE;AACrB,gBAAA,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,QAAQ,CAAC;AAC5B,gBAAA,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE;AACjB,oBAAA,MAAM,CAA0B,uBAAA,EAAA,IAAI,CAAC,KAAK,EAAE,CAAC;AACpD,aAAA;AAED,YAAA,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,KAAK,CAAC,KAAK,CAAC,GAAG,EAAE,EAAE,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;YACxD,OAAO,IAAI,CAAC,OAAO,CAAC;SACvB;QAED,SAAS,GAAA;;AAEL,YAAA,IAAI,MAAM,GAAG,IAAI,CAAC,QAAQ,EAAE,CAAC;;YAG7B,IAAI,MAAM,IAAI,IAAI,EAAE;gBAChB,IAAI,CAAC,KAAK,EAAE,CAAC;AACb,gBAAA,OAAO,IAAI,CAAC;AACf,aAAA;;AAGD,YAAA,IAAI,IAAI,CAAC,aAAa,CAAC,MAAM,CAAC,EAAE;AAC5B,gBAAA,OAAO,IAAI,CAAC;AACf,aAAA;YAED,IAAI,MAAM,IAAI,GAAG,EAAE;;AAEf,gBAAA,IAAI,IAAI,CAAC,UAAU,EAAE,IAAI,GAAG,EAAE;oBAC1B,OAAO,MAAM,IAAI,IAAI,EAAE;wBACnB,IAAI,IAAI,CAAC,QAAQ,EAAE;AACf,4BAAA,OAAO,IAAI,CAAC;AAChB,wBAAA,MAAM,GAAG,IAAI,CAAC,QAAQ,EAAE,CAAC;AAC5B,qBAAA;;oBAED,IAAI,CAAC,KAAK,EAAE,CAAC;AACb,oBAAA,OAAO,IAAI,CAAC;AACf,iBAAA;AAAM,qBAAA,IAAI,IAAI,CAAC,UAAU,EAAE,IAAI,GAAG,EAAE;;;oBAGjC,IAAI,CAAC,QAAQ,EAAE,CAAC;oBAChB,IAAI,YAAY,GAAG,CAAC,CAAC;oBACrB,OAAO,YAAY,GAAG,CAAC,EAAE;wBACrB,IAAI,IAAI,CAAC,QAAQ,EAAE;AACf,4BAAA,OAAO,IAAI,CAAC;AAChB,wBAAA,MAAM,GAAG,IAAI,CAAC,QAAQ,EAAE,CAAC;wBACzB,IAAI,MAAM,IAAI,IAAI,EAAE;4BAChB,IAAI,CAAC,KAAK,EAAE,CAAC;AAChB,yBAAA;6BAAM,IAAI,MAAM,IAAI,GAAG,EAAE;AACtB,4BAAA,IAAI,IAAI,CAAC,UAAU,EAAE,IAAI,GAAG,EAAE;gCAC1B,IAAI,CAAC,QAAQ,EAAE,CAAC;AAChB,gCAAA,YAAY,EAAE,CAAC;gCACf,IAAI,YAAY,IAAI,CAAC,EAAE;AACnB,oCAAA,OAAO,IAAI,CAAC;AACf,iCAAA;AACJ,6BAAA;AACJ,yBAAA;6BAAM,IAAI,MAAM,IAAI,GAAG,EAAE;AACtB,4BAAA,IAAI,IAAI,CAAC,UAAU,EAAE,IAAI,GAAG,EAAE;gCAC1B,IAAI,CAAC,QAAQ,EAAE,CAAC;AAChB,gCAAA,YAAY,EAAE,CAAC;AAClB,6BAAA;AACJ,yBAAA;AACJ,qBAAA;AACD,oBAAA,OAAO,IAAI,CAAC;AACf,iBAAA;AACJ,aAAA;YAED,IAAI,UAAU,GAAG,IAAI,CAAC;YAEtB,SAAU;gBACN,IAAI,YAAY,GAAG,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC;;;;;;;;gBAS3C,IAAI,MAAM,IAAI,GAAG,IAAI,IAAI,CAAC,UAAU,EAAE,IAAI,GAAG,EAAE;oBAC3C,IAAI,aAAa,GAAG,KAAK,CAAC;oBAC1B,IAAI,EAAE,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM,GAAG,CAAC,CAAC;AACjC,oBAAA,KAAK,IAAI,KAAK,GAAG,CAAC,EAAE,KAAK,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC,EAAE,EAAE,KAAK,EAAE,EAAE,EAAE,EAAE;AACrD,wBAAA,IAAI,IAAI,CAAC,OAAO,CAAC,EAAE,CAAC,CAAC,KAAK,IAAI,KAAK,CAAC,SAAS,EAAE;4BAC3C,IAAI,EAAE,GAAG,CAAC,IAAI,KAAK,CAAC,cAAc,CAAC,OAAO,CAAC,IAAI,CAAC,OAAO,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,EAAE;gCAC1E,aAAa,GAAG,IAAI,CAAC;AACxB,6BAAA;4BACD,MAAM;AACT,yBAAA;AACJ,qBAAA;;;AAGD,oBAAA,IAAI,aAAa,EAAE;AACf,wBAAA,IAAI,CAAC,SAAS,CAAC,YAAY,CAAC,CAAC;AAC7B,wBAAA,OAAO,IAAI,CAAC;AACf,qBAAA;AACJ,iBAAA;;;;;;;;;gBAUD,IAAI,CAAC,YAAY,EAAE;oBACf,IAAI,eAAe,GAAG,MAAM,CAAC;oBAC7B,IAAI,SAAS,GAAG,CAAC,CAAC;oBAClB,MAAM,YAAY,GAAG,CAAC,CAAC;oBACvB,KAAK,IAAI,EAAE,GAAG,CAAC,EAAE,EAAE,GAAG,YAAY,EAAE,EAAE,EAAE,EAAE;AACtC,wBAAA,eAAe,IAAI,IAAI,CAAC,UAAU,CAAC,EAAE,CAAC,CAAC;AACvC,wBAAA,YAAY,GAAG,IAAI,CAAC,UAAU,CAAC,eAAe,CAAC,CAAC;AAChD,wBAAA,IAAI,YAAY,EAAE;4BACd,SAAS,GAAG,EAAE,CAAC;4BACf,MAAM;AACT,yBAAA;AACJ,qBAAA;oBAED,IAAI,CAAC,YAAY,EAAE;AACf,wBAAA,IAAI,CAAC,UAAU;AACX,4BAAA,OAAO,KAAK,CAAC;wBACjB,IAAI,CAAC,QAAQ,EAAE,CAAC;AAChB,wBAAA,IAAI,CAAC,SAAS,CAAC,UAAU,CAAC,CAAC;AAC3B,wBAAA,OAAO,IAAI,CAAC;AACf,qBAAA;oBAED,MAAM,GAAG,eAAe,CAAC;AACzB,oBAAA,IAAI,CAAC,QAAQ,IAAI,SAAS,GAAG,CAAC,CAAC;AAClC,iBAAA;gBAED,UAAU,GAAG,YAAY,CAAC;gBAE1B,IAAI,IAAI,CAAC,QAAQ,EAAE;oBACf,MAAM;AAEV,gBAAA,MAAM,IAAI,IAAI,CAAC,QAAQ,EAAE,CAAC;AAC7B,aAAA;;YAGD,IAAI,UAAU,KAAK,IAAI;AACnB,gBAAA,OAAO,KAAK,CAAC;AAEjB,YAAA,IAAI,CAAC,SAAS,CAAC,UAAU,CAAC,CAAC;AAC3B,YAAA,OAAO,IAAI,CAAC;SACf;AAED,QAAA,UAAU,CAAC,MAAM,EAAA;AACb,YAAA,KAAK,MAAM,IAAI,IAAI,OAAO,EAAE;AACxB,gBAAA,MAAM,KAAK,GAAG,OAAO,CAAC,IAAI,CAAC,CAAC;gBAC5B,IAAI,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE,KAAK,CAAC,IAAI,CAAC,EAAE;AACjC,oBAAA,OAAO,KAAK,CAAC;AAChB,iBAAA;AACJ,aAAA;AACD,YAAA,KAAK,MAAM,IAAI,IAAI,KAAK,CAAC,MAAM,EAAE;gBAC7B,MAAM,KAAK,GAAG,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;gBACjC,IAAI,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE,KAAK,CAAC,IAAI,CAAC,EAAE;AACjC,oBAAA,OAAO,KAAK,CAAC;AAChB,iBAAA;AACJ,aAAA;AACD,YAAA,OAAO,IAAI,CAAC;SACf;QAED,MAAM,CAAC,MAAM,EAAE,IAAI,EAAA;AACf,YAAA,IAAI,QAAQ,IAAI,CAAC,IAAI,QAAQ,EAAE;gBAC3B,IAAI,IAAI,IAAI,MAAM,EAAE;AAChB,oBAAA,OAAO,IAAI,CAAC;AACf,iBAAA;AACJ,aAAA;AAAM,iBAAA;;gBAEH,MAAM,KAAK,GAAG,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;AAChC,gBAAA,IAAI,KAAK,IAAI,KAAK,CAAC,KAAK,IAAI,CAAC,IAAI,KAAK,CAAC,CAAC,CAAC,IAAI,MAAM;AAC/C,oBAAA,OAAO,IAAI,CAAC;AACnB,aAAA;AACD,YAAA,OAAO,KAAK,CAAC;SAChB;QAED,QAAQ,GAAA;YACJ,OAAO,IAAI,CAAC,QAAQ,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC;SAC/C;AAED,QAAA,aAAa,CAAC,CAAC,EAAA;YACX,OAAO,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,IAAI,IAAI,CAAC;SAC7C;AAED,QAAA,QAAQ,CAAC,MAAM,EAAA;YACX,IAAI,CAAC,GAAG,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;AACpC,YAAA,MAAM,GAAG,MAAM,IAAI,CAAC,CAAC;AACrB,YAAA,MAAM,EAAE,CAAC;AACT,YAAA,IAAI,CAAC,QAAQ,IAAI,MAAM,CAAC;AACxB,YAAA,OAAO,CAAC,CAAC;SACZ;AAED,QAAA,UAAU,CAAC,MAAM,EAAA;AACb,YAAA,MAAM,GAAG,MAAM,IAAI,CAAC,CAAC;YACrB,IAAI,IAAI,CAAC,QAAQ,GAAG,MAAM,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM;AAAE,gBAAA,OAAO,IAAI,CAAC;YAC/D,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,QAAQ,GAAG,MAAM,CAAC,CAAC;SAC/C;AAED,QAAA,SAAS,CAAC,IAAI,EAAA;AACV,YAAA,MAAM,IAAI,GAAG,IAAI,CAAC,OAAO,CAAC,SAAS,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC;AAChE,YAAA,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,KAAK,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;SACxD;AACJ,KAAA;IAED,KAAK,CAAC,UAAU,GAAG;AACf,QAAA,qBAAqB,EACjB,6FAA6F;AACjG,QAAA,iBAAiB,EACb,2HAA2H;AAC/H,QAAA,WAAW,EACP,kCAAkC;AACtC,QAAA,YAAY,EACR,iCAAiC;AACrC,QAAA,KAAK,EACD,uBAAuB;AAC3B,QAAA,GAAG,EACC,GAAG;AACP,QAAA,OAAO,EACH,IAAI;AACR,QAAA,KAAK,EACD,IAAI;AACR,QAAA,IAAI,EACA,GAAG;AACP,QAAA,SAAS,EACL,IAAI;AACR,QAAA,UAAU,EACN,IAAI;AACR,QAAA,aAAa,EACT,GAAG;AACP,QAAA,IAAI,EACA,GAAG;AACP,QAAA,YAAY,EACR,GAAG;AACP,QAAA,aAAa,EACT,GAAG;AACP,QAAA,UAAU,EACN,GAAG;AACP,QAAA,WAAW,EACP,GAAG;AACP,QAAA,KAAK,EACD,GAAG;AACP,QAAA,KAAK,EACD,GAAG;AACP,QAAA,KAAK,EACD,GAAG;AACP,QAAA,WAAW,EACP,IAAI;AACR,QAAA,SAAS,EACL,IAAI;AACR,QAAA,YAAY,EACR,GAAG;AACP,QAAA,kBAAkB,EACd,IAAI;AACR,QAAA,WAAW,EACP,IAAI;AACR,QAAA,SAAS,EACL,GAAG;AACP,QAAA,eAAe,EACX,IAAI;AACR,QAAA,UAAU,EACN,IAAI;AACR,QAAA,MAAM,EACF,GAAG;AACP,QAAA,KAAK,EACD,GAAG;AACP,QAAA,WAAW,EACP,IAAI;AACR,QAAA,MAAM,EACF,GAAG;AACP,QAAA,IAAI,EACA,GAAG;AACP,QAAA,SAAS,EACL,IAAI;AACR,QAAA,EAAE,EACE,GAAG;AACP,QAAA,KAAK,EACD,IAAI;AACR,QAAA,UAAU,EACN,GAAG;AACP,QAAA,WAAW,EACP,GAAG;AACP,QAAA,SAAS,EACL,GAAG;AACP,QAAA,IAAI,EACA,GAAG;AACP,QAAA,KAAK,EACD,GAAG;AACP,QAAA,UAAU,EACN,GAAG;AACP,QAAA,GAAG,EACC,GAAG;AAEP,QAAA,UAAU,EACN,IAAI;AACR,QAAA,WAAW,EACP,IAAI;AACR,QAAA,WAAW,EACP,IAAI;AACR,QAAA,cAAc,EACV,IAAI;AACR,QAAA,YAAY,EACR,IAAI;AACR,QAAA,SAAS,EACL,IAAI;AACR,QAAA,QAAQ,EACJ,IAAI;AACR,QAAA,SAAS,EACL,IAAI;AACR,QAAA,iBAAiB,EACb,KAAK;AACT,QAAA,gBAAgB,EACZ,KAAK;KACZ,CAAC;IAEF,KAAK,CAAC,YAAY,GAAG;QACjB,OAAO;QACP,QAAQ;QACR,MAAM;QACN,KAAK;QACL,KAAK;QACL,QAAQ;QACR,QAAQ;QACR,QAAQ;QACR,QAAQ;QACR,QAAQ;QACR,QAAQ;QACR,QAAQ;QACR,QAAQ;QACR,QAAQ;QACR,KAAK;QACL,SAAS;QACT,oBAAoB;QACpB,QAAQ;QACR,YAAY;QACZ,YAAY;QACZ,kBAAkB;QAClB,YAAY;QACZ,cAAc;QACd,oBAAoB;QACpB,yBAAyB;QACzB,oBAAoB;QACpB,oBAAoB;QACpB,0BAA0B;QAC1B,oBAAoB;QACpB,kBAAkB;QAClB,wBAAwB;QACxB,oBAAoB;QACpB,0BAA0B;QAC1B,+BAA+B;QAC/B,KAAK;QACL,MAAM;QACN,MAAM;QACN,MAAM;QACN,SAAS;QACT,OAAO;QACP,OAAO;QACP,MAAM;QACN,UAAU;QACV,YAAY;QACZ,SAAS;QACT,SAAS;QACT,MAAM;QACN,QAAQ;QACR,QAAQ;QACR,aAAa;QACb,OAAO;QACP,IAAI;QACJ,KAAK;QACL,UAAU;QACV,IAAI;QACJ,KAAK;QACL,OAAO;QACP,MAAM;QACN,OAAO;QACP,SAAS;QACT,MAAM;QACN,YAAY;QACZ,QAAQ;QACR,SAAS;QACT,QAAQ;QACR,MAAM;QACN,MAAM;QACN,SAAS;QACT,KAAK;QACL,WAAW;QACX,OAAO;QACP,SAAS;QACT,SAAS;QACT,QAAQ;QACR,QAAQ;QACR,SAAS;QACT,SAAS;QACT,UAAU;QACV,UAAU;QACV,UAAU;QACV,SAAS;QACT,SAAS;QACT,SAAS;QACT,SAAS;QACT,UAAU;QACV,UAAU;QACV,UAAU;QACV,WAAW;QACX,YAAY;QACZ,iBAAiB;QACjB,YAAY;QACZ,WAAW;QACX,WAAW;QACX,YAAY;QACZ,iBAAiB;QACjB,cAAc;QACd,cAAc;QACd,UAAU;QACV,UAAU;QACV,WAAW;QACX,YAAY;QACZ,YAAY;QACZ,aAAa;QACb,YAAY;QACZ,YAAY;QACZ,aAAa;QACb,eAAe;KAClB,CAAC;IAEF,KAAK,CAAC,YAAY,GAAG;QACjB,KAAK;QACL,MAAM;QACN,IAAI;QACJ,MAAM;QACN,KAAK;QACL,KAAK;QACL,QAAQ;QACR,IAAI;QACJ,KAAK;QACL,KAAK;QACL,KAAK;QACL,UAAU;QACV,YAAY;QACZ,SAAS;QACT,IAAI;QACJ,KAAK;QACL,KAAK;QACL,QAAQ;QACR,OAAO;QACP,KAAK;QACL,MAAM;KACT,CAAC;AAEF,IAAA,SAAS,WAAW,GAAA;AAChB,QAAA,KAAK,CAAC,MAAM,GAAG,EAAE,CAAC;AAClB,QAAA,KAAK,IAAI,KAAK,IAAI,KAAK,CAAC,UAAU,EAAE;AAChC,YAAA,KAAK,CAAC,MAAM,CAAC,KAAK,CAAC,GAAG;AAClB,gBAAA,IAAI,EAAE,KAAK;AACX,gBAAA,IAAI,EAAE,OAAO;AACb,gBAAA,IAAI,EAAE,KAAK,CAAC,UAAU,CAAC,KAAK,CAAC;AAC7B,gBAAA,QAAQ,EAAE,YAAc,EAAA,OAAO,KAAK,CAAC,EAAE;aAC1C,CAAC;YACF,KAAK,CAAC,KAAK,CAAC,GAAG,KAAK,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;AACtC,SAAA;AAED,QAAA,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,YAAY,CAAC,MAAM,EAAE,CAAC,GAAG,CAAC,EAAE,EAAE,CAAC,EAAE;YACvD,OAAO,CAAC,KAAK,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,GAAG;AAC7B,gBAAA,IAAI,EAAE,KAAK,CAAC,YAAY,CAAC,CAAC,CAAC;AAC3B,gBAAA,IAAI,EAAE,SAAS;AACf,gBAAA,IAAI,EAAE,KAAK,CAAC,YAAY,CAAC,CAAC,CAAC;gBAC3B,QAAQ,EAAE,YAAc,EAAA,OAAO,KAAK,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,EAAE;aAC1D,CAAC;AACL,SAAA;AAED,QAAA,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,YAAY,CAAC,MAAM,EAAE,CAAC,GAAG,CAAC,EAAE,EAAE,CAAC,EAAE;YACvD,OAAO,CAAC,KAAK,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,GAAG;AAC7B,gBAAA,IAAI,EAAE,KAAK,CAAC,YAAY,CAAC,CAAC,CAAC;AAC3B,gBAAA,IAAI,EAAE,UAAU;AAChB,gBAAA,IAAI,EAAE,KAAK,CAAC,YAAY,CAAC,CAAC,CAAC;gBAC3B,QAAQ,EAAE,YAAc,EAAA,OAAO,KAAK,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,EAAE;aAC1D,CAAC;AACL,SAAA;;;AAKD,QAAA,OAAO,CAAC,KAAK,GAAG,OAAO,CAAC,GAAG,CAAC;AAC5B,QAAA,OAAO,CAAC,MAAM,GAAG,OAAO,CAAC,GAAG,CAAC;AAC7B,QAAA,OAAO,CAAC,OAAO,GAAG,OAAO,CAAC,GAAG,CAAC;AAC9B,QAAA,OAAO,CAAC,OAAO,GAAG,OAAO,CAAC,GAAG,CAAC;;;QAK9B,KAAK,CAAC,aAAa,GAAG;AAClB,YAAA,OAAO,CAAC,QAAQ;AAChB,YAAA,OAAO,CAAC,OAAO;AACf,YAAA,OAAO,CAAC,SAAS;AACjB,YAAA,OAAO,CAAC,OAAO;AACf,YAAA,OAAO,CAAC,OAAO;SAClB,CAAC;QAEF,KAAK,CAAC,WAAW,GAAG;AAChB,YAAA,OAAO,CAAC,IAAI;AACZ,YAAA,OAAO,CAAC,KAAK;AACb,YAAA,OAAO,CAAC,UAAU;SACrB,CAAC;QAEF,KAAK,CAAC,YAAY,GAAG;AACjB,YAAA,OAAO,CAAC,OAAO;AACf,YAAA,OAAO,CAAC,kBAAkB;SAC7B,CAAC;QAEF,KAAK,CAAC,oBAAoB,GAAG;AACzB,YAAA,OAAO,CAAC,UAAU;AAClB,YAAA,OAAO,CAAC,UAAU;AAClB,YAAA,OAAO,CAAC,gBAAgB;AACxB,YAAA,OAAO,CAAC,UAAU;AAClB,YAAA,OAAO,CAAC,YAAY;AACpB,YAAA,OAAO,CAAC,kBAAkB;SAC7B,CAAC;QAEF,KAAK,CAAC,yBAAyB,GAAG;AAC9B,YAAA,OAAO,CAAC,uBAAuB;SAClC,CAAC;QAEF,KAAK,CAAC,oBAAoB,GAAG;AACzB,YAAA,OAAO,CAAC,kBAAkB;AAC1B,YAAA,OAAO,CAAC,kBAAkB;AAC1B,YAAA,OAAO,CAAC,wBAAwB;AAChC,YAAA,OAAO,CAAC,kBAAkB;SAC7B,CAAC;QAEF,KAAK,CAAC,kBAAkB,GAAG;AACvB,YAAA,OAAO,CAAC,gBAAgB;AACxB,YAAA,OAAO,CAAC,sBAAsB;AAC9B,YAAA,OAAO,CAAC,kBAAkB;AAC1B,YAAA,OAAO,CAAC,wBAAwB;AAChC,YAAA,OAAO,CAAC,6BAA6B;SACxC,CAAC;QAEF,KAAK,CAAC,gBAAgB,GAAG;YACrB,GAAG,KAAK,CAAC,oBAAoB;YAC7B,GAAG,KAAK,CAAC,yBAAyB;YAClC,GAAG,KAAK,CAAC,oBAAoB;YAC7B,GAAG,KAAK,CAAC,kBAAkB;SAC9B,CAAC;QAEF,KAAK,CAAC,YAAY,GAAG;AACjB,YAAA,OAAO,CAAC,OAAO;AACf,YAAA,OAAO,CAAC,OAAO;AACf,YAAA,OAAO,CAAC,MAAM;AACd,YAAA,OAAO,CAAC,MAAM;AACd,YAAA,OAAO,CAAC,OAAO;AACf,YAAA,OAAO,CAAC,OAAO;AACf,YAAA,OAAO,CAAC,QAAQ;AAChB,YAAA,OAAO,CAAC,QAAQ;AAChB,YAAA,OAAO,CAAC,QAAQ;AAChB,YAAA,OAAO,CAAC,OAAO;AACf,YAAA,OAAO,CAAC,OAAO;AACf,YAAA,OAAO,CAAC,OAAO;AACf,YAAA,OAAO,CAAC,OAAO;AACf,YAAA,OAAO,CAAC,QAAQ;AAChB,YAAA,OAAO,CAAC,QAAQ;AAChB,YAAA,OAAO,CAAC,QAAQ;AAChB,YAAA,OAAO,CAAC,SAAS;AACjB,YAAA,OAAO,CAAC,UAAU;AAClB,YAAA,OAAO,CAAC,eAAe;AACvB,YAAA,OAAO,CAAC,UAAU;AAClB,YAAA,OAAO,CAAC,SAAS;AACjB,YAAA,OAAO,CAAC,SAAS;AACjB,YAAA,OAAO,CAAC,UAAU;AAClB,YAAA,OAAO,CAAC,eAAe;AACvB,YAAA,OAAO,CAAC,YAAY;AACpB,YAAA,OAAO,CAAC,YAAY;AACpB,YAAA,OAAO,CAAC,QAAQ;AAChB,YAAA,OAAO,CAAC,QAAQ;AAChB,YAAA,OAAO,CAAC,SAAS;AACjB,YAAA,OAAO,CAAC,UAAU;AAClB,YAAA,OAAO,CAAC,UAAU;AAClB,YAAA,OAAO,CAAC,WAAW;AACnB,YAAA,OAAO,CAAC,UAAU;AAClB,YAAA,OAAO,CAAC,UAAU;AAClB,YAAA,OAAO,CAAC,WAAW;SACtB,CAAC;QAEF,KAAK,CAAC,aAAa,GAAG;AAClB,YAAA,KAAK,CAAC,WAAW;AACjB,YAAA,KAAK,CAAC,YAAY;AAClB,YAAA,KAAK,CAAC,qBAAqB;AAC3B,YAAA,KAAK,CAAC,iBAAiB;AACvB,YAAA,OAAO,CAAC,IAAI;AACZ,YAAA,OAAO,CAAC,KAAK;SAChB,CAAC;QAEF,KAAK,CAAC,gBAAgB,GAAG;AACrB,YAAA,KAAK,CAAC,KAAK;AACX,YAAA,KAAK,CAAC,WAAW;AACjB,YAAA,KAAK,CAAC,YAAY;AAClB,YAAA,KAAK,CAAC,qBAAqB;AAC3B,YAAA,KAAK,CAAC,iBAAiB;SAC1B,CAAC;QAEF,KAAK,CAAC,wBAAwB,GAAG;AAC7B,YAAA,KAAK,CAAC,WAAW;AACjB,YAAA,KAAK,CAAC,YAAY;AAClB,YAAA,KAAK,CAAC,KAAK;SACd,CAAC;QAEF,KAAK,CAAC,cAAc,GAAG;AACnB,YAAA,OAAO,CAAC,IAAI;AACZ,YAAA,OAAO,CAAC,IAAI;AACZ,YAAA,OAAO,CAAC,IAAI;AACZ,YAAA,OAAO,CAAC,MAAM;AACd,YAAA,OAAO,CAAC,MAAM;AACd,YAAA,OAAO,CAAC,MAAM;AACd,YAAA,OAAO,CAAC,MAAM;AACd,YAAA,OAAO,CAAC,MAAM;AACd,YAAA,OAAO,CAAC,MAAM;AACd,YAAA,OAAO,CAAC,MAAM;AACd,YAAA,OAAO,CAAC,MAAM;AACd,YAAA,OAAO,CAAC,MAAM;AACd,YAAA,OAAO,CAAC,MAAM;AAEd,YAAA,OAAO,CAAC,OAAO;YAEf,GAAG,KAAK,CAAC,gBAAgB;SAC5B,CAAC;;;QAIF,KAAK,CAAC,cAAc,GAAG;AACnB,YAAA,KAAK,CAAC,KAAK;AACX,YAAA,OAAO,CAAC,KAAK;SAChB,CAAC;QAEF,KAAK,CAAC,oBAAoB,GAAG;AACzB,YAAA,KAAK,CAAC,KAAK;AACX,YAAA,KAAK,CAAC,UAAU;AAChB,YAAA,KAAK,CAAC,WAAW;AACjB,YAAA,KAAK,CAAC,WAAW;AACjB,YAAA,KAAK,CAAC,cAAc;AACpB,YAAA,KAAK,CAAC,YAAY;AAClB,YAAA,KAAK,CAAC,SAAS;AACf,YAAA,KAAK,CAAC,QAAQ;AACd,YAAA,KAAK,CAAC,SAAS;AACf,YAAA,KAAK,CAAC,iBAAiB;AACvB,YAAA,KAAK,CAAC,gBAAgB;SACzB,CAAC;QAEF,KAAK,CAAC,mBAAmB,GAAG;AACxB,YAAA,KAAK,CAAC,SAAS;AACf,YAAA,KAAK,CAAC,WAAW;SACpB,CAAC;KACL;AACD,IAAA,WAAW,EAAE,CAAC;AAEd;;AAEG;AAEH,IAAA,MAAM,GAAG,CAAA;QACL,WAAY,CAAA,IAAI,EAAE,OAAO,EAAA;AACrB,YAAA,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC;AAClB,YAAA,IAAI,OAAO,EAAE;AACT,gBAAA,KAAK,IAAI,MAAM,IAAI,OAAO,EAAE;oBACxB,IAAI,CAAC,MAAM,CAAC,GAAG,OAAO,CAAC,MAAM,CAAC,CAAC;AAClC,iBAAA;AACJ,aAAA;SACJ;AACJ,KAAA;AAED,IAAA,MAAM,UAAU,CAAA;AACZ,QAAA,WAAA,GAAA;AACI,YAAA,IAAI,CAAC,OAAO,GAAG,EAAE,CAAC;AAClB,YAAA,IAAI,CAAC,QAAQ,GAAG,CAAC,CAAC;SACrB;AAED,QAAA,KAAK,CAAC,YAAY,EAAA;AACd,YAAA,IAAI,CAAC,WAAW,CAAC,YAAY,CAAC,CAAC;YAE/B,IAAI,UAAU,GAAG,EAAE,CAAC;AACpB,YAAA,OAAO,CAAC,IAAI,CAAC,QAAQ,EAAE,EAAE;AACrB,gBAAA,MAAM,SAAS,GAAG,IAAI,CAAC,yBAAyB,EAAE,CAAC;AACnD,gBAAA,IAAI,CAAC,SAAS;oBACV,MAAM;AACV,gBAAA,UAAU,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;AAC9B,aAAA;AACD,YAAA,OAAO,UAAU,CAAC;SACrB;AAED,QAAA,WAAW,CAAC,YAAY,EAAA;AACpB,YAAA,IAAI,YAAY,EAAE;AACd,gBAAA,IAAI,QAAQ,YAAY,CAAC,IAAI,QAAQ,EAAE;AACnC,oBAAA,MAAM,OAAO,GAAG,IAAI,WAAW,CAAC,YAAY,CAAC,CAAC;AAC9C,oBAAA,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC,UAAU,EAAE,CAAC;AACvC,iBAAA;AAAM,qBAAA;AACH,oBAAA,IAAI,CAAC,OAAO,GAAG,YAAY,CAAC;AAC/B,iBAAA;AACJ,aAAA;AAAM,iBAAA;AACH,gBAAA,IAAI,CAAC,OAAO,GAAG,EAAE,CAAC;AACrB,aAAA;AACD,YAAA,IAAI,CAAC,QAAQ,GAAG,CAAC,CAAC;SACrB;QAED,MAAM,CAAC,KAAK,EAAE,OAAO,EAAA;AACjB,YAAA,OAAO,CAAC,KAAK,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC;AAC9B,YAAA,OAAO,EAAE,KAAK,EAAE,OAAO,EAAE,QAAQ,EAAE,YAAA,EAAc,OAAO,CAAA,EAAG,OAAO,CAAE,CAAA,CAAC,EAAE,EAAE,CAAC;SAC7E;QAED,QAAQ,GAAA,EAAK,OAAO,IAAI,CAAC,QAAQ,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,IAAI,IAAI,CAAC,KAAK,EAAE,CAAC,KAAK,IAAI,KAAK,CAAC,GAAG,CAAC,EAAE;AAE9F,QAAA,MAAM,CAAC,KAAK,EAAA;AACR,YAAA,IAAI,KAAK,CAAC,MAAM,KAAK,SAAS,EAAE;AAC5B,gBAAA,IAAI,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE;oBACpB,IAAI,CAAC,QAAQ,EAAE,CAAC;AAChB,oBAAA,OAAO,IAAI,CAAC;AACf,iBAAA;AACD,gBAAA,OAAO,KAAK,CAAC;AAChB,aAAA;AAED,YAAA,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,GAAG,CAAC,EAAE,EAAE,CAAC,EAAE;AAC1C,gBAAA,MAAM,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;AACtB,gBAAA,IAAI,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE;oBACnB,IAAI,CAAC,QAAQ,EAAE,CAAC;AAChB,oBAAA,OAAO,IAAI,CAAC;AACf,iBAAA;AACJ,aAAA;AAED,YAAA,OAAO,KAAK,CAAC;SAChB;QAED,QAAQ,CAAC,KAAK,EAAE,OAAO,EAAA;AACnB,YAAA,IAAI,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC;AAAE,gBAAA,OAAO,IAAI,CAAC,QAAQ,EAAE,CAAC;YAC/C,MAAM,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,EAAE,EAAE,OAAO,CAAC,CAAC;SAC5C;AAED,QAAA,MAAM,CAAC,KAAK,EAAA;YACR,IAAI,IAAI,CAAC,QAAQ,EAAE;AAAE,gBAAA,OAAO,KAAK,CAAC;AAClC,YAAA,IAAI,KAAK,CAAC,MAAM,KAAK,SAAS,EAAE;gBAC5B,IAAI,CAAC,GAAG,IAAI,CAAC,KAAK,EAAE,CAAC,KAAK,CAAC;gBAC3B,OAAO,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;AACjC,aAAA;YACD,OAAO,IAAI,CAAC,KAAK,EAAE,CAAC,KAAK,IAAI,KAAK,CAAC;SACtC;QAED,QAAQ,GAAA;AACJ,YAAA,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE;gBAAE,IAAI,CAAC,QAAQ,EAAE,CAAC;AACtC,YAAA,OAAO,IAAI,CAAC,SAAS,EAAE,CAAC;SAC3B;QAED,KAAK,GAAA;YACD,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;SACtC;QAED,SAAS,GAAA;YACL,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,QAAQ,GAAG,CAAC,CAAC,CAAC;SAC1C;QAED,yBAAyB,GAAA;;;;;;;;;AAUrB,YAAA,OAAO,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE;gBAAC,CAAC;YAEzD,IAAI,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE;AAC3B,gBAAA,MAAM,IAAI,GAAG,IAAI,CAAC,WAAW,EAAE,CAAC;gBAChC,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,SAAS,EAAE,cAAc,CAAC,CAAC;AAC/C,gBAAA,OAAO,IAAI,CAAC;AACf,aAAA;YAED,IAAI,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,EAAE;AAC7B,gBAAA,MAAM,MAAM,GAAG,IAAI,CAAC,iBAAiB,EAAE,CAAC;gBACxC,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,SAAS,EAAE,cAAc,CAAC,CAAC;AAC/C,gBAAA,OAAO,MAAM,CAAC;AACjB,aAAA;;AAGD,YAAA,MAAM,KAAK,GAAG,IAAI,CAAC,UAAU,EAAE,CAAC;YAEhC,IAAI,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE;AAC1B,gBAAA,MAAM,IAAI,GAAG,IAAI,CAAC,qBAAqB,EAAE,CAAC;AAC1C,gBAAA,IAAI,CAAC,UAAU,GAAG,KAAK,CAAC;gBACxB,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,SAAS,EAAE,eAAe,CAAC,CAAC;AAChD,gBAAA,OAAO,IAAI,CAAC;AACf,aAAA;AAED,YAAA,IAAI,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE;AACxD,gBAAA,MAAM,IAAI,GAAG,IAAI,CAAC,qBAAqB,EAAE,CAAC;AAC1C,gBAAA,IAAI,CAAC,UAAU,GAAG,KAAK,CAAC;gBACxB,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,SAAS,EAAE,eAAe,CAAC,CAAC;AAChD,gBAAA,OAAO,IAAI,CAAC;AACf,aAAA;YAED,IAAI,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,EAAE;AAC7B,gBAAA,MAAM,OAAO,GAAG,IAAI,CAAC,YAAY,EAAE,CAAC;AACpC,gBAAA,OAAO,CAAC,UAAU,GAAG,KAAK,CAAC;AAC3B,gBAAA,OAAO,OAAO,CAAC;AAClB,aAAA;YAED,IAAI,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,EAAE,CAAC,EAAE;AACzB,gBAAA,MAAM,GAAG,GAAG,IAAI,CAAC,cAAc,EAAE,CAAC;AAClC,gBAAA,GAAG,CAAC,UAAU,GAAG,KAAK,CAAC;AACvB,gBAAA,OAAO,GAAG,CAAC;AACd,aAAA;AAED,YAAA,OAAO,IAAI,CAAC;SACf;QAED,cAAc,GAAA;;;YAGV,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,EAAE,CAAC;AACxB,gBAAA,OAAO,IAAI,CAAC;AAEhB,YAAA,MAAM,IAAI,GAAG,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,KAAK,EAAE,yBAAyB,CAAC,CAAC,QAAQ,EAAE,CAAC;YAE9E,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,UAAU,EAAE,sCAAsC,CAAC,CAAC;YAExE,MAAM,IAAI,GAAG,EAAE,CAAC;YAChB,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,WAAW,CAAC,EAAE;gBACjC,GAAG;AACC,oBAAA,IAAI,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,WAAW,CAAC;wBAC9B,MAAM;AACV,oBAAA,MAAM,QAAQ,GAAG,IAAI,CAAC,UAAU,EAAE,CAAC;AAEnC,oBAAA,MAAM,IAAI,GAAG,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,KAAK,EAAE,yBAAyB,CAAC,CAAC,QAAQ,EAAE,CAAC;oBAE9E,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,KAAK,EAAE,iCAAiC,CAAC,CAAC;AAE9D,oBAAA,MAAM,SAAS,GAAG,IAAI,CAAC,UAAU,EAAE,CAAC;AACpC,oBAAA,MAAM,IAAI,GAAG,IAAI,CAAC,UAAU,EAAE,CAAC;AAC/B,oBAAA,IAAI,CAAC,UAAU,GAAG,SAAS,CAAC;AAE5B,oBAAA,IAAI,CAAC,IAAI,CAAC,IAAI,GAAG,CAAC,KAAK,EAAE,EAAE,IAAI,EAAE,UAAU,EAAE,QAAQ,EAAE,IAAI,EAAE,CAAC,CAAC,CAAC;iBACnE,QAAQ,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,EAAE;AACtC,aAAA;YAED,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,WAAW,EAAE,wCAAwC,CAAC,CAAC;YAE3E,IAAI,OAAO,GAAG,IAAI,CAAC;YACnB,IAAI,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,EAAE;AAC1B,gBAAA,MAAM,KAAK,GAAG,IAAI,CAAC,UAAU,EAAE,CAAC;AAChC,gBAAA,OAAO,GAAG,IAAI,CAAC,UAAU,EAAE,CAAC;AAC5B,gBAAA,OAAO,CAAC,UAAU,GAAG,KAAK,CAAC;AAC9B,aAAA;AAED,YAAA,MAAM,IAAI,GAAG,IAAI,CAAC,mBAAmB,EAAE,CAAC;AAExC,YAAA,OAAO,IAAI,GAAG,CAAC,UAAU,EAAE,EAAE,IAAI,EAAE,IAAI,EAAE,MAAM,EAAE,OAAO,EAAE,IAAI,EAAE,CAAC,CAAC;SACrE;QAED,mBAAmB,GAAA;;YAEf,MAAM,UAAU,GAAG,EAAE,CAAC;YACtB,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,UAAU,EAAE,yBAAyB,CAAC,CAAC;YAC3D,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,WAAW,CAAC,EAAE;AACpC,gBAAA,MAAM,SAAS,GAAG,IAAI,CAAC,UAAU,EAAE,CAAC;AACpC,gBAAA,IAAI,SAAS;AACT,oBAAA,UAAU,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;AAClC,aAAA;YACD,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,WAAW,EAAE,yBAAyB,CAAC,CAAC;AAE5D,YAAA,OAAO,UAAU,CAAC;SACrB;QAED,UAAU,GAAA;;;;;;;;;;;;;;;;;;AAmBN,YAAA,OAAO,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE;gBAAC,CAAC;AAEzD,YAAA,IAAI,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,EAAE,CAAC;AACvB,gBAAA,OAAO,IAAI,CAAC,aAAa,EAAE,CAAC;AAEhC,YAAA,IAAI,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC;AAC3B,gBAAA,OAAO,IAAI,CAAC,iBAAiB,EAAE,CAAC;AAEpC,YAAA,IAAI,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC;AACzB,gBAAA,OAAO,IAAI,CAAC,eAAe,EAAE,CAAC;AAElC,YAAA,IAAI,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC;AACxB,gBAAA,OAAO,IAAI,CAAC,cAAc,EAAE,CAAC;AAEjC,YAAA,IAAI,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC;AAC1B,gBAAA,OAAO,IAAI,CAAC,gBAAgB,EAAE,CAAC;AAEnC,YAAA,IAAI,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,aAAa,CAAC;AAClC,gBAAA,OAAO,IAAI,CAAC,wBAAwB,EAAE,CAAC;AAE3C,YAAA,IAAI,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,UAAU,CAAC;AAC7B,gBAAA,OAAO,IAAI,CAAC,mBAAmB,EAAE,CAAC;YAEtC,IAAI,MAAM,GAAG,IAAI,CAAC;AAClB,YAAA,IAAI,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC;AAC3B,gBAAA,MAAM,GAAG,IAAI,CAAC,iBAAiB,EAAE,CAAC;AACjC,iBAAA,IAAI,IAAI,CAAC,MAAM,CAAC,CAAC,OAAO,CAAC,GAAG,EAAE,OAAO,CAAC,GAAG,EAAE,OAAO,CAAC,KAAK,CAAC,CAAC;AAC3D,gBAAA,MAAM,GAAG,IAAI,CAAC,mBAAmB,EAAE,CAAC;AACnC,iBAAA,IAAI,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC;AACjC,gBAAA,MAAM,GAAG,IAAI,GAAG,CAAC,SAAS,CAAC,CAAC;AAC3B,iBAAA,IAAI,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC;AAC/B,gBAAA,MAAM,GAAG,IAAI,GAAG,CAAC,OAAO,CAAC,CAAC;AACzB,iBAAA,IAAI,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,QAAQ,CAAC;AAClC,gBAAA,MAAM,GAAG,IAAI,GAAG,CAAC,UAAU,CAAC,CAAC;;AAE7B,gBAAA,MAAM,GAAG,IAAI,CAAC,8BAA8B,EAAE,IAAI,IAAI,CAAC,oBAAoB,EAAE,IAAI,IAAI,CAAC,qBAAqB,EAAE,CAAC;YAElH,IAAI,MAAM,IAAI,IAAI;gBACd,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,SAAS,EAAE,+BAA+B,CAAC,CAAC;AAEpE,YAAA,OAAO,MAAM,CAAC;SACjB;QAED,wBAAwB,GAAA;YACpB,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,aAAa,CAAC;AACnC,gBAAA,OAAO,IAAI,CAAC;AAChB,YAAA,IAAI,UAAU,GAAG,IAAI,CAAC,0BAA0B,EAAE,CAAC;YACnD,OAAO,IAAI,GAAG,CAAC,eAAe,EAAE,EAAE,UAAU,EAAE,CAAC,CAAC;SACnD;QAED,gBAAgB,GAAA;YACZ,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC;AAC3B,gBAAA,OAAO,IAAI,CAAC;AAChB,YAAA,IAAI,SAAS,GAAG,IAAI,CAAC,0BAA0B,EAAE,CAAC;AAClD,YAAA,MAAM,KAAK,GAAG,IAAI,CAAC,mBAAmB,EAAE,CAAC;YACzC,OAAO,IAAI,GAAG,CAAC,OAAO,EAAE,EAAE,SAAS,EAAE,KAAK,EAAE,CAAC,CAAC;SACjD;QAED,cAAc,GAAA;;YAEV,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC;AACzB,gBAAA,OAAO,IAAI,CAAC;YAEhB,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,UAAU,EAAE,eAAe,CAAC,CAAC;;YAGjD,MAAM,IAAI,GAAG,CAAC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,SAAS,CAAC,GAAG,IAAI,CAAC,SAAS,EAAE,GAAG,IAAI,CAAC;YACrE,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,SAAS,EAAE,eAAe,CAAC,CAAC;YAChD,MAAM,SAAS,GAAG,CAAC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,SAAS,CAAC,GAAG,IAAI,CAAC,4BAA4B,EAAE,GAAG,IAAI,CAAC;YAC7F,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,SAAS,EAAE,eAAe,CAAC,CAAC;YAChD,MAAM,SAAS,GAAG,CAAC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,WAAW,CAAC,GAAG,IAAI,CAAC,cAAc,EAAE,GAAG,IAAI,CAAC;YAEjF,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,WAAW,EAAE,eAAe,CAAC,CAAC;AAElD,YAAA,MAAM,IAAI,GAAG,IAAI,CAAC,mBAAmB,EAAE,CAAC;AAExC,YAAA,OAAO,IAAI,GAAG,CAAC,KAAK,EAAE,EAAE,IAAI,EAAE,SAAS,EAAE,SAAS,EAAE,IAAI,EAAE,CAAC,CAAC;SAC/D;QAED,SAAS,GAAA;;AAEL,YAAA,OAAO,IAAI,CAAC,mBAAmB,EAAE,IAAI,IAAI,CAAC,oBAAoB,EAAE,IAAI,IAAI,CAAC,qBAAqB,EAAE,CAAC;SACpG;QAED,cAAc,GAAA;;AAEV,YAAA,OAAO,IAAI,CAAC,8BAA8B,EAAE,IAAI,IAAI,CAAC,oBAAoB,EAAE,IAAI,IAAI,CAAC,qBAAqB,EAAE,CAAC;SAC/G;QAED,mBAAmB,GAAA;;;;;YAKf,IAAI,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE;AAC1B,gBAAA,MAAM,IAAI,GAAG,IAAI,CAAC,cAAc,EAAE,CAAC;gBACnC,IAAI,KAAK,GAAG,IAAI,CAAC;AACjB,gBAAA,IAAI,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC;AACxB,oBAAA,KAAK,GAAG,IAAI,CAAC,4BAA4B,EAAE,CAAC;AAEhD,gBAAA,OAAO,IAAI,GAAG,CAAC,KAAK,EAAE,EAAE,GAAG,EAAE,IAAI,EAAE,KAAK,EAAE,CAAC,CAAC;AAC/C,aAAA;YAED,IAAI,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE;AAC1B,gBAAA,MAAM,IAAI,GAAG,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,KAAK,EAAE,wBAAwB,CAAC,CAAC,QAAQ,EAAE,CAAC;gBAC7E,IAAI,IAAI,GAAG,IAAI,CAAC;gBAChB,IAAI,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,EAAE;AAC1B,oBAAA,MAAM,SAAS,GAAG,IAAI,CAAC,UAAU,EAAE,CAAC;AACpC,oBAAA,IAAI,GAAG,IAAI,CAAC,UAAU,EAAE,CAAC;AACzB,oBAAA,IAAI,CAAC,UAAU,GAAG,SAAS,CAAC;AAC/B,iBAAA;gBACD,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,KAAK,EAAE,uBAAuB,CAAC,CAAC;AACpD,gBAAA,MAAM,KAAK,GAAG,IAAI,CAAC,4BAA4B,EAAE,CAAC;AAClD,gBAAA,OAAO,IAAI,GAAG,CAAC,KAAK,EAAE,EAAE,IAAI,EAAE,IAAI,EAAE,KAAK,EAAE,CAAC,CAAC;AAChD,aAAA;YAED,IAAI,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE;AAC5B,gBAAA,MAAM,IAAI,GAAG,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,KAAK,EAAE,0BAA0B,CAAC,CAAC,QAAQ,EAAE,CAAC;gBAC/E,IAAI,IAAI,GAAG,IAAI,CAAC;gBAChB,IAAI,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,EAAE;AAC1B,oBAAA,MAAM,SAAS,GAAG,IAAI,CAAC,UAAU,EAAE,CAAC;AACpC,oBAAA,IAAI,GAAG,IAAI,CAAC,UAAU,EAAE,CAAC;AACzB,oBAAA,IAAI,CAAC,UAAU,GAAG,SAAS,CAAC;AAC/B,iBAAA;gBACD,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,KAAK,EAAE,yBAAyB,CAAC,CAAC;AACtD,gBAAA,MAAM,KAAK,GAAG,IAAI,CAAC,4BAA4B,EAAE,CAAC;AAClD,gBAAA,OAAO,IAAI,GAAG,CAAC,OAAO,EAAE,EAAE,IAAI,EAAE,IAAI,EAAE,KAAK,EAAE,CAAC,CAAC;AAClD,aAAA;AAED,YAAA,OAAO,IAAI,CAAC;SACf;QAED,8BAA8B,GAAA;AAC1B,YAAA,MAAM,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC;AAE/B,YAAA,MAAM,IAAI,GAAG,IAAI,CAAC,iBAAiB,EAAE,CAAC;YACtC,IAAI,IAAI,IAAI,IAAI;AACZ,gBAAA,OAAO,IAAI,CAAC;YAEhB,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,mBAAmB,CAAC,EAAE;AACzC,gBAAA,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;AACzB,gBAAA,OAAO,IAAI,CAAC;AACf,aAAA;AAED,YAAA,MAAM,IAAI,GAAG,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,mBAAmB,EAAE,6BAA6B,CAAC,CAAC;AAErF,YAAA,OAAO,IAAI,GAAG,CAAC,WAAW,EAAE,EAAE,IAAI,EAAE,GAAG,EAAE,IAAI,EAAE,CAAC,CAAC;SACpD;QAED,qBAAqB,GAAA;;YAEjB,IAAI,IAAI,GAAG,IAAI,CAAC;AAEhB,YAAA,IAAI,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,WAAW,CAAC;AAC9B,gBAAA,OAAO,IAAI,CAAC;YAEhB,IAAI,YAAY,GAAG,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,UAAU,CAAC,CAAC;AACjD,YAAA,IAAI,CAAC,YAAY;AACb,gBAAA,IAAI,GAAG,IAAI,CAAC,iBAAiB,EAAE,CAAC;AAEpC,YAAA,IAAI,CAAC,YAAY,IAAI,IAAI,IAAI,IAAI;AAC7B,gBAAA,OAAO,IAAI,CAAC;AAEhB,YAAA,MAAM,IAAI,GAAG,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,oBAAoB,EAAE,+BAA+B,CAAC,CAAC;AAExF,YAAA,MAAM,KAAK,GAAG,IAAI,CAAC,4BAA4B,EAAE,CAAC;AAElD,YAAA,OAAO,IAAI,GAAG,CAAC,QAAQ,EAAE,EAAE,IAAI,EAAE,GAAG,EAAE,IAAI,EAAE,KAAK,EAAE,CAAC,CAAC;SACxD;QAED,oBAAoB,GAAA;;YAEhB,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC;AACzB,gBAAA,OAAO,IAAI,CAAC;AAEhB,YAAA,MAAM,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC;AAC/B,YAAA,MAAM,IAAI,GAAG,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,KAAK,EAAE,yBAAyB,CAAC,CAAC;AACnE,YAAA,MAAM,IAAI,GAAG,IAAI,CAAC,yBAAyB,EAAE,CAAC;YAE9C,IAAI,IAAI,KAAK,IAAI,EAAE;AACf,gBAAA,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;AACzB,gBAAA,OAAO,IAAI,CAAC;AACf,aAAA;YAED,OAAO,IAAI,GAAG,CAAC,MAAM,EAAE,EAAE,IAAI,EAAE,IAAI,EAAE,CAAC,CAAC;SAC1C;QAED,eAAe,GAAA;;YAEX,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC;AAC1B,gBAAA,OAAO,IAAI,CAAC;YAEhB,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,UAAU,EAAE,wBAAwB,CAAC,CAAC;;YAG1D,MAAM,UAAU,GAAG,EAAE,CAAC;AACtB,YAAA,IAAI,SAAS,GAAG,IAAI,CAAC,UAAU,EAAE,CAAC;YAClC,OAAO,SAAS,KAAK,IAAI,EAAE;AACvB,gBAAA,UAAU,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;AAC3B,gBAAA,SAAS,GAAG,IAAI,CAAC,UAAU,EAAE,CAAC;AACjC,aAAA;;YAGD,IAAI,UAAU,GAAG,IAAI,CAAC;AACtB,YAAA,IAAI,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,UAAU,CAAC;AAC/B,gBAAA,UAAU,GAAG,IAAI,CAAC,mBAAmB,EAAE,CAAC;YAE5C,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,WAAW,EAAE,wBAAwB,CAAC,CAAC;YAE3D,OAAO,IAAI,GAAG,CAAC,MAAM,EAAE,EAAE,UAAU,EAAE,UAAU,EAAE,CAAC,CAAC;SACtD;QAED,iBAAiB,GAAA;;YAEb,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC;AAC5B,gBAAA,OAAO,IAAI,CAAC;AAEhB,YAAA,MAAM,SAAS,GAAG,IAAI,CAAC,0BAA0B,EAAE,CAAC;AACpD,YAAA,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,UAAU,CAAC,CAAC;AAChC,YAAA,MAAM,IAAI,GAAG,IAAI,CAAC,YAAY,EAAE,CAAC;YACjC,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,CAAC,MAAM,IAAI,CAAC;gBAChC,MAAM,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,SAAS,EAAE,EAAE,+BAA+B,CAAC,CAAC;AACzE,YAAA,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,WAAW,CAAC,CAAC;YACjC,OAAO,IAAI,GAAG,CAAC,QAAQ,EAAE,EAAE,SAAS,EAAE,IAAI,EAAE,CAAC,CAAC;SACjD;QAED,YAAY,GAAA;;;YAGR,MAAM,KAAK,GAAG,EAAE,CAAC;YACjB,IAAI,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE;AAC3B,gBAAA,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;AAC5B,gBAAA,MAAM,QAAQ,GAAG,IAAI,CAAC,eAAe,EAAE,CAAC;gBACxC,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,KAAK,EAAE,8BAA8B,CAAC,CAAC;gBAC3D,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,UAAU,EAAE,8BAA8B,CAAC,CAAC;AAChE,gBAAA,MAAM,IAAI,GAAG,IAAI,CAAC,UAAU,EAAE,CAAC;gBAC/B,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,WAAW,EAAE,8BAA8B,CAAC,CAAC;AACjE,gBAAA,KAAK,CAAC,IAAI,CAAC,IAAI,GAAG,CAAC,MAAM,EAAE,EAAE,QAAQ,EAAE,IAAI,EAAE,CAAC,CAAC,CAAC;AACnD,aAAA;YAED,IAAI,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC,EAAE;gBAC9B,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,KAAK,EAAE,iCAAiC,CAAC,CAAC;gBAC9D,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,UAAU,EAAE,iCAAiC,CAAC,CAAC;AACnE,gBAAA,MAAM,IAAI,GAAG,IAAI,CAAC,UAAU,EAAE,CAAC;gBAC/B,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,WAAW,EAAE,iCAAiC,CAAC,CAAC;AACpE,gBAAA,KAAK,CAAC,IAAI,CAAC,IAAI,GAAG,CAAC,SAAS,EAAE,EAAE,IAAI,EAAE,CAAC,CAAC,CAAC;AAC5C,aAAA;AAED,YAAA,IAAI,IAAI,CAAC,MAAM,CAAC,CAAC,OAAO,CAAC,OAAO,EAAE,OAAO,CAAC,IAAI,CAAC,CAAC,EAAE;AAC9C,gBAAA,MAAM,MAAM,GAAG,IAAI,CAAC,YAAY,EAAE,CAAC;gBACnC,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;AACzB,aAAA;AAED,YAAA,OAAO,KAAK,CAAC;SAChB;QAED,eAAe,GAAA;;AAEX,YAAA,MAAM,SAAS,GAAG,CAAC,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,aAAa,EAAE,2BAA2B,CAAC,CAAC,QAAQ,EAAE,CAAC,CAAC;YAC/F,OAAO,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,EAAE;AAC7B,gBAAA,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,aAAa,EAAE,2BAA2B,CAAC,CAAC,QAAQ,EAAE,CAAC,CAAC;AAC9F,aAAA;AACD,YAAA,OAAO,SAAS,CAAC;SACpB;QAED,UAAU,GAAA;;;YAGN,IAAI,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,WAAW,CAAC,EAAE;AAClC,gBAAA,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;AAC/B,gBAAA,OAAO,EAAE,CAAC;AACb,aAAA;AAED,YAAA,MAAM,SAAS,GAAG,IAAI,CAAC,UAAU,EAAE,CAAC;YACpC,IAAI,SAAS,IAAI,IAAI;AACjB,gBAAA,OAAO,EAAE,CAAC;AAEd,YAAA,MAAM,aAAa,GAAG,IAAI,CAAC,UAAU,EAAE,CAAC;AACxC,YAAA,IAAI,aAAa,CAAC,MAAM,IAAI,CAAC;gBACzB,OAAO,CAAC,SAAS,CAAC,CAAC;YAEvB,OAAO,CAAC,SAAS,EAAE,aAAa,CAAC,CAAC,CAAC,CAAC,CAAC;SACxC;QAED,aAAa,GAAA;;YAET,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,EAAE,CAAC;AACxB,gBAAA,OAAO,IAAI,CAAC;AAEhB,YAAA,MAAM,SAAS,GAAG,IAAI,CAAC,0BAA0B,EAAE,CAAC;AACpD,YAAA,MAAM,KAAK,GAAG,IAAI,CAAC,mBAAmB,EAAE,CAAC;YAEzC,IAAI,MAAM,GAAG,IAAI,CAAC;AAClB,YAAA,IAAI,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC;AAC3B,gBAAA,MAAM,GAAG,IAAI,CAAC,iBAAiB,EAAE,CAAC;YAEtC,IAAI,KAAK,GAAG,IAAI,CAAC;AACjB,YAAA,IAAI,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC;AACzB,gBAAA,KAAK,GAAG,IAAI,CAAC,mBAAmB,EAAE,CAAC;AAEvC,YAAA,OAAO,IAAI,GAAG,CAAC,IAAI,EAAE,EAAE,SAAS,EAAE,KAAK,EAAE,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,CAAC,CAAC;SACnE;QAED,iBAAiB,GAAA;;YAEb,MAAM,MAAM,GAAG,EAAE,CAAC;AAClB,YAAA,MAAM,SAAS,GAAG,IAAI,CAAC,0BAA0B,EAAE,CAAC;AACpD,YAAA,MAAM,KAAK,GAAG,IAAI,CAAC,mBAAmB,EAAE,CAAC;AACzC,YAAA,MAAM,CAAC,IAAI,CAAC,IAAI,GAAG,CAAC,QAAQ,EAAE,EAAE,SAAS,EAAE,KAAK,EAAE,CAAC,CAAC,CAAC;AACrD,YAAA,IAAI,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC;gBAC3B,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,iBAAiB,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;AAC7C,YAAA,OAAO,MAAM,CAAC;SACjB;QAED,iBAAiB,GAAA;;YAEb,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC;AAC5B,gBAAA,OAAO,IAAI,CAAC;AAChB,YAAA,MAAM,KAAK,GAAG,IAAI,CAAC,4BAA4B,EAAE,CAAC;YAClD,OAAO,IAAI,GAAG,CAAC,QAAQ,EAAE,EAAE,KAAK,EAAE,KAAK,EAAE,CAAC,CAAC;SAC9C;QAED,4BAA4B,GAAA;;;AAGxB,YAAA,IAAI,IAAI,GAAG,IAAI,CAAC,uBAAuB,EAAE,CAAC;YAC1C,OAAO,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,EAAE;AAC7B,gBAAA,IAAI,GAAG,IAAI,GAAG,CAAC,WAAW,EAAE;AACxB,oBAAA,QAAQ,EAAE,IAAI,CAAC,SAAS,EAAE,CAAC,QAAQ,EAAE;AACrC,oBAAA,IAAI,EAAE,IAAI;AACV,oBAAA,KAAK,EAAE,IAAI,CAAC,uBAAuB,EAAE;AACxC,iBAAA,CAAC,CAAC;AACN,aAAA;AACD,YAAA,OAAO,IAAI,CAAC;SACf;QAED,uBAAuB,GAAA;;;AAGnB,YAAA,IAAI,IAAI,GAAG,IAAI,CAAC,wBAAwB,EAAE,CAAC;YAC3C,OAAO,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,OAAO,CAAC,EAAE;AAC/B,gBAAA,IAAI,GAAG,IAAI,GAAG,CAAC,WAAW,EAAE;AACxB,oBAAA,QAAQ,EAAE,IAAI,CAAC,SAAS,EAAE,CAAC,QAAQ,EAAE;AACrC,oBAAA,IAAI,EAAE,IAAI;AACV,oBAAA,KAAK,EAAE,IAAI,CAAC,wBAAwB,EAAE;AACzC,iBAAA,CAAC,CAAC;AACN,aAAA;AACD,YAAA,OAAO,IAAI,CAAC;SACf;QAED,wBAAwB,GAAA;;;AAGpB,YAAA,IAAI,IAAI,GAAG,IAAI,CAAC,wBAAwB,EAAE,CAAC;YAC3C,OAAO,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE;AAC1B,gBAAA,IAAI,GAAG,IAAI,GAAG,CAAC,UAAU,EAAE;AACvB,oBAAA,QAAQ,EAAE,IAAI,CAAC,SAAS,EAAE,CAAC,QAAQ,EAAE;AACrC,oBAAA,IAAI,EAAE,IAAI;AACV,oBAAA,KAAK,EAAE,IAAI,CAAC,wBAAwB,EAAE;AACzC,iBAAA,CAAC,CAAC;AACN,aAAA;AACD,YAAA,OAAO,IAAI,CAAC;SACf;QAED,wBAAwB,GAAA;;;AAGpB,YAAA,IAAI,IAAI,GAAG,IAAI,CAAC,eAAe,EAAE,CAAC;YAClC,OAAO,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,EAAE;AAC3B,gBAAA,IAAI,GAAG,IAAI,GAAG,CAAC,UAAU,EAAE;AACvB,oBAAA,QAAQ,EAAE,IAAI,CAAC,SAAS,EAAE,CAAC,QAAQ,EAAE;AACrC,oBAAA,IAAI,EAAE,IAAI;AACV,oBAAA,KAAK,EAAE,IAAI,CAAC,eAAe,EAAE;AAChC,iBAAA,CAAC,CAAC;AACN,aAAA;AACD,YAAA,OAAO,IAAI,CAAC;SACf;QAED,eAAe,GAAA;;;AAGX,YAAA,IAAI,IAAI,GAAG,IAAI,CAAC,oBAAoB,EAAE,CAAC;YACvC,OAAO,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,EAAE;AAC3B,gBAAA,IAAI,GAAG,IAAI,GAAG,CAAC,UAAU,EAAE;AACvB,oBAAA,QAAQ,EAAE,IAAI,CAAC,SAAS,EAAE,CAAC,QAAQ,EAAE;AACrC,oBAAA,IAAI,EAAE,IAAI;AACV,oBAAA,KAAK,EAAE,IAAI,CAAC,oBAAoB,EAAE;AACrC,iBAAA,CAAC,CAAC;AACN,aAAA;AACD,YAAA,OAAO,IAAI,CAAC;SACf;QAED,oBAAoB,GAAA;;;;AAIhB,YAAA,MAAM,IAAI,GAAG,IAAI,CAAC,sBAAsB,EAAE,CAAC;AAC3C,YAAA,IAAI,IAAI,CAAC,MAAM,CAAC,CAAC,KAAK,CAAC,WAAW,EAAE,KAAK,CAAC,SAAS,CAAC,CAAC,EAAE;AACnD,gBAAA,OAAO,IAAI,GAAG,CAAC,WAAW,EAAE;AACxB,oBAAA,QAAQ,EAAE,IAAI,CAAC,SAAS,EAAE,CAAC,QAAQ,EAAE;AACrC,oBAAA,IAAI,EAAE,IAAI;AACV,oBAAA,KAAK,EAAE,IAAI,CAAC,sBAAsB,EAAE;AACvC,iBAAA,CAAC,CAAC;AACN,aAAA;AACD,YAAA,OAAO,IAAI,CAAC;SACf;QAED,sBAAsB,GAAA;;;;;;AAMlB,YAAA,IAAI,IAAI,GAAG,IAAI,CAAC,iBAAiB,EAAE,CAAC;AACpC,YAAA,OAAO,IAAI,CAAC,MAAM,CAAC,CAAC,KAAK,CAAC,SAAS,EAAE,KAAK,CAAC,YAAY,EAAE,KAAK,CAAC,eAAe;AAC9E,gBAAA,KAAK,CAAC,kBAAkB,CAAC,CAAC,EAAE;AACxB,gBAAA,IAAI,GAAG,IAAI,GAAG,CAAC,WAAW,EAAE;AACxB,oBAAA,QAAQ,EAAE,IAAI,CAAC,SAAS,EAAE,CAAC,QAAQ,EAAE;AACrC,oBAAA,IAAI,EAAE,IAAI;AACV,oBAAA,KAAK,EAAE,IAAI,CAAC,iBAAiB,EAAE;AAClC,iBAAA,CAAC,CAAC;AACN,aAAA;AACD,YAAA,OAAO,IAAI,CAAC;SACf;QAED,iBAAiB,GAAA;;;;AAIb,YAAA,IAAI,IAAI,GAAG,IAAI,CAAC,oBAAoB,EAAE,CAAC;AACvC,YAAA,OAAO,IAAI,CAAC,MAAM,CAAC,CAAC,KAAK,CAAC,UAAU,EAAE,KAAK,CAAC,WAAW,CAAC,CAAC,EAAE;AACvD,gBAAA,IAAI,GAAG,IAAI,GAAG,CAAC,UAAU,EAAE;AACvB,oBAAA,QAAQ,EAAE,IAAI,CAAC,SAAS,EAAE,CAAC,QAAQ,EAAE;AACrC,oBAAA,IAAI,EAAE,IAAI;AACV,oBAAA,KAAK,EAAE,IAAI,CAAC,oBAAoB,EAAE;AACrC,iBAAA,CAAC,CAAC;AACN,aAAA;AACD,YAAA,OAAO,IAAI,CAAC;SACf;QAED,oBAAoB,GAAA;;;;AAIhB,YAAA,IAAI,IAAI,GAAG,IAAI,CAAC,0BAA0B,EAAE,CAAC;AAC7C,YAAA,OAAO,IAAI,CAAC,MAAM,CAAC,CAAC,KAAK,CAAC,IAAI,EAAE,KAAK,CAAC,KAAK,CAAC,CAAC,EAAE;AAC3C,gBAAA,IAAI,GAAG,IAAI,GAAG,CAAC,UAAU,EAAE;AACvB,oBAAA,QAAQ,EAAE,IAAI,CAAC,SAAS,EAAE,CAAC,QAAQ,EAAE;AACrC,oBAAA,IAAI,EAAE,IAAI;AACV,oBAAA,KAAK,EAAE,IAAI,CAAC,0BAA0B,EAAE;AAC3C,iBAAA,CAAC,CAAC;AACN,aAAA;AACD,YAAA,OAAO,IAAI,CAAC;SACf;QAED,0BAA0B,GAAA;;;;;AAKtB,YAAA,IAAI,IAAI,GAAG,IAAI,CAAC,iBAAiB,EAAE,CAAC;AACpC,YAAA,OAAO,IAAI,CAAC,MAAM,CAAC,CAAC,KAAK,CAAC,IAAI,EAAE,KAAK,CAAC,aAAa,EAAE,KAAK,CAAC,MAAM,CAAC,CAAC,EAAE;AACjE,gBAAA,IAAI,GAAG,IAAI,GAAG,CAAC,UAAU,EAAE;AACvB,oBAAA,QAAQ,EAAE,IAAI,CAAC,SAAS,EAAE,CAAC,QAAQ,EAAE;AACrC,oBAAA,IAAI,EAAE,IAAI;AACV,oBAAA,KAAK,EAAE,IAAI,CAAC,iBAAiB,EAAE;AAClC,iBAAA,CAAC,CAAC;AACN,aAAA;AACD,YAAA,OAAO,IAAI,CAAC;SACf;QAED,iBAAiB,GAAA;;;;;;;YAOb,IAAI,IAAI,CAAC,MAAM,CAAC,CAAC,KAAK,CAAC,KAAK,EAAE,KAAK,CAAC,IAAI,EAAE,KAAK,CAAC,KAAK,EAAE,KAAK,CAAC,IAAI,EAAE,KAAK,CAAC,GAAG,CAAC,CAAC,EAAE;AAC5E,gBAAA,OAAO,IAAI,GAAG,CAAC,SAAS,EAAE;AACtB,oBAAA,QAAQ,EAAE,IAAI,CAAC,SAAS,EAAE,CAAC,QAAQ,EAAE,EAAE,KAAK,EAAE,IAAI,CAAC,iBAAiB,EAAE;AACzE,iBAAA,CAAC,CAAC;AACN,aAAA;AACD,YAAA,OAAO,IAAI,CAAC,oBAAoB,EAAE,CAAC;SACtC;QAED,oBAAoB,GAAA;;AAEhB,YAAA,MAAM,IAAI,GAAG,IAAI,CAAC,mBAAmB,EAAE,CAAC;AACxC,YAAA,MAAM,CAAC,GAAG,IAAI,CAAC,mBAAmB,EAAE,CAAC;AACrC,YAAA,IAAI,CAAC;AACD,gBAAA,IAAI,CAAC,OAAO,GAAG,CAAC,CAAC;AACrB,YAAA,OAAO,IAAI,CAAC;SACf;QAED,mBAAmB,GAAA;;YAEf,IAAI,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,YAAY,CAAC,EAAE;AACjC,gBAAA,MAAM,IAAI,GAAG,IAAI,CAAC,4BAA4B,EAAE,CAAC;gBACjD,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,aAAa,EAAE,eAAe,CAAC,CAAC;AACpD,gBAAA,MAAM,CAAC,GAAG,IAAI,CAAC,mBAAmB,EAAE,CAAC;AACrC,gBAAA,IAAI,CAAC;AACD,oBAAA,IAAI,CAAC,OAAO,GAAG,CAAC,CAAC;AACrB,gBAAA,OAAO,IAAI,CAAC;AACf,aAAA;;YAGD,IAAI,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC,EAAE;AAC3B,gBAAA,MAAM,IAAI,GAAG,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,KAAK,EAAE,uBAAuB,CAAC,CAAC;AACjE,gBAAA,MAAM,CAAC,GAAG,IAAI,CAAC,mBAAmB,EAAE,CAAC;AACrC,gBAAA,IAAI,CAAC;AACD,oBAAA,IAAI,CAAC,OAAO,GAAG,CAAC,CAAC;AACrB,gBAAA,OAAO,IAAI,CAAC;AACf,aAAA;AAED,YAAA,OAAO,IAAI,CAAC;SACf;QAED,mBAAmB,GAAA;;YAEf,IAAI,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,EAAE;gBAC1B,MAAM,IAAI,GAAG,IAAI,CAAC,SAAS,EAAE,CAAC,QAAQ,EAAE,CAAC;gBACzC,IAAI,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,UAAU,CAAC,EAAE;AAC/B,oBAAA,MAAM,IAAI,GAAG,IAAI,CAAC,yBAAyB,EAAE,CAAC;oBAC9C,OAAO,IAAI,GAAG,CAAC,WAAW,EAAE,EAAE,IAAI,EAAE,IAAI,EAAE,CAAC,CAAC;AAC/C,iBAAA;gBACD,OAAO,IAAI,GAAG,CAAC,eAAe,EAAE,EAAE,IAAI,EAAE,CAAC,CAAC;AAC7C,aAAA;;YAGD,IAAI,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,aAAa,CAAC,EAAE;AAClC,gBAAA,OAAO,IAAI,GAAG,CAAC,cAAc,EAAE,EAAE,KAAK,EAAE,IAAI,CAAC,SAAS,EAAE,CAAC,QAAQ,EAAE,EAAE,CAAC,CAAC;AAC1E,aAAA;;YAGD,IAAI,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,UAAU,CAAC,EAAE;AAC/B,gBAAA,OAAO,IAAI,CAAC,iBAAiB,EAAE,CAAC;AACnC,aAAA;;YAGD,IAAI,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC,EAAE;gBAC9B,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,SAAS,EAAE,eAAe,CAAC,CAAC;AAChD,gBAAA,MAAM,IAAI,GAAG,IAAI,CAAC,UAAU,EAAE,CAAC;gBAC/B,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,YAAY,EAAE,eAAe,CAAC,CAAC;AACnD,gBAAA,MAAM,KAAK,GAAG,IAAI,CAAC,iBAAiB,EAAE,CAAC;gBACvC,OAAO,IAAI,GAAG,CAAC,cAAc,EAAE,EAAE,IAAI,EAAE,KAAK,EAAE,CAAC,CAAC;AACnD,aAAA;;AAGD,YAAA,MAAM,IAAI,GAAG,IAAI,CAAC,UAAU,EAAE,CAAC;AAC/B,YAAA,MAAM,IAAI,GAAG,IAAI,CAAC,yBAAyB,EAAE,CAAC;YAC9C,OAAO,IAAI,GAAG,CAAC,eAAe,EAAE,EAAE,IAAI,EAAE,IAAI,EAAE,CAAC,CAAC;SACnD;QAED,yBAAyB,GAAA;;YAErB,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,UAAU,CAAC;AAC9B,gBAAA,OAAO,IAAI,CAAC;YAEhB,MAAM,IAAI,GAAG,EAAE,CAAC;YAChB,GAAG;AACC,gBAAA,IAAI,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,WAAW,CAAC;oBAC9B,MAAM;AACV,gBAAA,MAAM,GAAG,GAAG,IAAI,CAAC,4BAA4B,EAAE,CAAC;AAChD,gBAAA,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;aAClB,QAAQ,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,EAAE;YACnC,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,WAAW,EAAE,+BAA+B,CAAC,CAAC;AAElE,YAAA,OAAO,IAAI,CAAC;SACf;QAED,0BAA0B,GAAA;;AAEtB,YAAA,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,UAAU,CAAC,CAAC;AAC9B,YAAA,MAAM,IAAI,GAAG,IAAI,CAAC,4BAA4B,EAAE,CAAC;AACjD,YAAA,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,WAAW,CAAC,CAAC;YAC/B,OAAO,IAAI,GAAG,CAAC,eAAe,EAAE,EAAE,QAAQ,EAAE,IAAI,EAAE,CAAC,CAAC;SACvD;QAED,iBAAiB,GAAA;;YAEb,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,UAAU,EAAE,eAAe,CAAC,CAAC;AACjD,YAAA,MAAM,IAAI,GAAG,IAAI,CAAC,4BAA4B,EAAE,CAAC;YACjD,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,WAAW,EAAE,eAAe,CAAC,CAAC;YAClD,OAAO,IAAI,GAAG,CAAC,eAAe,EAAE,EAAE,QAAQ,EAAE,IAAI,EAAE,CAAC,CAAC;SACvD;QAED,YAAY,GAAA;;YAER,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC;AAC5B,gBAAA,OAAO,IAAI,CAAC;AAEhB,YAAA,MAAM,IAAI,GAAG,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,KAAK,EAAE,2BAA2B,CAAC,CAAC,QAAQ,EAAE,CAAC;;YAGhF,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,UAAU,EAAE,+BAA+B,CAAC,CAAC;YACjE,MAAM,OAAO,GAAG,EAAE,CAAC;YACnB,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,WAAW,CAAC,EAAE;;AAEpC,gBAAA,MAAM,WAAW,GAAG,IAAI,CAAC,UAAU,EAAE,CAAC;AAEtC,gBAAA,MAAM,UAAU,GAAG,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,KAAK,EAAE,yBAAyB,CAAC,CAAC,QAAQ,EAAE,CAAC;gBAEpF,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,KAAK,EAAE,sCAAsC,CAAC,CAAC;AAEnE,gBAAA,MAAM,SAAS,GAAG,IAAI,CAAC,UAAU,EAAE,CAAC;AACpC,gBAAA,MAAM,UAAU,GAAG,IAAI,CAAC,UAAU,EAAE,CAAC;AACrC,gBAAA,UAAU,CAAC,UAAU,GAAG,SAAS,CAAC;gBAElC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,WAAW,CAAC;oBAC/B,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,KAAK,EAAE,iCAAiC,CAAC,CAAC;;oBAE9D,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;AAE7B,gBAAA,OAAO,CAAC,IAAI,CAAC,IAAI,GAAG,CAAC,QAAQ,EAAE;AAC3B,oBAAA,IAAI,EAAE,UAAU;AAChB,oBAAA,UAAU,EAAE,WAAW;AACvB,oBAAA,IAAI,EAAE,UAAU;AACnB,iBAAA,CAAC,CAAC,CAAC;AACP,aAAA;YAED,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,WAAW,EAAE,iCAAiC,CAAC,CAAC;YAEpE,OAAO,IAAI,GAAG,CAAC,QAAQ,EAAE,EAAE,IAAI,EAAE,OAAO,EAAE,CAAC,CAAC;SAC/C;QAED,qBAAqB,GAAA;;AAEjB,YAAA,MAAM,IAAI,GAAG,IAAI,CAAC,cAAc,EAAE,CAAC;AACnC,YAAA,IAAI,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC;AACxB,gBAAA,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,iBAAiB,EAAE,CAAC;AAC1C,YAAA,OAAO,IAAI,CAAC;SACf;QAED,qBAAqB,GAAA;;AAEjB,YAAA,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC;AACxD,gBAAA,OAAO,IAAI,CAAC;AAEhB,YAAA,MAAM,IAAI,GAAG,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,KAAK,EAAE,wBAAwB,CAAC,CAAC;YAClE,IAAI,IAAI,GAAG,IAAI,CAAC;YAChB,IAAI,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,EAAE;AAC1B,gBAAA,MAAM,KAAK,GAAG,IAAI,CAAC,UAAU,EAAE,CAAC;AAChC,gBAAA,IAAI,GAAG,IAAI,CAAC,UAAU,EAAE,CAAC;AACzB,gBAAA,IAAI,CAAC,UAAU,GAAG,KAAK,CAAC;AAC3B,aAAA;YACD,IAAI,KAAK,GAAG,IAAI,CAAC;YACjB,IAAI,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,EAAE;AAC1B,gBAAA,KAAK,GAAG,IAAI,CAAC,iBAAiB,EAAE,CAAC;AACpC,aAAA;AACD,YAAA,OAAO,IAAI,GAAG,CAAC,KAAK,EAAE,EAAE,IAAI,EAAE,IAAI,CAAC,QAAQ,EAAE,EAAE,IAAI,EAAE,KAAK,EAAE,CAAC,CAAC;SACjE;QAED,iBAAiB,GAAA;;;AAGb,YAAA,IAAI,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,aAAa,CAAC;AAChC,gBAAA,OAAO,IAAI,CAAC,SAAS,EAAE,CAAC,QAAQ,EAAE,CAAC;AAEvC,YAAA,MAAM,IAAI,GAAG,IAAI,CAAC,UAAU,EAAE,CAAC;YAE/B,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,UAAU,EAAE,eAAe,CAAC,CAAC;YAEjD,IAAI,IAAI,GAAG,EAAE,CAAC;YACd,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,WAAW,CAAC,EAAE;gBACpC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,iBAAiB,EAAE,CAAC,CAAC;gBACpC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC;oBACzB,MAAM;gBACV,IAAI,CAAC,QAAQ,EAAE,CAAC;AACnB,aAAA;YAED,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,WAAW,EAAE,eAAe,CAAC,CAAC;YAElD,OAAO,IAAI,GAAG,CAAC,QAAQ,EAAE,EAAE,IAAI,EAAE,IAAI,EAAE,CAAC,CAAC;SAC5C;QAED,cAAc,GAAA;;YAEV,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC;AACzB,gBAAA,OAAO,IAAI,CAAC;;YAGhB,IAAI,OAAO,GAAG,IAAI,CAAC;YACnB,IAAI,MAAM,GAAG,IAAI,CAAC;YAClB,IAAI,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,SAAS,CAAC,EAAE;AAC9B,gBAAA,OAAO,GAAG,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,aAAa,EAAE,yBAAyB,CAAC,CAAC,QAAQ,EAAE,CAAC;AACnF,gBAAA,IAAI,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC;AACxB,oBAAA,MAAM,GAAG,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,WAAW,EAAE,uBAAuB,CAAC,CAAC,QAAQ,EAAE,CAAC;gBAClF,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,YAAY,EAAE,eAAe,CAAC,CAAC;AACtD,aAAA;AAED,YAAA,MAAM,IAAI,GAAG,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,KAAK,EAAE,wBAAwB,CAAC,CAAC;YAClE,IAAI,IAAI,GAAG,IAAI,CAAC;YAChB,IAAI,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,EAAE;AAC1B,gBAAA,MAAM,KAAK,GAAG,IAAI,CAAC,UAAU,EAAE,CAAC;AAChC,gBAAA,IAAI,GAAG,IAAI,CAAC,UAAU,EAAE,CAAC;AACzB,gBAAA,IAAI,CAAC,UAAU,GAAG,KAAK,CAAC;AAC3B,aAAA;YAED,OAAO,IAAI,GAAG,CAAC,KAAK,EAAE,EAAE,IAAI,EAAE,IAAI,CAAC,QAAQ,EAAE,EAAE,IAAI,EAAE,OAAO,EAAE,MAAM,EAAE,CAAC,CAAC;SAC3E;QAED,iBAAiB,GAAA;;AAEb,YAAA,MAAM,IAAI,GAAG,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,KAAK,EAAE,oBAAoB,CAAC,CAAC;AAC9D,YAAA,OAAO,IAAI,GAAG,CAAC,QAAQ,EAAE,EAAE,IAAI,EAAE,IAAI,CAAC,QAAQ,EAAE,EAAE,CAAC,CAAC;SACvD;QAED,WAAW,GAAA;;AAEP,YAAA,MAAM,IAAI,GAAG,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,KAAK,EAAE,oBAAoB,CAAC,CAAC;YAC9D,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,KAAK,EAAE,8BAA8B,CAAC,CAAC;AAC3D,YAAA,MAAM,KAAK,GAAG,IAAI,CAAC,UAAU,EAAE,CAAC;AAChC,YAAA,OAAO,IAAI,GAAG,CAAC,OAAO,EAAE,EAAE,IAAI,EAAE,IAAI,CAAC,QAAQ,EAAE,EAAE,KAAK,EAAE,CAAC,CAAC;SAC7D;QAED,UAAU,GAAA;;;;;;;;;;;;;;;;;;;;;;AAuBN,YAAA,IAAI,IAAI,CAAC,MAAM,CAAC,CAAC,KAAK,CAAC,KAAK,EAAE,GAAG,KAAK,CAAC,YAAY,EAAE,OAAO,CAAC,IAAI,EAAE,OAAO,CAAC,OAAO,EAAE,OAAO,CAAC,KAAK,EAAE,OAAO,CAAC,MAAM,CAAC,CAAC,EAAE;AACjH,gBAAA,MAAM,IAAI,GAAG,IAAI,CAAC,QAAQ,EAAE,CAAC;AAC7B,gBAAA,OAAO,IAAI,GAAG,CAAC,MAAM,EAAE,EAAE,IAAI,EAAE,IAAI,CAAC,QAAQ,EAAE,EAAE,CAAC,CAAC;AACrD,aAAA;YAED,IAAI,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,cAAc,CAAC,EAAE;gBACnC,IAAI,IAAI,GAAG,IAAI,CAAC,QAAQ,EAAE,CAAC,QAAQ,EAAE,CAAC;gBACtC,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,SAAS,EAAE,wBAAwB,CAAC,CAAC;AACzD,gBAAA,MAAM,MAAM,GAAG,IAAI,CAAC,UAAU,EAAE,CAAC;gBACjC,IAAI,MAAM,GAAG,IAAI,CAAC;AAClB,gBAAA,IAAI,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC;AACxB,oBAAA,MAAM,GAAG,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,WAAW,EAAE,kCAAkC,CAAC,CAAC,QAAQ,EAAE,CAAC;gBAC7F,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,YAAY,EAAE,wBAAwB,CAAC,CAAC;AAC5D,gBAAA,OAAO,IAAI,GAAG,CAAC,IAAI,EAAE,EAAE,IAAI,EAAE,IAAI,EAAE,MAAM,EAAE,MAAM,EAAE,CAAC,CAAC;AACxD,aAAA;;YAGD,IAAI,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC,EAAE;gBAC9B,IAAI,OAAO,GAAG,IAAI,CAAC,SAAS,EAAE,CAAC,QAAQ,EAAE,CAAC;gBAC1C,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,SAAS,EAAE,2BAA2B,CAAC,CAAC;AAC5D,gBAAA,MAAM,OAAO,GAAG,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,aAAa,EAAE,oCAAoC,CAAC,CAAC;gBACzF,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,KAAK,EAAE,2BAA2B,CAAC,CAAC;AACxD,gBAAA,MAAM,IAAI,GAAG,IAAI,CAAC,UAAU,EAAE,CAAC;gBAC/B,IAAI,MAAM,GAAG,IAAI,CAAC;AAClB,gBAAA,IAAI,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC;AACxB,oBAAA,MAAM,GAAG,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,WAAW,EAAE,kCAAkC,CAAC,CAAC,QAAQ,EAAE,CAAC;gBAC7F,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,YAAY,EAAE,2BAA2B,CAAC,CAAC;gBAC/D,OAAO,IAAI,GAAG,CAAC,SAAS,EAAE,EAAE,IAAI,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,CAAC,QAAQ,EAAE,EAAE,IAAI,EAAE,MAAM,EAAE,CAAC,CAAC;AAC3F,aAAA;;AAGD,YAAA,IAAI,IAAI,GAAG,IAAI,CAAC,sBAAsB,EAAE,CAAC;AACzC,YAAA,IAAI,IAAI;AACJ,gBAAA,OAAO,IAAI,CAAC;;AAGhB,YAAA,MAAM,KAAK,GAAG,IAAI,CAAC,UAAU,EAAE,CAAC;;YAGhC,IAAI,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE;AAC5B,gBAAA,MAAM,KAAK,GAAG,IAAI,CAAC,SAAS,EAAE,CAAC;gBAC/B,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,SAAS,EAAE,8BAA8B,CAAC,CAAC;AAC/D,gBAAA,MAAM,MAAM,GAAG,IAAI,CAAC,UAAU,EAAE,CAAC;gBACjC,IAAI,KAAK,GAAG,IAAI,CAAC;AACjB,gBAAA,IAAI,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC;AACxB,oBAAA,KAAK,GAAG,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,wBAAwB,EAAE,mCAAmC,CAAC,CAAC,QAAQ,EAAE,CAAC;gBAC1G,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,YAAY,EAAE,yBAAyB,CAAC,CAAC;gBAE7D,OAAO,IAAI,GAAG,CAAC,OAAO,EAAE,EAAE,IAAI,EAAE,KAAK,CAAC,QAAQ,EAAE,EAAE,UAAU,EAAE,KAAK,EAAE,MAAM,EAAE,KAAK,EAAE,CAAC,CAAC;AACzF,aAAA;AAED,YAAA,OAAO,IAAI,CAAC;SACf;QAED,sBAAsB,GAAA;;AAElB,YAAA,IAAI,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,YAAY,CAAC;AAC/B,gBAAA,OAAO,IAAI,GAAG,CAAC,SAAS,EAAE,EAAE,IAAI,EAAE,IAAI,CAAC,SAAS,EAAE,CAAC,QAAQ,EAAE,EAAE,CAAC,CAAC;;AAGrE,YAAA,IAAI,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,kBAAkB,CAAC;AACrC,gBAAA,OAAO,IAAI,GAAG,CAAC,SAAS,EAAE,EAAE,IAAI,EAAE,IAAI,CAAC,SAAS,EAAE,CAAC,QAAQ,EAAE,EAAE,CAAC,CAAC;;;AAIrE,YAAA,IAAI,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,oBAAoB,CAAC;AACvC,gBAAA,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,yBAAyB,CAAC,EAAE;AAC9C,gBAAA,MAAM,OAAO,GAAG,IAAI,CAAC,SAAS,EAAE,CAAC;gBACjC,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,SAAS,EAAE,gCAAgC,CAAC,CAAC;AACjE,gBAAA,MAAM,MAAM,GAAG,IAAI,CAAC,UAAU,EAAE,CAAC;gBACjC,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,YAAY,EAAE,gCAAgC,CAAC,CAAC;AACpE,gBAAA,OAAO,IAAI,GAAG,CAAC,SAAS,EAAE,EAAE,IAAI,EAAE,OAAO,CAAC,QAAQ,EAAE,EAAE,MAAM,EAAE,CAAC,CAAC;AACnE,aAAA;;YAGD,IAAI,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,oBAAoB,CAAC,EAAE;AACzC,gBAAA,MAAM,OAAO,GAAG,IAAI,CAAC,SAAS,EAAE,CAAC;gBACjC,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,SAAS,EAAE,gCAAgC,CAAC,CAAC;AACjE,gBAAA,MAAM,MAAM,GAAG,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,YAAY,EAAE,uBAAuB,CAAC,CAAC,QAAQ,EAAE,CAAC;gBACrF,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,KAAK,EAAE,kCAAkC,CAAC,CAAC;AAC/D,gBAAA,MAAM,MAAM,GAAG,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,WAAW,EAAE,gDAAgD,CAAC,CAAC,QAAQ,EAAE,CAAC;gBAC7G,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,YAAY,EAAE,gCAAgC,CAAC,CAAC;AACpE,gBAAA,OAAO,IAAI,GAAG,CAAC,SAAS,EAAE,EAAE,IAAI,EAAE,OAAO,CAAC,QAAQ,EAAE,EAAE,MAAM,EAAE,MAAM,EAAE,CAAC,CAAC;AAC3E,aAAA;AAED,YAAA,OAAO,IAAI,CAAC;SACf;QAED,UAAU,GAAA;;;YAIN,IAAI,UAAU,GAAG,EAAE,CAAC;YAEpB,OAAO,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE;AAC5B,gBAAA,MAAM,IAAI,GAAG,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,cAAc,EAAE,yBAAyB,CAAC,CAAC;AAC5E,gBAAA,MAAM,IAAI,GAAG,IAAI,GAAG,CAAC,WAAW,EAAE,EAAE,IAAI,EAAE,IAAI,CAAC,QAAQ,EAAE,EAAE,CAAC,CAAC;gBAC7D,IAAI,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,UAAU,CAAC,EAAE;;AAE/B,oBAAA,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,gBAAgB,EAAE,0BAA0B,CAAC,CAAC,QAAQ,EAAE,CAAC;oBAC1F,IAAI,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,EAAE;wBAC1B,IAAI,CAAC,QAAQ,EAAE,CAAC;wBAChB,IAAI,CAAC,KAAK,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;wBAC1B,GAAG;AACC,4BAAA,MAAM,CAAC,GAAG,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,gBAAgB,EAAE,0BAA0B,CAAC,CAAC,QAAQ,EAAE,CAAC;AACvF,4BAAA,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;yBACtB,QAAQ,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,EAAE;AACtC,qBAAA;oBACD,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,WAAW,EAAE,cAAc,CAAC,CAAC;AACpD,iBAAA;AACD,gBAAA,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;AACzB,aAAA;;;YAID,OAAO,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,SAAS,CAAC,EAAE;gBACjC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,UAAU,CAAC,EAAE;oBAChC,GAAG;AACC,wBAAA,MAAM,IAAI,GAAG,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,cAAc,EAAE,yBAAyB,CAAC,CAAC;AAC5E,wBAAA,MAAM,IAAI,GAAG,IAAI,GAAG,CAAC,WAAW,EAAE,EAAE,IAAI,EAAE,IAAI,CAAC,QAAQ,EAAE,EAAE,CAAC,CAAC;wBAC7D,IAAI,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,UAAU,CAAC,EAAE;;AAE/B,4BAAA,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,gBAAgB,EAAE,0BAA0B,CAAC,CAAC,QAAQ,EAAE,CAAC;4BAC1F,IAAI,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,EAAE;gCAC1B,IAAI,CAAC,QAAQ,EAAE,CAAC;gCAChB,IAAI,CAAC,KAAK,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;gCAC1B,GAAG;AACC,oCAAA,MAAM,CAAC,GAAG,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,gBAAgB,EAAE,0BAA0B,CAAC,CAAC,QAAQ,EAAE,CAAC;AACvF,oCAAA,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;iCACtB,QAAQ,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,EAAE;AACtC,6BAAA;4BACD,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,WAAW,EAAE,cAAc,CAAC,CAAC;AACpD,yBAAA;AACD,wBAAA,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;qBACzB,QAAQ,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,EAAE;AAEtC,iBAAA;;gBAED,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,UAAU,EAAE,4CAA4C,CAAC,CAAC;AACjF,aAAA;AAED,YAAA,IAAI,UAAU,CAAC,MAAM,IAAI,CAAC;AACtB,gBAAA,OAAO,IAAI,CAAC;AAEhB,YAAA,OAAO,UAAU,CAAC;SACrB;AACJ,KAAA;AAED;;AAEG;AAEH,IAAA,MAAa,WAAW,CAAA;AACpB,QAAA,SAAS,CAAyB;AAClC,QAAA,OAAO,CAAuB;AAC9B,QAAA,WAAA,CAAY,IAAY,EAAA;AACpB,YAAA,IAAI,IAAI;AACJ,gBAAA,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;SAC7B;AAED,QAAA,UAAU,CAAC,IAAI,EAAA;AACX,YAAA,MAAM,MAAM,GAAG,IAAI,UAAU,EAAE,CAAC;YAChC,IAAI,CAAC,GAAG,GAAG,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;;AAG9B,YAAA,IAAI,CAAC,OAAO,GAAG,EAAE,CAAC;;AAElB,YAAA,IAAI,CAAC,QAAQ,GAAG,EAAE,CAAC;;AAEnB,YAAA,IAAI,CAAC,OAAO,GAAG,EAAE,CAAC;;AAElB,YAAA,IAAI,CAAC,QAAQ,GAAG,EAAE,CAAC;;AAEnB,YAAA,IAAI,CAAC,QAAQ,GAAG,EAAE,CAAC;;AAEnB,YAAA,IAAI,CAAC,SAAS,GAAG,EAAE,CAAC;;AAEpB,YAAA,IAAI,CAAC,OAAO,GAAG,EAAE,CAAC;;YAElB,IAAI,CAAC,KAAK,GAAG;AACT,gBAAA,MAAM,EAAE,EAAE;AACV,gBAAA,QAAQ,EAAE,EAAE;AACZ,gBAAA,OAAO,EAAE,EAAE;aACd,CAAC;AAEF,YAAA,KAAK,MAAM,IAAI,IAAI,IAAI,CAAC,GAAG,EAAE;AACzB,gBAAA,IAAI,IAAI,CAAC,KAAK,IAAI,QAAQ;AACtB,oBAAA,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;AAE5B,gBAAA,IAAI,IAAI,CAAC,KAAK,IAAI,OAAO;AACrB,oBAAA,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;AAE5B,gBAAA,IAAI,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,EAAE;oBACzB,MAAM,KAAK,GAAG,IAAI,CAAC,YAAY,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;oBAC/C,IAAI,CAAC,KAAK,GAAG,KAAK,IAAI,KAAK,CAAC,KAAK,GAAG,QAAQ,CAAC,KAAK,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;oBAC9D,MAAM,OAAO,GAAG,IAAI,CAAC,YAAY,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC;oBACnD,IAAI,CAAC,OAAO,GAAG,OAAO,IAAI,OAAO,CAAC,KAAK,GAAG,QAAQ,CAAC,OAAO,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;AACtE,oBAAA,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;AAC5B,iBAAA;AAED,gBAAA,IAAI,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,EAAE;oBACzB,MAAM,KAAK,GAAG,IAAI,CAAC,YAAY,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;oBAC/C,IAAI,CAAC,KAAK,GAAG,KAAK,IAAI,KAAK,CAAC,KAAK,GAAG,QAAQ,CAAC,KAAK,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;oBAC9D,MAAM,OAAO,GAAG,IAAI,CAAC,YAAY,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC;oBACnD,IAAI,CAAC,OAAO,GAAG,OAAO,IAAI,OAAO,CAAC,KAAK,GAAG,QAAQ,CAAC,OAAO,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;AACtE,oBAAA,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;AAC3B,iBAAA;AAED,gBAAA,IAAI,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,EAAE;oBACzB,MAAM,KAAK,GAAG,IAAI,CAAC,YAAY,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;oBAC/C,IAAI,CAAC,KAAK,GAAG,KAAK,IAAI,KAAK,CAAC,KAAK,GAAG,QAAQ,CAAC,KAAK,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;oBAC9D,MAAM,OAAO,GAAG,IAAI,CAAC,YAAY,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC;oBACnD,IAAI,CAAC,OAAO,GAAG,OAAO,IAAI,OAAO,CAAC,KAAK,GAAG,QAAQ,CAAC,OAAO,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;AACtE,oBAAA,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;AAC5B,iBAAA;AAED,gBAAA,IAAI,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,EAAE;oBACzB,MAAM,KAAK,GAAG,IAAI,CAAC,YAAY,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;oBAC/C,IAAI,CAAC,KAAK,GAAG,KAAK,IAAI,KAAK,CAAC,KAAK,GAAG,QAAQ,CAAC,KAAK,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;oBAC9D,MAAM,OAAO,GAAG,IAAI,CAAC,YAAY,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC;oBACnD,IAAI,CAAC,OAAO,GAAG,OAAO,IAAI,OAAO,CAAC,KAAK,GAAG,QAAQ,CAAC,OAAO,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;AACtE,oBAAA,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;AAC5B,iBAAA;AAED,gBAAA,IAAI,IAAI,CAAC,KAAK,IAAI,UAAU,EAAE;AAC1B,oBAAA,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;oBAC1B,MAAM,WAAW,GAAG,IAAI,CAAC,YAAY,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;oBACtD,MAAM,aAAa,GAAG,IAAI,CAAC,YAAY,CAAC,IAAI,EAAE,UAAU,CAAC,CAAC;oBAC1D,MAAM,YAAY,GAAG,IAAI,CAAC,YAAY,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC;AACxD,oBAAA,MAAM,KAAK,GAAG,WAAW,IAAI,aAAa,IAAI,YAAY,CAAC;AAC3D,oBAAA,IAAI,KAAK,EAAE;wBACP,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;AACpC,wBAAA,IAAI,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC;AACtB,4BAAA,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;;4BAElC,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;AACvC,qBAAA;AACJ,iBAAA;AACJ,aAAA;SACJ;AAED,QAAA,YAAY,CAAC,IAAI,EAAA;YACb,OAAO,IAAI,CAAC,KAAK,IAAI,KAAK,IAAI,WAAW,CAAC,YAAY,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;SACxF;AAED,QAAA,YAAY,CAAC,IAAI,EAAA;YACb,OAAO,IAAI,CAAC,KAAK,IAAI,KAAK,IAAI,WAAW,CAAC,YAAY,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;SACxF;AAED,QAAA,YAAY,CAAC,IAAI,EAAA;AACb,YAAA,OAAO,IAAI,IAAI,IAAI,CAAC,KAAK,IAAI,KAAK,IAAI,IAAI,CAAC,OAAO,IAAI,SAAS,CAAC;SACnE;AAED,QAAA,YAAY,CAAC,IAAI,EAAA;AACb,YAAA,OAAO,IAAI,IAAI,IAAI,CAAC,KAAK,IAAI,KAAK,IAAI,IAAI,CAAC,OAAO,IAAI,SAAS,CAAC;SACnE;QAED,UAAU,CAAC,IAAI,EAAE,MAAM,EAAA;AACnB,YAAA,IAAI,IAAI,CAAC,KAAK,IAAI,UAAU;AACxB,gBAAA,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;AACrB,YAAA,IAAI,CAAC,MAAM;gBACP,MAAM,GAAG,EAAE,CAAC;AAEhB,YAAA,KAAK,MAAM,GAAG,IAAI,IAAI,EAAE;gBACpB,MAAM,KAAK,GAAG,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,CAAC;AACtC,gBAAA,IAAI,KAAK;AACL,oBAAA,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;gBACvB,MAAM,MAAM,GAAG,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;AACxC,gBAAA,IAAI,MAAM;oBACN,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,OAAO,EAAE,MAAM,CAAC,CAAC;AAC/C,aAAA;AAED,YAAA,OAAO,MAAM,CAAC;SACjB;AAED,QAAA,aAAa,CAAC,IAAI,EAAA;AACd,YAAA,MAAM,QAAQ,GAAG,IAAI,CAAC,YAAY,CAAC,IAAI,EAAE,UAAU,CAAC,IAAI,IAAI,CAAC,YAAY,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC;AAC3F,YAAA,IAAI,QAAQ,EAAE;AACV,gBAAA,IAAI,KAAK,GAAG;oBACR,IAAI,EAAE,IAAI,CAAC,IAAI;oBACf,IAAI,EAAE,IAAI,CAAC,IAAI;AACf,oBAAA,KAAK,EAAE,IAAI;oBACX,YAAY,EAAE,QAAQ,CAAC,IAAI;oBAC3B,QAAQ,EAAE,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,KAAK,CAAC;iBAC3C,CAAC;gBACF,MAAM,aAAa,GAAG,IAAI,CAAC,YAAY,CAAC,IAAI,EAAE,eAAe,CAAC,CAAC;AAC/D,gBAAA,IAAI,aAAa;AACb,oBAAA,KAAK,CAAC,aAAa,GAAG,aAAa,CAAC,KAAK,CAAC;AAC9C,gBAAA,OAAO,KAAK,CAAC;AAChB,aAAA;AACD,YAAA,OAAO,IAAI,CAAC;SACf;AAED,QAAA,SAAS,CAAC,CAAC,EAAA;AACP,YAAA,MAAM,CAAC,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;AACtB,YAAA,OAAO,KAAK,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;SAC3B;AAED,QAAA,QAAQ,CAAC,IAAI,EAAA;AACT,YAAA,IAAI,CAAC,IAAI;AAAE,gBAAA,OAAO,IAAI,CAAC;AACvB,YAAA,IAAI,IAAI,CAAC,WAAW,KAAK,GAAG,EAAE;AAC1B,gBAAA,IAAI,IAAI,CAAC,KAAK,IAAI,MAAM;AACpB,oBAAA,OAAO,IAAI,CAAC;AAChB,gBAAA,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;AACpB,aAAA;AACD,YAAA,KAAK,MAAM,CAAC,IAAI,IAAI,CAAC,OAAO,EAAE;AAC1B,gBAAA,IAAI,CAAC,CAAC,IAAI,IAAI,IAAI;oBACd,OAAO,CAAC,CAAC,KAAK,CAAC;AACtB,aAAA;AACD,YAAA,OAAO,IAAI,CAAC;SACf;AAED,QAAA,SAAS,CAAC,IAAI,EAAA;AACV,YAAA,IAAI,CAAC,IAAI;AAAE,gBAAA,OAAO,IAAI,CAAC;AACvB,YAAA,IAAI,IAAI,CAAC,WAAW,KAAK,GAAG,EAAE;AAC1B,gBAAA,IAAI,IAAI,CAAC,KAAK,IAAI,QAAQ;AACtB,oBAAA,OAAO,IAAI,CAAC;AAChB,gBAAA,IAAI,IAAI,CAAC,KAAK,IAAI,MAAM;AACpB,oBAAA,OAAO,IAAI,CAAC;AAChB,gBAAA,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;AACpB,aAAA;AACD,YAAA,KAAK,MAAM,CAAC,IAAI,IAAI,CAAC,OAAO,EAAE;AAC1B,gBAAA,IAAI,CAAC,CAAC,IAAI,IAAI,IAAI;AACd,oBAAA,OAAO,CAAC,CAAC;AAChB,aAAA;AACD,YAAA,OAAO,IAAI,CAAC;SACf;QAED,YAAY,CAAC,IAAI,EAAE,IAAI,EAAA;AACnB,YAAA,IAAI,CAAC,IAAI,IAAI,CAAC,IAAI,CAAC,UAAU;AAAE,gBAAA,OAAO,IAAI,CAAC;AAC3C,YAAA,KAAK,IAAI,CAAC,IAAI,IAAI,CAAC,UAAU,EAAE;AAC3B,gBAAA,IAAI,CAAC,CAAC,IAAI,IAAI,IAAI;AACd,oBAAA,OAAO,CAAC,CAAC;AAChB,aAAA;AACD,YAAA,OAAO,IAAI,CAAC;SACf;QAED,aAAa,GAAA;YACT,MAAM,MAAM,GAAG,EAAE,CAAC;AAElB,YAAA,SAAS,SAAS,CAAC,KAAK,EAAE,OAAO,EAAA;AAC7B,gBAAA,IAAI,KAAK,IAAI,MAAM,CAAC,MAAM;AACtB,oBAAA,MAAM,CAAC,MAAM,GAAG,KAAK,GAAG,CAAC,CAAC;AAC9B,gBAAA,IAAI,MAAM,CAAC,KAAK,CAAC,KAAK,SAAS;AAC3B,oBAAA,MAAM,CAAC,KAAK,CAAC,GAAG,EAAE,CAAC;AAEvB,gBAAA,IAAI,OAAO,IAAI,MAAM,CAAC,KAAK,CAAC,CAAC,MAAM;oBAC/B,MAAM,CAAC,KAAK,CAAC,CAAC,MAAM,GAAG,OAAO,GAAG,CAAC,CAAC;aAC1C;AAED,YAAA,KAAK,MAAM,CAAC,IAAI,IAAI,CAAC,QAAQ,EAAE;gBAC3B,SAAS,CAAC,CAAC,CAAC,KAAK,EAAE,CAAC,CAAC,OAAO,CAAC,CAAC;gBAC9B,MAAM,KAAK,GAAG,MAAM,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC;gBAC9B,KAAK,CAAC,CAAC,CAAC,OAAO,CAAC,GAAG,EAAE,IAAI,EAAE,QAAQ,EAAE,QAAQ,EAAE,IAAI,CAAC,oBAAoB,CAAC,CAAC,CAAC,EAAE,CAAC;AACjF,aAAA;AAED,YAAA,KAAK,MAAM,CAAC,IAAI,IAAI,CAAC,OAAO,EAAE;gBAC1B,SAAS,CAAC,CAAC,CAAC,KAAK,EAAE,CAAC,CAAC,OAAO,CAAC,CAAC;gBAC9B,MAAM,KAAK,GAAG,MAAM,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC;gBAC9B,KAAK,CAAC,CAAC,CAAC,OAAO,CAAC,GAAG,EAAE,IAAI,EAAE,SAAS,EAAE,QAAQ,EAAE,IAAI,CAAC,oBAAoB,CAAC,CAAC,CAAC,EAAE,CAAC;AAClF,aAAA;AAED,YAAA,KAAK,MAAM,CAAC,IAAI,IAAI,CAAC,QAAQ,EAAE;gBAC3B,SAAS,CAAC,CAAC,CAAC,KAAK,EAAE,CAAC,CAAC,OAAO,CAAC,CAAC;gBAC9B,MAAM,KAAK,GAAG,MAAM,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC;AAC9B,gBAAA,KAAK,CAAC,CAAC,CAAC,OAAO,CAAC,GAAG,EAAE,IAAI,EAAE,SAAS,EAAE,QAAQ,EAAE,CAAC,EAAE,CAAC;AACvD,aAAA;AAED,YAAA,KAAK,MAAM,CAAC,IAAI,IAAI,CAAC,QAAQ,EAAE;gBAC3B,SAAS,CAAC,CAAC,CAAC,KAAK,EAAE,CAAC,CAAC,OAAO,CAAC,CAAC;gBAC9B,MAAM,KAAK,GAAG,MAAM,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC;AAC9B,gBAAA,KAAK,CAAC,CAAC,CAAC,OAAO,CAAC,GAAG,EAAE,IAAI,EAAE,SAAS,EAAE,QAAQ,EAAE,CAAC,EAAE,CAAC;AACvD,aAAA;AAED,YAAA,OAAO,MAAM,CAAC;SACjB;AAED,QAAA,oBAAoB,CAAC,IAAI,EAAA;AACrB,YAAA,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC;AACxB,gBAAA,OAAO,IAAI,CAAC;YAEhB,IAAI,KAAK,GAAG,IAAI,CAAC,YAAY,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;YAC7C,IAAI,OAAO,GAAG,IAAI,CAAC,YAAY,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC;AAEjD,YAAA,KAAK,GAAG,KAAK,IAAI,KAAK,CAAC,KAAK,GAAG,QAAQ,CAAC,KAAK,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;AACzD,YAAA,OAAO,GAAG,OAAO,IAAI,OAAO,CAAC,KAAK,GAAG,QAAQ,CAAC,OAAO,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;AAEjE,YAAA,OAAO,EAAE,IAAI,EAAE,IAAI,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC,IAAI,EAAE,KAAK,EAAE,OAAO,EAAE,CAAC;SAC/D;AAED,QAAA,oBAAoB,CAAC,IAAI,EAAA;AACrB,YAAA,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC;AACxB,gBAAA,OAAO,IAAI,CAAC;YAEhB,IAAI,KAAK,GAAG,IAAI,CAAC,YAAY,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;YAC7C,IAAI,OAAO,GAAG,IAAI,CAAC,YAAY,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC;AAEjD,YAAA,KAAK,GAAG,KAAK,IAAI,KAAK,CAAC,KAAK,GAAG,QAAQ,CAAC,KAAK,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;AACzD,YAAA,OAAO,GAAG,OAAO,IAAI,OAAO,CAAC,KAAK,GAAG,QAAQ,CAAC,OAAO,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;YAEjE,MAAM,MAAM,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;YAEzC,IAAI,MAAM,GAAG,CAAC,CAAC;YACf,IAAI,QAAQ,GAAG,CAAC,CAAC;YACjB,IAAI,UAAU,GAAG,CAAC,CAAC;YACnB,IAAI,WAAW,GAAG,CAAC,CAAC;AACpB,YAAA,IAAI,MAAM,GAAG,EAAE,IAAI,EAAE,IAAI,CAAC,IAAI,EAAE,IAAI,EAAE,SAAS,EAAE,KAAK,EAAE,CAAC,EAAE,IAAI,EAAE,CAAC,EAAE,OAAO,EAAE,EAAE,EAAE,KAAK,EAAE,OAAO,EAAE,CAAC;AAElG,YAAA,KAAK,IAAI,EAAE,GAAG,CAAC,EAAE,EAAE,GAAG,MAAM,CAAC,OAAO,CAAC,MAAM,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE;gBACxD,IAAI,MAAM,GAAG,MAAM,CAAC,OAAO,CAAC,EAAE,CAAC,CAAC;AAChC,gBAAA,IAAI,IAAI,GAAG,MAAM,CAAC,IAAI,CAAC;gBAEvB,IAAI,IAAI,GAAG,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,CAAC;AACpC,gBAAA,IAAI,CAAC,IAAI;oBACL,SAAS;AAEb,gBAAA,IAAI,IAAI,GAAG,MAAM,CAAC,IAAI,CAAC;AACvB,gBAAA,IAAI,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;AACvB,gBAAA,IAAI,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;gBACrB,MAAM,GAAG,IAAI,CAAC,QAAQ,CAAC,KAAK,EAAE,MAAM,GAAG,QAAQ,CAAC,CAAC;gBACjD,QAAQ,GAAG,IAAI,CAAC;gBAChB,UAAU,GAAG,MAAM,CAAC;gBACpB,WAAW,GAAG,IAAI,CAAC,GAAG,CAAC,WAAW,EAAE,KAAK,CAAC,CAAC;AAE3C,gBAAA,IAAI,CAAC,GAAG,EAAE,IAAI,EAAE,MAAM,EAAE,IAAI,EAAE,IAAI,EAAE,MAAM,EAAE,CAAC;AAC7C,gBAAA,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;AAC1B,aAAA;AAED,YAAA,MAAM,CAAC,IAAI,GAAG,IAAI,CAAC,QAAQ,CAAC,WAAW,EAAE,UAAU,GAAG,QAAQ,CAAC,CAAC;AAChE,YAAA,MAAM,CAAC,KAAK,GAAG,WAAW,CAAC;AAE3B,YAAA,OAAO,MAAM,CAAC;SACjB;AAED,QAAA,WAAW,CAAC,IAAI,EAAA;YACZ,IAAI,YAAY,GAAG,CAAC,CAAC;YACrB,MAAM,QAAQ,GAAG,IAAI,CAAC,YAAY,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;AACjD,YAAA,IAAI,QAAQ;AACR,gBAAA,YAAY,GAAG,QAAQ,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;YAE5C,IAAI,aAAa,GAAG,CAAC,CAAC;YACtB,MAAM,SAAS,GAAG,IAAI,CAAC,YAAY,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;AACnD,YAAA,IAAI,SAAS;AACT,gBAAA,aAAa,GAAG,QAAQ,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;AAE9C,YAAA,IAAI,IAAI,CAAC,KAAK,IAAI,QAAQ;AACtB,gBAAA,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;AAErB,YAAA,IAAI,IAAI,CAAC,KAAK,IAAI,MAAM,EAAE;gBACtB,MAAM,KAAK,GAAG,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;AACvC,gBAAA,IAAI,KAAK,EAAE;oBACP,IAAI,GAAG,KAAK,CAAC;AAChB,iBAAA;AAAM,qBAAA;oBACH,MAAM,MAAM,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;AACzC,oBAAA,IAAI,MAAM;wBACN,IAAI,GAAG,MAAM,CAAC;AACrB,iBAAA;AACJ,aAAA;YAED,MAAM,IAAI,GAAG,WAAW,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;AAC7C,YAAA,IAAI,IAAI,EAAE;gBACN,OAAO;oBACH,KAAK,EAAE,IAAI,CAAC,GAAG,CAAC,aAAa,EAAE,IAAI,CAAC,KAAK,CAAC;oBAC1C,IAAI,EAAE,IAAI,CAAC,GAAG,CAAC,YAAY,EAAE,IAAI,CAAC,IAAI,CAAC;iBAC1C,CAAC;AACL,aAAA;AAED,YAAA,IAAI,IAAI,CAAC,IAAI,IAAI,OAAO,EAAE;gBACtB,IAAI,KAAK,GAAG,CAAC,CAAC;gBACd,IAAI,IAAI,GAAG,CAAC,CAAC;;;;;;;;;;;gBAWb,MAAM,CAAC,GAAG,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;AACxC,gBAAA,IAAI,CAAC,EAAE;AACH,oBAAA,IAAI,GAAG,CAAC,CAAC,IAAI,CAAC;AACd,oBAAA,KAAK,GAAG,CAAC,CAAC,KAAK,CAAC;AACnB,iBAAA;gBAED,MAAM,CAAC,GAAG,QAAQ,CAAC,IAAI,CAAC,KAAK,IAAI,CAAC,CAAC,CAAC;gBAEpC,MAAM,MAAM,GAAG,IAAI,CAAC,YAAY,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;AACjD,gBAAA,IAAI,MAAM,EAAE;oBACR,IAAI,GAAG,CAAC,GAAG,QAAQ,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;AACrC,iBAAA;AAAM,qBAAA;oBACH,IAAI,GAAG,CAAC,GAAG,IAAI,CAAC,QAAQ,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;AACzC,iBAAA;AAED,gBAAA,IAAI,YAAY;oBACZ,IAAI,GAAG,YAAY,CAAC;gBAExB,OAAO;oBACH,KAAK,EAAE,IAAI,CAAC,GAAG,CAAC,aAAa,EAAE,KAAK,CAAC;oBACrC,IAAI,EAAE,IAAI,CAAC,GAAG,CAAC,YAAY,EAAE,IAAI,CAAC;iBACrC,CAAC;AACL,aAAA;AAED,YAAA,IAAI,IAAI,CAAC,KAAK,IAAI,QAAQ,EAAE;gBACxB,IAAI,KAAK,GAAG,CAAC,CAAC;gBACd,IAAI,IAAI,GAAG,CAAC,CAAC;;;;gBAIb,IAAI,MAAM,GAAG,CAAC,CAAC;gBACf,IAAI,QAAQ,GAAG,CAAC,CAAC;gBACjB,IAAI,UAAU,GAAG,CAAC,CAAC;AACnB,gBAAA,KAAK,MAAM,CAAC,IAAI,IAAI,CAAC,OAAO,EAAE;oBAC1B,MAAM,EAAE,GAAG,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC;oBAC/B,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;AAClC,oBAAA,MAAM,GAAG,IAAI,CAAC,QAAQ,CAAC,EAAE,CAAC,KAAK,EAAE,MAAM,GAAG,QAAQ,CAAC,CAAC;AACpD,oBAAA,QAAQ,GAAG,EAAE,CAAC,IAAI,CAAC;oBACnB,UAAU,GAAG,MAAM,CAAC;AACvB,iBAAA;gBACD,IAAI,GAAG,IAAI,CAAC,QAAQ,CAAC,KAAK,EAAE,UAAU,GAAG,QAAQ,CAAC,CAAC;gBAEnD,OAAO;oBACH,KAAK,EAAE,IAAI,CAAC,GAAG,CAAC,aAAa,EAAE,KAAK,CAAC;oBACrC,IAAI,EAAE,IAAI,CAAC,GAAG,CAAC,YAAY,EAAE,IAAI,CAAC;iBACrC,CAAC;AACL,aAAA;AAED,YAAA,OAAO,IAAI,CAAC;SACf;QAED,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAA;YACT,OAAO,IAAI,CAAC,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC;SAC/B;AACJ,KAAA;AA9XY,IAAA,WAAA,CAAA,WAAW,cA8XvB,CAAA;;;;;;;;;;;;;;;;IAkBD,WAAW,CAAC,QAAQ,GAAG;QACnB,KAAK,EAAE,EAAE,KAAK,EAAE,CAAC,EAAE,IAAI,EAAE,CAAC,EAAE;QAC5B,KAAK,EAAE,EAAE,KAAK,EAAE,CAAC,EAAE,IAAI,EAAE,CAAC,EAAE;QAC5B,KAAK,EAAE,EAAE,KAAK,EAAE,CAAC,EAAE,IAAI,EAAE,CAAC,EAAE;QAC5B,QAAQ,EAAE,EAAE,KAAK,EAAE,CAAC,EAAE,IAAI,EAAE,CAAC,EAAE;QAC/B,MAAM,EAAE,EAAE,KAAK,EAAE,CAAC,EAAE,IAAI,EAAE,CAAC,EAAE;QAC7B,MAAM,EAAE,EAAE,KAAK,EAAE,EAAE,EAAE,IAAI,EAAE,EAAE,EAAE;QAC/B,MAAM,EAAE,EAAE,KAAK,EAAE,EAAE,EAAE,IAAI,EAAE,EAAE,EAAE;QAC/B,QAAQ,EAAE,EAAE,KAAK,EAAE,CAAC,EAAE,IAAI,EAAE,EAAE,EAAE;QAChC,QAAQ,EAAE,EAAE,KAAK,EAAE,CAAC,EAAE,IAAI,EAAE,EAAE,EAAE;QAChC,QAAQ,EAAE,EAAE,KAAK,EAAE,CAAC,EAAE,IAAI,EAAE,EAAE,EAAE;QAChC,QAAQ,EAAE,EAAE,KAAK,EAAE,EAAE,EAAE,IAAI,EAAE,EAAE,EAAE;QACjC,QAAQ,EAAE,EAAE,KAAK,EAAE,EAAE,EAAE,IAAI,EAAE,EAAE,EAAE;QACjC,QAAQ,EAAE,EAAE,KAAK,EAAE,EAAE,EAAE,IAAI,EAAE,EAAE,EAAE;QACjC,QAAQ,EAAE,EAAE,KAAK,EAAE,EAAE,EAAE,IAAI,EAAE,EAAE,EAAE;QACjC,QAAQ,EAAE,EAAE,KAAK,EAAE,EAAE,EAAE,IAAI,EAAE,EAAE,EAAE;QACjC,QAAQ,EAAE,EAAE,KAAK,EAAE,EAAE,EAAE,IAAI,EAAE,EAAE,EAAE;KACpC,CAAC;IAEF,WAAW,CAAC,YAAY,GAAG,KAAK,CAAC,gBAAgB,CAAC,GAAG,CAAC,CAAC,CAAC,KAAI,EAAG,OAAO,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;IACjF,WAAW,CAAC,YAAY,GAAG,KAAK,CAAC,YAAY,CAAC,GAAG,CAAC,CAAC,CAAC,KAAI,EAAG,OAAO,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;;AAGjF,CAAC,EAxyEgB,WAAW,KAAX,WAAW,GAwyE3B,EAAA,CAAA,CAAA;;;;"}